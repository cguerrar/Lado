@{
    var modo = ViewBag.Modo ?? "story";
    var titulo = ViewBag.Titulo ?? "Crear Historia";
    var textoPublicar = ViewBag.TextoPublicar ?? "Publicar";
    var usuarioVerificado = ViewBag.UsuarioVerificado ?? false;
    ViewData["Title"] = titulo;
    Layout = null; // Full screen sin layout
}
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>@ViewData["Title"] - Lado</title>
    <link rel="icon" type="image/png" href="/images/favicon.png" />

    <!-- Google Fonts para variedad de tipografías -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Dancing+Script:wght@700&family=Lobster&family=Montserrat:wght@600;800&family=Oswald:wght@600&family=Pacifico&family=Permanent+Marker&family=Playfair+Display:wght@700&family=Poppins:wght@600;700&family=Roboto:wght@500;700&family=Satisfy&family=Anton&display=swap" rel="stylesheet">

    <!-- Fabric.js para canvas interactivo -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <!-- HEIC to JPEG converter para imágenes de iPhone -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>

    <style>
        /* ========================================
           TEMA - Sincronizado con el sistema
           ======================================== */
        :root {
            /* Colores base - Modo claro (default) */
            --primary: #4682B4;
            --primary-dark: #36648B;
            --primary-light: #B0C4DE;
            --primary-hover: #5a9fd4;
            --primary-rgb: 70, 130, 180;
            --danger: #dc3545;
            --success: #28a745;

            /* Modo claro */
            --bg: #f1f5f9;
            --bg-secondary: #e2e8f0;
            --surface: #ffffff;
            --surface-hover: #f8fafc;
            --surface-elevated: #ffffff;
            --fg: #0f172a;
            --fg-secondary: #475569;
            --muted: #64748b;
            --line: #e2e8f0;
            --line-light: #f1f5f9;
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-strong: rgba(0, 0, 0, 0.15);
            --glass-bg: rgba(255, 255, 255, 0.8);
            --glass-border: rgba(255, 255, 255, 0.3);
            --canvas-bg: #1a1a1a;
        }

        [data-theme="dark"] {
            /* Modo oscuro */
            --bg: #0f172a;
            --bg-secondary: #1e293b;
            --surface: #1e293b;
            --surface-hover: #334155;
            --surface-elevated: #334155;
            --fg: #f8fafc;
            --fg-secondary: #e2e8f0;
            --muted: #94a3b8;
            --line: #334155;
            --line-light: #1e293b;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-strong: rgba(0, 0, 0, 0.5);
            --glass-bg: rgba(30, 41, 59, 0.85);
            --glass-border: rgba(51, 65, 85, 0.5);
            --canvas-bg: #000000;
            --primary: #6CA6CD;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--fg);
            overflow: hidden;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height para móviles */
            width: 100vw;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* ========================================
           LAYOUT PRINCIPAL
           ======================================== */
        .story-editor {
            display: flex;
            height: 100vh;
            height: 100dvh;
            width: 100vw;
            position: relative;
        }

        /* Panel izquierdo - Herramientas (Desktop) */
        .tools-panel {
            width: 72px;
            background: var(--surface);
            border-right: 1px solid var(--line);
            display: flex;
            flex-direction: column;
            padding: 16px 12px;
            gap: 6px;
            transition: all 0.3s ease;
            z-index: 50;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            border: none;
            background: transparent;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--muted);
            transition: all 0.2s ease;
            position: relative;
        }

        .tool-btn:hover {
            background: var(--surface-hover);
            color: var(--fg);
            transform: scale(1.05);
        }

        .tool-btn:active {
            transform: scale(0.95);
        }

        .tool-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 12px rgba(var(--primary-rgb), 0.3);
        }

        .tool-btn svg {
            width: 22px;
            height: 22px;
        }

        /* Tooltip para herramientas */
        .tool-btn::after {
            content: attr(title);
            position: absolute;
            left: 100%;
            margin-left: 8px;
            padding: 6px 10px;
            background: var(--surface-elevated);
            color: var(--fg);
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            box-shadow: 0 4px 12px var(--shadow);
            border: 1px solid var(--line);
            z-index: 100;
        }

        .tool-btn:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .tools-divider {
            height: 1px;
            background: var(--line);
            margin: 8px 4px;
        }

        /* Botón de salir del editor */
        .close-editor-btn {
            background: rgba(220, 53, 69, 0.1) !important;
            color: var(--danger) !important;
        }

        .close-editor-btn:hover {
            background: var(--danger) !important;
            color: white !important;
        }

        .desktop-only {
            display: block;
        }

        /* Panel central - Canvas */
        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            position: relative;
            padding: 20px;
            transition: background-color 0.3s ease;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 380px;
            aspect-ratio: 9/16;
            background: var(--canvas-bg);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 20px 60px var(--shadow-strong), 0 0 0 1px var(--line);
            transition: box-shadow 0.3s ease;
        }

        .canvas-wrapper:hover {
            box-shadow: 0 25px 70px var(--shadow-strong), 0 0 0 1px var(--primary);
        }

        /* Video de fondo */
        #videoBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            display: none;
            transform-origin: center center;
            transition: filter 0.3s ease, transform 0.3s ease;
        }

        #videoBackground.active {
            display: block;
        }

        /* Canvas de Fabric.js */
        #storyCanvas {
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            z-index: 2;
        }

        /* El contenedor que Fabric.js genera automaticamente */
        .canvas-wrapper > .canvas-container {
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            z-index: 2;
        }

        /* Upper canvas de Fabric (el que maneja interacciones) */
        .canvas-wrapper .upper-canvas {
            z-index: 3 !important;
        }

        /* Panel derecho - Opciones (Desktop) */
        .options-panel {
            width: 340px;
            background: var(--surface);
            border-left: 1px solid var(--line);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease;
            z-index: 50;
        }

        .options-header {
            padding: 18px 20px;
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--surface);
        }

        .options-header-title-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }

        .options-header h3 {
            font-size: 15px;
            font-weight: 600;
            color: var(--fg);
            flex-shrink: 0;
        }

        /* Barra de progreso BeatSync en header */
        .beatsync-header-progress {
            display: none;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .beatsync-header-progress.active {
            display: flex;
        }

        .beatsync-header-progress-bar {
            flex: 1;
            height: 6px;
            background: var(--line);
            border-radius: 3px;
            overflow: hidden;
            min-width: 80px;
        }

        .beatsync-header-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .beatsync-header-progress-text {
            font-size: 11px;
            color: var(--muted);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .options-header .close-btn,
        .options-header .expand-btn {
            display: none;
        }

        .options-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        @@media (max-width: 768px) {
            .options-header .close-btn,
            .options-header .expand-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 36px;
                height: 36px;
                border: none;
                background: var(--bg-secondary);
                border-radius: 10px;
                color: var(--fg);
                cursor: pointer;
                transition: all 0.2s;
            }

            .options-header .expand-btn:hover,
            .options-header .close-btn:hover {
                background: var(--surface-hover);
                transform: scale(1.05);
            }

            .options-header .expand-btn:active,
            .options-header .close-btn:active {
                transform: scale(0.95);
            }

            /* Cuando está expandido, mostrar el icono de contraer */
            .options-panel.expanded .expand-btn .expand-icon {
                display: none;
            }

            .options-panel.expanded .expand-btn .collapse-icon {
                display: block !important;
            }
        }

        .options-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            scrollbar-width: thin;
            scrollbar-color: var(--line) transparent;
        }

        .options-content::-webkit-scrollbar {
            width: 6px;
        }

        .options-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .options-content::-webkit-scrollbar-thumb {
            background: var(--line);
            border-radius: 3px;
        }

        .options-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--line);
            display: flex;
            gap: 12px;
            background: var(--surface);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            flex: 1;
            box-shadow: 0 4px 12px rgba(var(--primary-rgb), 0.25);
        }

        .btn-outline-primary {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 10px 14px;
            flex: 0;
        }

        .btn-outline-primary:hover:not(:disabled) {
            background: var(--primary);
            color: white;
        }

        .btn-outline-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(var(--primary-rgb), 0.35);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--surface-hover);
            color: var(--fg);
            border: 1px solid var(--line);
        }

        .btn-secondary:hover {
            background: var(--line);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* ========================================
           SECCIONES DE OPCIONES
           ======================================== */
        .option-section {
            display: none;
        }

        .option-section.active {
            display: block;
        }

        /* publishOptions ahora está oculto - se muestra en modal de publicación */
        #publishOptions {
            display: none !important;
        }

        /* ========================================
           MODAL DE PUBLICACIÓN
           ======================================== */
        .publish-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            padding: 20px;
        }

        .publish-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .publish-modal {
            background: var(--surface);
            border-radius: 20px;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(20px) scale(0.95);
            transition: transform 0.3s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .publish-modal-overlay.active .publish-modal {
            transform: translateY(0) scale(1);
        }

        .publish-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .publish-modal-header h3 {
            font-size: 18px;
            font-weight: 600;
            color: var(--fg);
            margin: 0;
        }

        .publish-modal-close {
            width: 36px;
            height: 36px;
            border: none;
            background: var(--bg-secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--fg);
            transition: all 0.2s;
        }

        .publish-modal-close:hover {
            background: var(--line);
        }

        .publish-modal-body {
            padding: 24px;
        }

        .publish-section {
            margin-bottom: 24px;
        }

        .publish-section:last-child {
            margin-bottom: 0;
        }

        .publish-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .publish-lado-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .publish-lado-option {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .publish-lado-option:hover {
            border-color: var(--muted);
        }

        .publish-lado-option.selected {
            border-color: var(--primary);
            background: rgba(var(--primary-rgb), 0.08);
        }

        .publish-lado-option svg {
            width: 32px;
            height: 32px;
            flex-shrink: 0;
            color: var(--muted);
        }

        .publish-lado-option.selected svg {
            color: var(--primary);
        }

        .publish-lado-info {
            flex: 1;
        }

        .publish-lado-name {
            font-size: 15px;
            font-weight: 600;
            color: var(--fg);
            margin-bottom: 2px;
        }

        .publish-lado-desc {
            font-size: 12px;
            color: var(--muted);
        }

        .publish-lado-check {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .publish-lado-option.selected .publish-lado-check {
            background: var(--primary);
            border-color: var(--primary);
        }

        .publish-lado-check svg {
            width: 14px;
            height: 14px;
            color: white;
            opacity: 0;
        }

        .publish-lado-option.selected .publish-lado-check svg {
            opacity: 1;
        }

        .publish-toggle-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg);
            border-radius: 12px;
            cursor: pointer;
        }

        .publish-toggle-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .publish-toggle-info svg {
            width: 22px;
            height: 22px;
            color: var(--primary);
        }

        .publish-toggle-text h4 {
            font-size: 14px;
            font-weight: 500;
            color: var(--fg);
            margin: 0 0 2px 0;
        }

        .publish-toggle-text p {
            font-size: 11px;
            color: var(--muted);
            margin: 0;
        }

        .publish-toggle-switch {
            width: 48px;
            height: 28px;
            background: var(--line);
            border-radius: 14px;
            position: relative;
            transition: all 0.2s;
            cursor: pointer;
        }

        .publish-toggle-switch.active {
            background: var(--primary);
        }

        .publish-toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .publish-toggle-switch.active::after {
            left: 23px;
        }

        .publish-modal-footer {
            padding: 16px 24px 24px;
            display: flex;
            gap: 12px;
        }

        .publish-modal-footer .btn {
            flex: 1;
            padding: 14px 20px;
            font-size: 15px;
        }

        /* Responsive para modal */
        @@media (max-width: 480px) {
            .publish-modal-overlay {
                padding: 0;
                align-items: flex-end;
            }

            .publish-modal {
                max-width: 100%;
                border-radius: 20px 20px 0 0;
                max-height: 85vh;
            }

            .publish-modal-overlay.active .publish-modal {
                transform: translateY(0);
            }
        }

        .option-group {
            margin-bottom: 20px;
        }

        .option-label {
            font-size: 12px;
            color: var(--muted);
            text-transform: uppercase;
            margin-bottom: 8px;
            display: block;
        }

        /* Input de texto */
        .text-input {
            width: 100%;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--line);
            border-radius: 8px;
            color: var(--fg);
            font-size: 14px;
            resize: none;
        }

        .text-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Selector de fuentes */
        .font-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .font-option {
            padding: 10px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .font-option:hover {
            border-color: var(--muted);
        }

        .font-option.selected {
            border-color: var(--primary);
            background: rgba(70, 130, 180, 0.1);
        }

        /* Selector de colores */
        .color-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .color-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: var(--fg);
        }

        /* Slider de tamaño */
        .size-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: var(--line);
            outline: none;
        }

        .size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        /* Grid de stickers */
        .sticker-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            max-height: calc(100vh - 280px);
            min-height: 350px;
            overflow-y: auto;
            padding: 4px;
        }

        .sticker-item {
            width: 100%;
            aspect-ratio: 1;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .sticker-item:hover {
            background: var(--surface-hover);
            transform: scale(1.1);
            border-color: var(--primary);
        }

        /* ========================================
           PANEL DE GIFs
           ======================================== */
        .gif-search-container {
            position: relative;
        }

        .gif-search-container .text-input {
            padding-right: 40px;
        }

        .gif-search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--muted);
            pointer-events: none;
        }

        .gif-search-icon svg {
            width: 18px;
            height: 18px;
        }

        .gif-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .gif-category-btn {
            padding: 6px 12px;
            border: 1px solid var(--line);
            background: var(--bg);
            border-radius: 20px;
            font-size: 12px;
            color: var(--fg-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .gif-category-btn:hover {
            background: var(--surface-hover);
            border-color: var(--muted);
        }

        .gif-category-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .gif-grid-container {
            max-height: calc(100vh - 420px);
            min-height: 300px;
            overflow-y: auto;
            border-radius: 8px;
        }

        .gif-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 4px;
        }

        .gif-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            background: var(--bg);
            aspect-ratio: 1;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .gif-item:hover {
            transform: scale(1.03);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .gif-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .gif-loading {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: var(--muted);
            gap: 12px;
        }

        .gif-loading .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--line);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .gif-no-results {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px;
            color: var(--muted);
        }

        .giphy-attribution {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px;
            font-size: 11px;
            color: var(--muted);
            border-top: 1px solid var(--line);
            margin-top: 12px;
        }

        .giphy-attribution img {
            opacity: 0.7;
        }

        /* ========================================
           PANEL DE EFECTOS DE VIDEO
           ======================================== */
        .effects-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .effect-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 12px 8px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--fg);
        }

        .effect-btn:hover {
            background: var(--surface-hover);
            border-color: var(--muted);
            transform: translateY(-2px);
        }

        .effect-btn.active {
            border-color: var(--primary);
            background: rgba(var(--primary-rgb), 0.1);
        }

        .effect-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: var(--primary);
        }

        .effect-icon svg {
            color: var(--primary);
        }

        .effect-btn span {
            font-size: 11px;
            color: var(--fg-secondary);
        }

        .effect-preview {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
            overflow: hidden;
        }

        .effect-preview.effect-none {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .effect-preview.effect-glitch {
            background: linear-gradient(135deg, #ff0080 0%, #00ff80 50%, #0080ff 100%);
            animation: glitch-preview 0.5s infinite;
        }

        .effect-preview.effect-vhs {
            background: linear-gradient(135deg, #333 0%, #666 100%);
            position: relative;
        }

        .effect-preview.effect-vhs::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.3) 2px,
                rgba(0,0,0,0.3) 4px
            );
        }

        .effect-preview.effect-retro {
            background: linear-gradient(135deg, #d4a373 0%, #faedcd 100%);
            filter: sepia(50%);
        }

        .effect-preview.effect-cinematic {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        .effect-preview.effect-cinematic::before,
        .effect-preview.effect-cinematic::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 8px;
            background: black;
        }

        .effect-preview.effect-cinematic::before { top: 0; }
        .effect-preview.effect-cinematic::after { bottom: 0; }

        .effect-preview.effect-noir {
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);
            filter: grayscale(100%) contrast(120%);
        }

        .effect-info {
            margin-top: 16px;
            padding: 12px;
            background: var(--bg);
            border-radius: 8px;
            text-align: center;
        }

        .effect-info small {
            color: var(--muted);
            font-size: 11px;
        }

        @@keyframes glitch-preview {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 1px); }
            40% { transform: translate(2px, -1px); }
            60% { transform: translate(-1px, 2px); }
            80% { transform: translate(1px, -2px); }
        }

        /* Efectos CSS aplicados al video */
        .video-effect-glitch {
            animation: video-glitch 0.3s infinite;
        }

        .video-effect-vhs {
            filter: saturate(120%) contrast(110%);
        }

        .video-effect-vhs::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.1) 2px,
                rgba(0,0,0,0.1) 4px
            );
            pointer-events: none;
            z-index: 10;
        }

        .video-effect-retro {
            filter: sepia(40%) saturate(80%) brightness(110%);
        }

        .video-effect-cinematic {
            filter: contrast(110%) saturate(90%);
        }

        .video-effect-noir {
            filter: grayscale(100%) contrast(120%);
        }

        @@keyframes video-glitch {
            0%, 100% {
                filter: hue-rotate(0deg);
                transform: translate(0);
            }
            25% {
                filter: hue-rotate(90deg);
                transform: translate(-2px, 1px);
            }
            50% {
                filter: hue-rotate(180deg);
                transform: translate(2px, -1px);
            }
            75% {
                filter: hue-rotate(270deg);
                transform: translate(-1px, -1px);
            }
        }

        /* ========================================
           ANIMACIONES DE TEXTO
           ======================================== */
        .text-animation-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .text-anim-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 10px 6px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--fg);
        }

        .text-anim-btn:hover {
            background: var(--surface-hover);
            border-color: var(--muted);
        }

        .text-anim-btn.active {
            border-color: var(--primary);
            background: rgba(var(--primary-rgb), 0.1);
        }

        .anim-preview {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .text-anim-btn span:last-child {
            font-size: 10px;
            color: var(--fg-secondary);
        }

        /* Demos de animación de entrada */
        .anim-demo-fade {
            animation: demo-fade 2s infinite;
        }

        .anim-demo-slide {
            animation: demo-slide 2s infinite;
        }

        .anim-demo-bounce {
            animation: demo-bounce 1.5s infinite;
        }

        .anim-demo-typewriter {
            overflow: hidden;
            animation: demo-typewriter 2s steps(2) infinite;
        }

        .anim-demo-scale {
            animation: demo-scale 2s infinite;
        }

        /* Demos de efectos continuos */
        .effect-demo-glow {
            animation: demo-glow 1.5s ease-in-out infinite;
        }

        .effect-demo-shadow {
            text-shadow: 2px 2px 0 rgba(0,0,0,0.3), 4px 4px 0 rgba(0,0,0,0.2);
            animation: demo-shadow 2s infinite;
        }

        .effect-demo-colorshift {
            animation: demo-colorshift 3s linear infinite;
        }

        .effect-demo-float {
            animation: demo-float 2s ease-in-out infinite;
        }

        .effect-demo-shake {
            animation: demo-shake 0.5s infinite;
        }

        @@keyframes demo-fade {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        @@keyframes demo-slide {
            0%, 100% { transform: translateY(5px); opacity: 0.5; }
            50% { transform: translateY(0); opacity: 1; }
        }

        @@keyframes demo-bounce {
            0%, 100% { transform: translateY(0); }
            25% { transform: translateY(-5px); }
            50% { transform: translateY(2px); }
            75% { transform: translateY(-2px); }
        }

        @@keyframes demo-typewriter {
            0% { width: 0; }
            50%, 100% { width: 100%; }
        }

        @@keyframes demo-scale {
            0%, 100% { transform: scale(0.7); opacity: 0.5; }
            50% { transform: scale(1); opacity: 1; }
        }

        @@keyframes demo-glow {
            0%, 100% { text-shadow: 0 0 5px currentColor; }
            50% { text-shadow: 0 0 15px currentColor, 0 0 25px currentColor; }
        }

        @@keyframes demo-shadow {
            0%, 100% { text-shadow: 2px 2px 0 rgba(0,0,0,0.3); }
            50% { text-shadow: 4px 4px 0 rgba(0,0,0,0.3), 6px 6px 0 rgba(0,0,0,0.15); }
        }

        @@keyframes demo-colorshift {
            0% { color: #ff3b5c; }
            33% { color: #00d4ff; }
            66% { color: #ffdd00; }
            100% { color: #ff3b5c; }
        }

        @@keyframes demo-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

        @@keyframes demo-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        /* Clases para aplicar a textos en canvas (durante render) */
        .text-anim-fade { animation: text-fade-in 0.5s ease-out forwards; }
        .text-anim-slide-up { animation: text-slide-up 0.6s ease-out forwards; }
        .text-anim-slide-down { animation: text-slide-down 0.6s ease-out forwards; }
        .text-anim-bounce { animation: text-bounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; }
        .text-anim-scale { animation: text-scale 0.5s ease-out forwards; }
        .text-anim-rotate { animation: text-rotate 0.6s ease-out forwards; }

        .text-effect-glow { animation: text-glow 1.5s ease-in-out infinite; }
        .text-effect-shadow3d { animation: text-shadow3d 2s ease-in-out infinite; }
        .text-effect-colorshift { animation: text-colorshift 4s linear infinite; }
        .text-effect-float { animation: text-float 3s ease-in-out infinite; }
        .text-effect-shake { animation: text-shake 0.3s infinite; }

        @@keyframes text-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @@keyframes text-slide-up {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @@keyframes text-slide-down {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @@keyframes text-bounce {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        @@keyframes text-scale {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @@keyframes text-rotate {
            from { transform: rotate(-180deg) scale(0); opacity: 0; }
            to { transform: rotate(0) scale(1); opacity: 1; }
        }

        @@keyframes text-glow {
            0%, 100% { filter: drop-shadow(0 0 5px currentColor); }
            50% { filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 0 30px currentColor); }
        }

        @@keyframes text-shadow3d {
            0%, 100% {
                filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.5));
            }
            50% {
                filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.4)) drop-shadow(6px 6px 0 rgba(0,0,0,0.2));
            }
        }

        @@keyframes text-colorshift {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
        }

        @@keyframes text-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @@keyframes text-shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            60% { transform: translateX(-2px) rotate(-0.5deg); }
            80% { transform: translateX(2px) rotate(0.5deg); }
        }

        /* Buscador de menciones */
        .mention-search {
            position: relative;
        }

        .mention-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface);
            border: 1px solid var(--line);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .mention-results.active {
            display: block;
        }

        .mention-item {
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .mention-item:hover {
            background: var(--surface-hover);
        }

        .mention-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            background: var(--primary);
        }

        /* ========================================
           MÚSICA - Estilo TikTok
           ======================================== */
        .music-selector {
            background: var(--bg);
            border-radius: 12px;
            overflow: hidden;
        }

        /* Tabs de música */
        .music-tabs {
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--line);
            padding: 0 12px;
            gap: 4px;
        }

        .music-tab {
            padding: 12px 14px;
            font-size: 13px;
            font-weight: 500;
            color: var(--muted);
            background: none;
            border: none;
            cursor: pointer;
            position: relative;
            transition: color 0.2s;
        }

        .music-tab:hover {
            color: var(--fg);
        }

        .music-tab.active {
            color: var(--fg);
            font-weight: 600;
        }

        .music-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 2px;
            background: var(--fg);
            border-radius: 2px;
        }

        .music-search-btn {
            margin-left: auto;
            padding: 8px;
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .music-search-btn:hover {
            background: var(--surface-hover);
            color: var(--fg);
        }

        .music-search-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Búsqueda expandida */
        .music-search-container {
            padding: 10px 12px;
            border-bottom: 1px solid var(--line);
            display: none;
        }

        .music-search-container.active {
            display: block;
        }

        .music-search-input {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--line);
            border-radius: 20px;
            background: var(--bg-secondary);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .music-search-input:focus {
            border-color: var(--primary);
        }

        .music-search-input::placeholder {
            color: var(--muted);
        }

        /* Lista de música */
        .music-list-container {
            max-height: calc(100vh - 380px);
            min-height: 300px;
            overflow-y: auto;
            padding: 8px 0;
        }

        .music-item {
            padding: 12px 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: background 0.15s;
            border-radius: 8px;
            margin: 4px 0;
        }

        .music-item:hover {
            background: var(--surface-hover);
        }

        .music-item.playing .music-title {
            color: #fe2c55;
        }

        .music-item.selected {
            background: rgba(254, 44, 85, 0.1);
            border: 1px solid rgba(254, 44, 85, 0.3);
        }

        .music-cover {
            width: 52px;
            height: 52px;
            border-radius: 8px;
            background: var(--line);
            object-fit: cover;
            flex-shrink: 0;
        }

        .music-info {
            flex: 1;
            min-width: 0;
        }

        .music-title-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .music-playing-icon {
            display: none;
            color: #fe2c55;
        }

        .music-item.playing .music-playing-icon {
            display: flex;
        }

        .music-playing-icon svg {
            width: 14px;
            height: 14px;
        }

        .music-title {
            font-weight: 600;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--fg);
        }

        .music-meta {
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 3px;
        }

        .music-meta span {
            margin-right: 4px;
        }

        .music-meta span:not(:last-child)::after {
            content: '·';
            margin-left: 4px;
            color: var(--muted);
        }

        /* Acciones de música */
        .music-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        .music-action-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .music-action-btn:hover {
            background: var(--surface-hover);
            color: var(--fg);
        }

        .music-action-btn.favorited {
            color: #fe2c55;
        }

        .music-action-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Estado vacío */
        .music-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--muted);
        }

        .music-empty svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .music-empty p {
            font-size: 14px;
        }

        /* =============================================
           AUDIO CUTTER - Waveform Editor
           ============================================= */
        .audio-cutter {
            background: linear-gradient(135deg, #1a9be6 0%, #0d7bc5 100%);
            border-radius: 12px;
            padding: 14px;
            color: white;
        }

        .audio-cutter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .audio-cutter-filename {
            font-weight: 600;
            max-width: 70%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .audio-cutter-info {
            opacity: 0.8;
            font-size: 11px;
        }

        .btn-remove-music {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 8px;
        }

        .btn-remove-music:hover {
            background: rgba(239, 68, 68, 0.8);
        }

        .btn-remove-music svg {
            width: 14px;
            height: 14px;
        }

        /* Waveform container */
        .waveform-container {
            position: relative;
            height: 70px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Selection overlay */
        .waveform-selection {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(45, 212, 191, 0.4);
            border-left: 3px solid #2dd4bf;
            border-right: 3px solid #2dd4bf;
        }

        /* Selection handles - Mejorados para táctil */
        .selection-handle {
            position: absolute;
            top: -10px; /* Extender área táctil arriba */
            width: 44px; /* Mínimo recomendado para táctil */
            height: calc(100% + 20px); /* Extender área táctil */
            cursor: ew-resize;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            /* Área táctil invisible más grande */
            background: transparent;
        }

        .selection-handle .handle-bar {
            width: 6px;
            height: 50px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            pointer-events: none;
            transition: all 0.15s ease;
        }

        .selection-handle:hover .handle-bar,
        .selection-handle:active .handle-bar,
        .selection-handle.dragging .handle-bar {
            background: #2dd4bf;
            transform: scaleY(1.15);
            width: 8px;
        }

        .selection-handle.dragging {
            z-index: 30;
        }

        .selection-handle.handle-left {
            left: 0;
            transform: translateX(-50%);
        }

        .selection-handle.handle-right {
            right: 0;
            transform: translateX(50%);
        }

        /* En móvil, hacer handles aún más fáciles de tocar */
        @@media (max-width: 768px) {
            .selection-handle {
                width: 50px;
            }

            .selection-handle .handle-bar {
                width: 8px;
                height: 60px;
                border-radius: 5px;
            }
        }

        /* Playhead */
        .waveform-playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: white;
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        /* Waveform time display */
        .waveform-time {
            position: absolute;
            top: 5px;
            left: 6px;
            background: rgba(0,0,0,0.6);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            z-index: 10;
        }

        /* Controls row */
        .audio-cutter-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .cutter-play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: transform 0.15s;
        }

        .cutter-play-btn:hover {
            transform: scale(1.05);
        }

        .cutter-play-btn:active {
            transform: scale(0.95);
        }

        .cutter-play-btn svg {
            width: 18px;
            height: 18px;
            fill: #1a9be6;
        }

        .cutter-play-btn .pause-icon {
            display: none;
        }

        .cutter-play-btn.playing .play-icon {
            display: none;
        }

        .cutter-play-btn.playing .pause-icon {
            display: block;
        }

        /* Time inputs */
        .cutter-time-inputs {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .time-input-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .time-input-group label {
            font-size: 9px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .time-input {
            width: 58px;
            padding: 5px 6px;
            border: none;
            border-radius: 4px;
            background: rgba(255,255,255,0.15);
            color: white;
            font-size: 11px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            text-align: center;
        }

        .time-input:focus {
            outline: none;
            background: rgba(255,255,255,0.25);
        }

        .duration-group .selection-duration {
            font-size: 13px;
            font-weight: 600;
            color: #2dd4bf;
        }

        /* Volume control */
        .cutter-volume {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }

        .cutter-volume svg {
            width: 16px;
            height: 16px;
            opacity: 0.8;
        }

        .cutter-volume .volume-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            outline: none;
        }

        .cutter-volume .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
        }

        .cutter-volume .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
        }

        .cutter-volume .volume-value {
            font-size: 11px;
            opacity: 0.8;
            min-width: 30px;
        }

        /* Cutter hint */
        .cutter-hint {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 11px;
            opacity: 0.7;
        }

        .cutter-hint svg {
            flex-shrink: 0;
            width: 14px;
            height: 14px;
        }

        /* Loading state */
        .audio-cutter.loading .waveform-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-cutter.loading .waveform-container::after {
            content: 'Cargando audio...';
            color: rgba(255,255,255,0.7);
            font-size: 12px;
        }

        .audio-cutter.loading .waveform-canvas,
        .audio-cutter.loading .waveform-selection,
        .audio-cutter.loading .selection-handle {
            display: none;
        }

        /* Botón confirmar música */
        .btn-confirm-music {
            width: 100%;
            padding: 14px 20px;
            margin-top: 12px;
            background: linear-gradient(135deg, #2dd4bf 0%, #14b8a6 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(45, 212, 191, 0.3);
        }

        .btn-confirm-music:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(45, 212, 191, 0.4);
        }

        .btn-confirm-music:active {
            transform: scale(0.98);
        }

        .btn-confirm-music svg {
            width: 18px;
            height: 18px;
        }

        .btn-confirm-music.confirmed {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            pointer-events: none;
        }

        /* Upload música propia */
        .music-upload-section {
            padding: 16px;
            border-bottom: 1px solid var(--line);
        }

        .music-upload-btn {
            width: 100%;
            padding: 16px;
            background: var(--bg-secondary);
            border: 2px dashed var(--line);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--muted);
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .music-upload-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(var(--primary-rgb), 0.05);
        }

        .music-upload-btn svg {
            width: 22px;
            height: 22px;
        }

        .music-upload-btn input[type="file"] {
            display: none;
        }

        /* Diseño mejorado del selector */
        .music-selector {
            background: var(--bg);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--line);
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .music-selector-header {
            padding: 14px 16px;
            background: linear-gradient(135deg, rgba(254, 44, 85, 0.08) 0%, rgba(254, 44, 85, 0.02) 100%);
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .music-selector-header svg {
            width: 22px;
            height: 22px;
            color: #fe2c55;
        }

        .music-selector-header span {
            font-weight: 600;
            font-size: 15px;
        }

        /* Tabs mejorados */
        .music-tabs {
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--line);
            padding: 0;
            gap: 0;
            background: var(--bg-secondary);
        }

        .music-tab {
            flex: 1;
            padding: 12px 8px;
            font-size: 12px;
            font-weight: 500;
            color: var(--muted);
            background: none;
            border: none;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            text-align: center;
        }

        .music-tab:hover {
            color: var(--fg);
            background: rgba(254, 44, 85, 0.05);
        }

        .music-tab.active {
            color: #fe2c55;
            font-weight: 600;
            background: var(--bg);
        }

        .music-tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: #fe2c55;
        }

        .music-search-btn {
            padding: 10px;
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s;
            margin: 0 8px;
            flex-shrink: 0;
        }

        /* Items de música mejorados */
        .music-item {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 14px;
            cursor: pointer;
            transition: all 0.15s;
            border-bottom: 1px solid transparent;
        }

        .music-item:hover {
            background: var(--surface-hover);
        }

        .music-item.selected {
            background: linear-gradient(90deg, rgba(254, 44, 85, 0.1) 0%, rgba(254, 44, 85, 0.02) 100%);
            border-left: 3px solid #fe2c55;
        }

        .music-cover {
            width: 52px;
            height: 52px;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--line) 0%, var(--bg-secondary) 100%);
            object-fit: cover;
            flex-shrink: 0;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .music-title {
            font-weight: 600;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--fg);
            line-height: 1.3;
        }

        .music-meta {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .music-meta .dot {
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: var(--muted);
        }

        /* Herramientas de dibujo */
        .brush-sizes {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .brush-size {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg);
            border: 2px solid var(--line);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .brush-size:hover {
            border-color: var(--muted);
        }

        .brush-size.selected {
            border-color: var(--primary);
        }

        .brush-size-dot {
            border-radius: 50%;
            background: var(--fg);
        }

        /* Grid de estilos de Link */
        .link-styles-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .link-style-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 10px 6px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .link-style-option:hover {
            border-color: var(--muted);
            background: var(--surface-hover);
        }

        .link-style-option.selected {
            border-color: var(--primary);
            background: rgba(70, 130, 180, 0.1);
        }

        .link-style-option span {
            font-size: 10px;
            color: var(--muted);
        }

        /* Previews de estilos de link */
        .link-preview-pill {
            background: var(--primary);
            color: white;
            padding: 4px 10px;
            border-radius: 14px;
            font-size: 9px;
            font-weight: 600;
        }

        .link-preview-rounded {
            background: var(--primary);
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 600;
        }

        .link-preview-square {
            background: var(--primary);
            color: white;
            padding: 4px 10px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: 600;
        }

        .link-preview-outline-pill {
            background: transparent;
            color: white;
            padding: 3px 9px;
            border: 1.5px solid white;
            border-radius: 14px;
            font-size: 9px;
            font-weight: 600;
        }

        .link-preview-outline-square {
            background: transparent;
            color: white;
            padding: 3px 9px;
            border: 1.5px solid white;
            border-radius: 2px;
            font-size: 9px;
            font-weight: 600;
        }

        .link-preview-glass {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            color: white;
            padding: 4px 10px;
            border-radius: 14px;
            font-size: 9px;
            font-weight: 600;
        }

        .link-preview-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 10px;
            border-radius: 14px;
            font-size: 9px;
            font-weight: 600;
        }

        .link-preview-swipe {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 4px 8px;
            border-radius: 14px;
            font-size: 9px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .link-preview-swipe svg {
            transform: rotate(-90deg);
        }

        .link-preview-minimal {
            color: white;
            font-size: 9px;
            font-weight: 600;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        /* Grid de fuentes para Link */
        .link-fonts-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            max-height: 180px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .link-font-option {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 4px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 36px;
        }

        .link-font-option:hover {
            border-color: var(--muted);
            background: var(--surface-hover);
        }

        .link-font-option.selected {
            border-color: var(--primary);
            background: rgba(70, 130, 180, 0.15);
        }

        .link-font-option span {
            font-size: 11px;
            color: var(--fg);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ========================================
           HERRAMIENTAS DE AJUSTE (Voltear, Rotar, Filtros)
           ======================================== */
        .adjust-buttons {
            display: flex;
            gap: 8px;
        }

        .adjust-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 12px 8px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--fg);
            font-size: 12px;
            font-weight: 500;
        }

        .adjust-btn:hover {
            border-color: var(--primary);
            background: rgba(70, 130, 180, 0.1);
        }

        .adjust-btn:active {
            transform: scale(0.95);
        }

        .adjust-btn svg {
            color: var(--muted);
            transition: color 0.2s;
        }

        .adjust-btn:hover svg {
            color: var(--primary);
        }

        /* Grid de filtros */
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .filter-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 8px 4px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-option:hover {
            border-color: var(--muted);
        }

        .filter-option.selected {
            border-color: var(--primary);
            background: rgba(70, 130, 180, 0.15);
        }

        .filter-preview {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            background: var(--line);
        }

        .filter-option span {
            font-size: 10px;
            color: var(--muted);
            text-align: center;
        }

        .filter-option.selected span {
            color: var(--primary);
            font-weight: 600;
        }

        /* Selector Lado A/B */
        .lado-selector {
            display: flex;
            gap: 12px;
        }

        .lado-option {
            flex: 1;
            padding: 12px;
            background: var(--bg);
            border: 2px solid var(--line);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lado-option:hover {
            border-color: var(--muted);
        }

        .lado-option.selected {
            border-color: var(--primary);
            background: rgba(70, 130, 180, 0.1);
        }

        /* Upload inicial */
        .upload-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--surface);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            cursor: pointer;
            z-index: 100;
        }

        .upload-overlay.hidden {
            display: none;
        }

        .upload-overlay svg {
            width: 64px;
            height: 64px;
            color: var(--muted);
        }

        .upload-overlay p {
            color: var(--muted);
            font-size: 14px;
        }

        .upload-overlay span {
            color: var(--primary);
            font-weight: 600;
        }

        /* ========================================
           RESPONSIVE - Tablet (1024px - 768px)
           ======================================== */
        @@media (max-width: 1024px) {
            .options-panel {
                width: 300px;
            }

            .canvas-wrapper {
                max-width: 340px;
            }
        }

        /* ========================================
           RESPONSIVE - Móvil (< 768px)
           ======================================== */
        @@media (max-width: 768px) {
            /* Ocultar tooltip en móvil */
            .tool-btn::after {
                display: none;
            }

            /* Panel de opciones como bottom sheet */
            .options-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                height: 75vh;
                max-height: 75vh;
                z-index: 200;
                border-left: none;
                border-top: none;
                border-radius: 20px 20px 0 0;
                transform: translateY(100%);
                transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                            height 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                            max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                            border-radius 0.35s ease;
                box-shadow: 0 -10px 40px var(--shadow-strong);
            }

            .options-panel::before {
                content: '';
                position: absolute;
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 4px;
                background: var(--line);
                border-radius: 2px;
                z-index: 10;
            }

            .options-panel.open {
                transform: translateY(0);
            }

            /* Modo expandido (pantalla completa) */
            .options-panel.expanded {
                height: 100vh;
                height: 100dvh;
                max-height: 100vh;
                max-height: 100dvh;
                border-radius: 0;
            }

            .options-panel.expanded::before {
                display: none;
            }

            .options-panel.expanded .options-header {
                padding-top: calc(16px + env(safe-area-inset-top, 0px));
            }

            .options-panel.expanded .options-content {
                padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px));
            }

            .options-header {
                padding-top: 24px;
            }

            /* Backdrop para cerrar el panel */
            .options-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 199;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s;
            }

            .options-backdrop.active {
                opacity: 1;
                visibility: visible;
            }

            /* Panel de herramientas inferior */
            .tools-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                height: auto;
                flex-direction: row;
                justify-content: space-around;
                align-items: center;
                padding: 8px 12px;
                padding-bottom: calc(8px + env(safe-area-inset-bottom));
                border-right: none;
                border-top: 1px solid var(--line);
                background: var(--glass-bg);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                z-index: 100;
            }

            .tools-panel .tools-divider,
            .tools-panel .desktop-only {
                display: none;
            }

            .close-editor-btn {
                display: none !important;
            }

            .tool-btn {
                width: 44px;
                height: 44px;
            }

            .tool-btn svg {
                width: 20px;
                height: 20px;
            }

            /* Canvas centrado con espacio para paneles */
            .canvas-area {
                padding: 0;
                padding-top: 60px;
                padding-bottom: 72px;
            }

            .canvas-wrapper {
                max-width: 100%;
                width: 100%;
                border-radius: 0;
                box-shadow: none;
            }

            .canvas-wrapper:hover {
                box-shadow: none;
            }
        }

        /* Header móvil */
        .mobile-header {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--line);
            padding: 0 12px;
            align-items: center;
            justify-content: space-between;
            z-index: 150;
        }

        @@media (max-width: 768px) {
            .mobile-header {
                display: flex;
            }
        }

        .close-btn {
            width: 44px;
            height: 44px;
            border: none;
            background: transparent;
            color: var(--fg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .close-btn:hover {
            background: var(--surface-hover);
        }

        .close-btn:active {
            transform: scale(0.9);
        }

        .mobile-header .title {
            font-weight: 600;
            font-size: 16px;
            color: var(--fg);
            flex: 1;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 8px;
        }

        .mobile-header .btn-primary {
            padding: 8px 16px;
            font-size: 13px;
            flex-shrink: 0;
        }

        /* ========================================
           RESPONSIVE - Móvil pequeño (< 400px)
           ======================================== */
        @@media (max-width: 400px) {
            .tool-btn {
                width: 40px;
                height: 40px;
            }

            .tool-btn svg {
                width: 18px;
                height: 18px;
            }

            .options-content {
                padding: 16px;
            }

            .sticker-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .font-selector {
                grid-template-columns: 1fr;
            }
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            z-index: 1000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--line);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @@keyframes spin {
            to { transform: rotate(360deg); }
        }

        @@keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @@keyframes fadeOutDown {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
        }

        /* ========================================
           CROP / RECORTE
           ======================================== */
        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 200;
            display: none;
        }

        .crop-overlay.active {
            display: flex;
            flex-direction: column;
        }

        .crop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.8);
        }

        .crop-header h4 {
            color: white;
            font-size: 16px;
            font-weight: 600;
        }

        .crop-actions {
            display: flex;
            gap: 8px;
        }

        .crop-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
        }

        .crop-btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .crop-btn-apply {
            background: var(--primary);
            color: white;
        }

        .crop-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .crop-box {
            position: absolute;
            border: 2px solid white;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            cursor: move;
        }

        .crop-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .crop-handle-tl { top: -10px; left: -10px; cursor: nwse-resize; }
        .crop-handle-tr { top: -10px; right: -10px; cursor: nesw-resize; }
        .crop-handle-bl { bottom: -10px; left: -10px; cursor: nesw-resize; }
        .crop-handle-br { bottom: -10px; right: -10px; cursor: nwse-resize; }

        .crop-footer {
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .aspect-btn {
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .aspect-btn:hover, .aspect-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        /* ========================================
           FONDOS / BACKGROUNDS
           ======================================== */
        .backgrounds-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .bg-option {
            aspect-ratio: 9/16;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .bg-option:hover {
            transform: scale(1.05);
            border-color: var(--muted);
        }

        .bg-option.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.3);
        }

        .bg-colors-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }

        .bg-color-option {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .bg-color-option:hover {
            transform: scale(1.1);
        }

        .bg-color-option.selected {
            border-color: var(--fg);
        }

        .gradient-preview {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        /* ========================================
           PLANTILLAS / TEMPLATES
           ======================================== */
        .templates-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 16px;
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 8px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) transparent;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        .templates-tabs::-webkit-scrollbar {
            height: 4px;
        }

        .templates-tabs::-webkit-scrollbar-track {
            background: transparent;
        }

        .templates-tabs::-webkit-scrollbar-thumb {
            background: var(--line);
            border-radius: 4px;
        }

        .templates-tabs::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        .template-tab {
            padding: 8px 14px;
            background: var(--bg);
            border: 1px solid var(--line);
            border-radius: 20px;
            color: var(--muted);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .template-tab:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .template-tab.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .templates-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-height: calc(100vh - 280px);
            min-height: 400px;
            overflow-y: auto;
            padding-right: 4px;
        }

        @@media (min-width: 769px) {
            .templates-grid {
                grid-template-columns: repeat(2, 1fr);
                max-height: calc(100vh - 200px);
            }
        }

        .template-item {
            aspect-ratio: 9/16;
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--line);
            transition: all 0.2s;
            min-height: 180px;
        }

        .template-item:hover {
            transform: scale(1.02);
            border-color: var(--primary);
            box-shadow: 0 8px 24px var(--shadow);
        }

        .template-item:active {
            transform: scale(0.98);
        }

        .template-preview {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            text-align: center;
            gap: 2px;
        }

        .template-preview span {
            display: block;
            line-height: 1.2;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .template-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 6px 8px;
            background: linear-gradient(transparent, rgba(0,0,0,0.85));
            color: white;
            font-size: 10px;
            font-weight: 500;
            text-align: center;
        }

        .template-badge {
            position: absolute;
            top: 6px;
            right: 6px;
            padding: 3px 8px;
            background: var(--primary);
            color: white;
            font-size: 9px;
            font-weight: 600;
            border-radius: 10px;
            text-transform: uppercase;
        }

        @@media (max-width: 400px) {
            .templates-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .backgrounds-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .template-item {
                min-height: 150px;
            }
        }

        /* ========================================
           BEAT SYNC - Video musical sincronizado
           ======================================== */
        .beatsync-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        /* En móvil, el scroll lo maneja options-content */
        @@media (max-width: 768px) {
            .beatsync-container {
                max-height: none;
                overflow-y: visible;
            }

            .beatsync-music-library {
                max-height: none;
            }
        }

        .beatsync-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
        }

        .beatsync-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--fg);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .beatsync-section-title svg {
            width: 18px;
            height: 18px;
            color: var(--primary);
        }

        /* Upload de música */
        .beatsync-music-upload {
            border: 2px dashed var(--line);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .beatsync-music-upload:hover {
            border-color: var(--primary);
            background: var(--primary-alpha);
        }

        .beatsync-music-upload.has-music {
            border-style: solid;
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }

        .beatsync-music-icon {
            width: 40px;
            height: 40px;
            margin: 0 auto 8px;
            color: var(--muted);
        }

        .beatsync-music-upload.has-music .beatsync-music-icon {
            color: var(--success);
        }

        .beatsync-music-text {
            font-size: 13px;
            color: var(--muted);
        }

        .beatsync-music-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--fg);
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Tabs de música (Subir / Biblioteca) */
        .beatsync-music-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            background: var(--bg);
            padding: 4px;
            border-radius: 10px;
        }

        .beatsync-music-tab {
            flex: 1;
            padding: 10px 12px;
            border: none;
            background: transparent;
            color: var(--muted);
            font-size: 13px;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .beatsync-music-tab:hover {
            color: var(--fg);
            background: var(--surface-hover);
        }

        .beatsync-music-tab.active {
            background: var(--primary);
            color: white;
        }

        .beatsync-music-tab svg {
            width: 16px;
            height: 16px;
        }

        /* Panel de contenido de tabs */
        .beatsync-music-tab-content {
            display: none;
        }

        .beatsync-music-tab-content.active {
            display: block;
        }

        /* Lista de biblioteca de música */
        .beatsync-music-library {
            max-height: 280px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .beatsync-music-search {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .beatsync-music-search input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: var(--bg);
            color: var(--fg);
            font-size: 13px;
        }

        .beatsync-music-search input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .beatsync-music-categories {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .beatsync-music-category {
            padding: 6px 12px;
            border: 1px solid var(--line);
            border-radius: 20px;
            background: transparent;
            color: var(--fg-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .beatsync-music-category:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .beatsync-music-category.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .beatsync-track {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .beatsync-track:hover {
            background: var(--surface-hover);
        }

        .beatsync-track.selected {
            border-color: var(--primary);
            background: rgba(var(--primary-rgb), 0.1);
        }

        .beatsync-track.playing {
            border-color: var(--success);
        }

        .beatsync-track.loading {
            border-color: var(--warning);
            opacity: 0.8;
        }

        .beatsync-track.loading .play-overlay {
            opacity: 1 !important;
        }

        .beatsync-track.loading .play-overlay::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .beatsync-track.loading .play-overlay svg {
            display: none;
        }

        @@keyframes spin {
            to { transform: rotate(360deg); }
        }

        .beatsync-track-cover {
            width: 44px;
            height: 44px;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        .beatsync-track-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .beatsync-track-cover svg {
            width: 20px;
            height: 20px;
            color: white;
        }

        .beatsync-track-cover .play-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .beatsync-track:hover .play-overlay,
        .beatsync-track.playing .play-overlay {
            opacity: 1;
        }

        /* Botón de play/pause para mejor soporte táctil en iOS */
        .beatsync-track-play-btn {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Por defecto mostrar play, ocultar pause */
        .beatsync-track .play-icon { display: flex; align-items: center; justify-content: center; }
        .beatsync-track .pause-icon { display: none; align-items: center; justify-content: center; }

        /* Cuando está reproduciendo, mostrar pause, ocultar play */
        .beatsync-track.playing .play-icon { display: none !important; }
        .beatsync-track.playing .pause-icon { display: flex !important; }

        /* Indicador visual más claro para estado playing */
        .beatsync-track.playing .beatsync-track-cover {
            box-shadow: 0 0 0 2px var(--success);
        }

        .beatsync-track-info {
            flex: 1;
            min-width: 0;
        }

        .beatsync-track-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--fg);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .beatsync-track-artist {
            font-size: 11px;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .beatsync-track-duration {
            font-size: 12px;
            color: var(--muted);
            flex-shrink: 0;
        }

        .beatsync-track-use-btn {
            padding: 6px 12px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
        }

        .beatsync-track:hover .beatsync-track-use-btn {
            opacity: 1;
        }

        .beatsync-library-empty {
            text-align: center;
            padding: 30px 20px;
            color: var(--muted);
        }

        .beatsync-library-empty svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .beatsync-library-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: var(--muted);
        }

        /* Upload de fotos */
        .beatsync-photos-upload {
            border: 2px dashed var(--line);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 100px;
        }

        .beatsync-photos-upload:hover {
            border-color: var(--primary);
            background: var(--primary-alpha);
        }

        .beatsync-photos-upload.has-photos {
            border-style: solid;
            padding: 12px;
        }

        .beatsync-photos-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .beatsync-photo-item {
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }

        .beatsync-photo-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .beatsync-photo-item .photo-number {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 20px;
            height: 20px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .beatsync-photo-item .photo-remove {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .beatsync-photo-item:hover .photo-remove {
            display: flex;
        }

        .beatsync-add-more {
            aspect-ratio: 1;
            border: 2px dashed var(--line);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--muted);
            font-size: 24px;
            transition: all 0.2s;
        }

        .beatsync-add-more:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .beatsync-photos-count {
            margin-top: 8px;
            font-size: 12px;
            color: var(--muted);
            text-align: center;
        }

        .beatsync-photos-actions {
            margin-top: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .beatsync-photos-hint {
            font-size: 11px;
            color: var(--muted);
        }

        .beatsync-shuffle-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            font-size: 11px;
            background: var(--bg);
            border: 1px solid var(--line);
            border-radius: 6px;
            color: var(--fg-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .beatsync-shuffle-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        /* Configuración */
        .beatsync-config {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .beatsync-config-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .beatsync-config-label {
            font-size: 13px;
            color: var(--fg-secondary);
            flex-shrink: 0;
        }

        .beatsync-select {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--line);
            background: var(--bg);
            color: var(--fg);
            font-size: 13px;
            cursor: pointer;
            max-width: 160px;
        }

        .beatsync-slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 180px;
        }

        .beatsync-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: var(--line);
            border-radius: 3px;
            outline: none;
        }

        .beatsync-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .beatsync-slider-value {
            font-size: 12px;
            color: var(--muted);
            min-width: 30px;
            text-align: right;
        }

        /* Visualizador de audio con timeline */
        .beatsync-waveform-container {
            margin-top: 12px;
        }

        .beatsync-waveform {
            height: 80px;
            background: var(--bg);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .beatsync-waveform canvas {
            width: 100%;
            height: 100%;
        }

        .beatsync-waveform-playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            pointer-events: none;
            display: none;
            z-index: 2;
        }

        .beatsync-waveform-playhead::after {
            content: '';
            position: absolute;
            top: 0;
            left: -4px;
            width: 10px;
            height: 10px;
            background: #ef4444;
            border-radius: 50%;
        }

        .beatsync-time-display {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--muted);
            margin-top: 4px;
            padding: 0 4px;
        }

        .beatsync-beats-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
            padding: 10px 12px;
            background: var(--bg);
            border-radius: 8px;
            gap: 12px;
        }

        /* Estilos para beats-info dentro del audio cutter (fondo púrpura) */
        .beatsync-audio-cutter .beatsync-beats-info {
            background: rgba(255, 255, 255, 0.15);
            padding: 8px 12px;
        }

        .beatsync-audio-cutter .beatsync-beats-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
        }

        .beatsync-audio-cutter .beatsync-beats-count {
            color: #2dd4bf;
            font-weight: 700;
            font-size: 15px;
        }

        .beatsync-audio-cutter .beatsync-beats-dot {
            background: #2dd4bf;
            box-shadow: 0 0 8px rgba(45, 212, 191, 0.6);
        }

        .beatsync-audio-cutter .beatsync-mode-btn {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.9);
        }

        .beatsync-audio-cutter .beatsync-mode-btn.active {
            background: #2dd4bf;
            border-color: #2dd4bf;
            color: #064e3b;
        }

        .beatsync-audio-cutter .beatsync-mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .beatsync-beats-stat {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .beatsync-beats-dot {
            width: 8px;
            height: 8px;
            background: var(--primary);
            border-radius: 50%;
        }

        .beatsync-beats-dot.active {
            animation: beatPulse 0.3s ease-out;
        }

        .beatsync-beats-text {
            font-size: 12px;
            color: var(--muted);
        }

        .beatsync-beats-count {
            font-weight: 600;
            color: var(--primary);
        }

        .beatsync-reanalyze-btn {
            padding: 6px 12px;
            font-size: 11px;
            background: var(--bg-secondary);
            border: 1px solid var(--line);
            border-radius: 6px;
            color: var(--fg);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .beatsync-reanalyze-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .beatsync-reanalyze-btn svg {
            width: 12px;
            height: 12px;
        }

        @@keyframes beatPulse {
            0% { transform: scale(1); background: var(--primary); }
            50% { transform: scale(1.8); background: #ef4444; }
            100% { transform: scale(1); background: var(--primary); }
        }

        /* Modo de detección */
        .beatsync-mode-selector {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .beatsync-mode-btn {
            flex: 1;
            padding: 8px 12px;
            font-size: 12px;
            background: var(--bg);
            border: 1px solid var(--line);
            border-radius: 8px;
            color: var(--fg-secondary);
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .beatsync-mode-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .beatsync-mode-btn:hover:not(.active) {
            border-color: var(--primary);
            color: var(--primary);
        }

        /* =============================================
           AUDIO CUTTER VISUAL - Beat Sync
           ============================================= */
        .beatsync-audio-cutter {
            margin-top: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 14px;
            color: white;
        }

        .beatsync-cutter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .beatsync-cutter-filename {
            font-weight: 600;
            max-width: 60%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .beatsync-cutter-info {
            opacity: 0.85;
            font-size: 11px;
            display: flex;
            gap: 8px;
        }

        /* Waveform container */
        .beatsync-waveform-visual {
            position: relative;
            height: 90px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .beatsync-waveform-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 1;
        }

        /* Overlays para oscurecer fuera de selección */
        .beatsync-waveform-overlay-left,
        .beatsync-waveform-overlay-right {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 2;
        }

        .beatsync-waveform-overlay-left {
            left: 0;
            width: 0;
        }

        .beatsync-waveform-overlay-right {
            right: 0;
            width: 0;
        }

        /* Área de selección (solo bordes) */
        .beatsync-waveform-selection {
            position: absolute;
            top: 0;
            height: 100%;
            border-left: 2px solid #2dd4bf;
            border-right: 2px solid #2dd4bf;
            pointer-events: none;
            z-index: 10;
            box-shadow: inset 0 0 0 1px rgba(45, 212, 191, 0.3);
        }

        /* Selection handles (posicionados independientemente) */
        .beatsync-selection-handle {
            position: absolute;
            top: 0;
            width: 28px;
            height: 100%;
            cursor: ew-resize;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            pointer-events: auto;
        }

        .beatsync-selection-handle .handle-bar {
            width: 8px;
            height: 55px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            pointer-events: none;
            transition: transform 0.15s, background 0.15s;
        }

        .beatsync-selection-handle:hover .handle-bar,
        .beatsync-selection-handle.dragging .handle-bar {
            background: #2dd4bf;
            transform: scaleY(1.15);
        }

        .beatsync-selection-handle.dragging {
            z-index: 30;
        }

        /* Posición inicial - será actualizada por JS */
        .beatsync-selection-handle.handle-left {
            left: 0;
        }

        .beatsync-selection-handle.handle-right {
            left: 100%;
        }

        /* Playhead animado */
        .beatsync-waveform-playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: white;
            pointer-events: none;
            display: none;
            z-index: 15;
            box-shadow: 0 0 6px rgba(255,255,255,0.6);
        }

        .beatsync-waveform-playhead.active {
            display: block;
        }

        /* Beat markers en waveform */
        .beatsync-beat-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(239, 68, 68, 0.7);
            pointer-events: none;
            z-index: 5;
        }

        /* Controles del cutter */
        .beatsync-cutter-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .beatsync-cutter-play-btn {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: transform 0.15s;
        }

        .beatsync-cutter-play-btn:hover {
            transform: scale(1.08);
        }

        .beatsync-cutter-play-btn:active {
            transform: scale(0.95);
        }

        .beatsync-cutter-play-btn svg {
            width: 18px;
            height: 18px;
            fill: #667eea;
        }

        .beatsync-cutter-play-btn .pause-icon {
            display: none;
        }

        .beatsync-cutter-play-btn.playing .play-icon {
            display: none;
        }

        .beatsync-cutter-play-btn.playing .pause-icon {
            display: block;
        }

        .beatsync-cutter-play-btn.loading {
            pointer-events: none;
            opacity: 0.7;
        }

        .beatsync-cutter-play-btn.loading .play-icon,
        .beatsync-cutter-play-btn.loading .pause-icon {
            display: none;
        }

        .beatsync-cutter-play-btn.loading::after {
            content: '';
            width: 18px;
            height: 18px;
            border: 2px solid #667eea;
            border-top-color: transparent;
            border-radius: 50%;
            animation: beatsync-spin 0.8s linear infinite;
        }

        @@keyframes beatsync-spin {
            to { transform: rotate(360deg); }
        }

        /* Time inputs del cutter */
        .beatsync-cutter-times {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }

        .beatsync-time-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .beatsync-time-group label {
            font-size: 10px;
            opacity: 0.7;
            text-transform: uppercase;
        }

        .beatsync-time-value {
            background: rgba(255,255,255,0.2);
            padding: 4px 10px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }

        .beatsync-current-time .beatsync-time-value {
            background: rgba(45, 212, 191, 0.3);
            border: 1px solid #2dd4bf;
            color: #2dd4bf;
        }

        .beatsync-current-time label {
            color: #2dd4bf;
            opacity: 1;
        }

        .beatsync-duration-input {
            background: rgba(255, 200, 50, 0.2);
            border: 1px solid rgba(255, 200, 50, 0.6);
            color: #ffc832;
            padding: 4px 6px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            font-weight: 600;
            width: 50px;
            text-align: center;
        }

        .beatsync-duration-input:focus {
            outline: none;
            border-color: #ffc832;
            background: rgba(255, 200, 50, 0.3);
        }

        .beatsync-duration-group label {
            color: #ffc832;
            opacity: 1;
        }

        /* Ocultar flechas del input number */
        .beatsync-duration-input::-webkit-outer-spin-button,
        .beatsync-duration-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .beatsync-duration-input[type=number] {
            -moz-appearance: textfield;
        }

        .beatsync-duration-badge {
            background: #2dd4bf;
            color: #064e3b;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 13px;
        }

        /* Hint del cutter */
        .beatsync-cutter-hint {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 10px;
            font-size: 11px;
            opacity: 0.75;
        }

        .beatsync-cutter-hint svg {
            width: 14px;
            height: 14px;
        }

        /* Loading state */
        .beatsync-audio-cutter.loading .beatsync-waveform-visual {
            opacity: 0.5;
        }

        .beatsync-audio-cutter.loading .beatsync-waveform-visual::after {
            content: 'Cargando...';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 500;
        }

        /* Preview mejorado */
        .beatsync-preview-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 12px;
            margin-top: 8px;
        }

        .beatsync-preview {
            position: relative;
            aspect-ratio: 9/16;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            max-height: 280px;
            margin: 0 auto;
        }

        .beatsync-preview-canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .beatsync-preview-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.4);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .beatsync-preview:hover .beatsync-preview-overlay:not(.playing) {
            opacity: 1;
        }

        .beatsync-preview-overlay.playing {
            opacity: 0;
            pointer-events: none;
        }

        .beatsync-preview-play {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.9);
            color: #000;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .beatsync-preview-play:hover {
            transform: scale(1.1);
            background: white;
        }

        .beatsync-preview-play svg {
            width: 28px;
            height: 28px;
            margin-left: 4px;
        }

        .beatsync-preview-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 12px;
            padding: 8px 0;
        }

        .beatsync-control-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: var(--bg);
            color: var(--fg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .beatsync-control-btn:hover {
            background: var(--primary);
            color: white;
        }

        .beatsync-control-btn.active {
            background: var(--primary);
            color: white;
        }

        .beatsync-control-btn svg {
            width: 16px;
            height: 16px;
        }

        .beatsync-control-btn.main {
            width: 44px;
            height: 44px;
            background: var(--primary);
            color: white;
        }

        .beatsync-control-btn.main svg {
            width: 20px;
            height: 20px;
        }

        .beatsync-control-btn.main:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }

        .beatsync-timeline {
            flex: 1;
            height: 4px;
            background: var(--line);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .beatsync-timeline-progress {
            height: 100%;
            background: var(--primary);
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .beatsync-timeline-time {
            font-size: 11px;
            color: var(--muted);
            min-width: 70px;
            text-align: right;
        }

        .beatsync-beat-flash {
            position: absolute;
            inset: 0;
            background: rgba(255,255,255,0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
        }

        .beatsync-beat-flash.active {
            opacity: 1;
        }

        /* Photo counter en preview */
        .beatsync-photo-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 10px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            border-radius: 12px;
            font-size: 11px;
            color: white;
            font-weight: 500;
        }

        /* Botones de acción */
        .beatsync-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .beatsync-btn {
            flex: 1;
            min-width: 0;
            padding: 10px 8px;
            border-radius: 10px;
            border: none;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
        }

        .beatsync-btn svg {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
        }

        .beatsync-btn span {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .beatsync-btn-secondary {
            background: var(--bg-secondary);
            color: var(--fg);
            border: 1px solid var(--line);
        }

        .beatsync-btn-secondary:hover {
            background: var(--bg-tertiary);
        }

        .beatsync-btn-primary {
            background: var(--primary);
            color: white;
        }

        .beatsync-btn-primary:hover {
            filter: brightness(1.1);
        }

        .beatsync-btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .beatsync-btn-outline {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
        }

        .beatsync-btn-outline:hover {
            background: var(--primary);
            color: white;
        }

        .beatsync-btn-outline:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            color: var(--muted);
            border-color: var(--line);
        }

        /* Header con título y progress */
        /* Header interno de BeatSync - OCULTO (usamos el header del panel) */
        .beatsync-header {
            display: none;
        }

        .beatsync-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
            margin: 0;
        }

        .beatsync-title svg {
            width: 22px;
            height: 22px;
            color: var(--primary);
        }

        /* Progress durante generación */
        .beatsync-header .beatsync-progress {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            gap: 8px;
            background: var(--surface);
            border-radius: 8px;
        }

        .beatsync-header .beatsync-progress.active {
            display: flex;
        }

        .beatsync-progress {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 12px;
        }

        .beatsync-progress.active {
            display: flex;
        }

        .beatsync-progress-bar {
            width: 100%;
            height: 8px;
            background: var(--line);
            border-radius: 4px;
            overflow: hidden;
        }

        .beatsync-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #8b5cf6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .beatsync-progress-text {
            font-size: 13px;
            color: var(--muted);
        }

        /* Sistema de partículas - Beat Sync */
        .beatsync-particles-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--line);
        }

        .beatsync-particles-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--fg-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .beatsync-particles-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .beatsync-particle-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px 8px;
            background: var(--bg);
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            gap: 6px;
        }

        .beatsync-particle-option:hover {
            background: var(--surface-hover);
            transform: translateY(-2px);
        }

        .beatsync-particle-option.selected {
            border-color: var(--primary);
            background: rgba(var(--primary-rgb), 0.1);
        }

        .beatsync-particle-icon {
            font-size: 24px;
            line-height: 1;
        }

        .beatsync-particle-label {
            font-size: 11px;
            color: var(--fg-secondary);
            font-weight: 500;
        }

        .beatsync-particle-option.selected .beatsync-particle-label {
            color: var(--primary);
        }

        /* Configuración de partículas */
        .beatsync-particles-config {
            margin-top: 12px;
            display: none;
        }

        .beatsync-particles-config.active {
            display: block;
        }

        .beatsync-particles-config .beatsync-config-row {
            margin-bottom: 8px;
        }

        /* Estilos para partículas dentro del audio cutter */
        .beatsync-audio-cutter .beatsync-particles-section {
            border-top-color: rgba(255, 255, 255, 0.2);
        }

        .beatsync-audio-cutter .beatsync-particles-title {
            color: rgba(255, 255, 255, 0.8);
        }

        .beatsync-audio-cutter .beatsync-particle-option {
            background: rgba(255, 255, 255, 0.1);
        }

        .beatsync-audio-cutter .beatsync-particle-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .beatsync-audio-cutter .beatsync-particle-option.selected {
            background: rgba(45, 212, 191, 0.2);
            border-color: #2dd4bf;
        }

        .beatsync-audio-cutter .beatsync-particle-label {
            color: rgba(255, 255, 255, 0.9);
        }

        .beatsync-audio-cutter .beatsync-particle-option.selected .beatsync-particle-label {
            color: #2dd4bf;
        }

        @@media (max-width: 768px) {
            .beatsync-container {
                max-height: calc(100vh - 280px);
            }

            .beatsync-photos-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .beatsync-config-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .beatsync-select, .beatsync-slider-container {
                max-width: 100%;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    @Html.AntiForgeryToken()

    <!-- Global Error Handler para capturar errores de JavaScript -->
    <script>
        // Capturar errores globales y enviarlos al servidor
        window.onerror = function(mensaje, archivo, linea, columna, error) {
            try {
                const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;
                fetch('/Stories/LogErrorFrontend', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': token
                    },
                    body: JSON.stringify({
                        mensaje: mensaje,
                        componente: 'StoryEditor',
                        archivo: archivo,
                        linea: linea,
                        columna: columna,
                        stack: error?.stack || null
                    })
                }).catch(() => {});
            } catch (e) {}
            return false;
        };

        // Capturar promesas no manejadas
        window.onunhandledrejection = function(event) {
            try {
                const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;
                fetch('/Stories/LogErrorFrontend', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': token
                    },
                    body: JSON.stringify({
                        mensaje: 'Unhandled Promise Rejection: ' + (event.reason?.message || event.reason || 'Unknown'),
                        componente: 'StoryEditor',
                        archivo: null,
                        linea: null,
                        columna: null,
                        stack: event.reason?.stack || null
                    })
                }).catch(() => {});
            } catch (e) {}
        };
    </script>

    <!-- Script para detectar y aplicar tema guardado (sincronizado con Layout) -->
    <script>
        // ThemeStorage - copia del Layout para consistencia
        const ThemeStorage = {
            _storage: null,
            _memoryFallback: {},

            init: function() {
                try {
                    const test = '__storage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    this._storage = localStorage;
                } catch (e) {
                    this._storage = null;
                }
            },

            getItem: function(key) {
                if (this._storage) {
                    return this._storage.getItem(key);
                }
                return this._memoryFallback[key] || null;
            },

            setItem: function(key, value) {
                if (this._storage) {
                    try {
                        this._storage.setItem(key, value);
                    } catch (e) {
                        this._memoryFallback[key] = value;
                    }
                } else {
                    this._memoryFallback[key] = value;
                }
            }
        };

        ThemeStorage.init();

        (function() {
            // Detectar tema guardado
            var savedTheme = ThemeStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            document.body?.classList.remove('theme-light', 'theme-dark');
            document.body?.classList.add('theme-' + savedTheme);
        })();

        // Escuchar cambios de tema desde otras pestanas
        window.addEventListener('storage', function(e) {
            if (e.key === 'theme') {
                var newTheme = e.newValue || 'light';
                document.documentElement.setAttribute('data-theme', newTheme);
                document.body.classList.remove('theme-light', 'theme-dark');
                document.body.classList.add('theme-' + newTheme);
            }
        });
    </script>

    <!-- Backdrop para cerrar panel en móvil -->
    <div class="options-backdrop" id="optionsBackdrop" onclick="cerrarPanelOpciones()"></div>

    <div class="story-editor">
        <!-- Header móvil -->
        <div class="mobile-header">
            <button class="close-btn" onclick="cancelarEditor()" aria-label="Cerrar">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <span class="title">@titulo</span>
            <button class="btn btn-primary" id="mobilePublishBtn" onclick="abrirModalPublicar()" disabled>@textoPublicar</button>
        </div>

        <!-- Panel de herramientas -->
        <div class="tools-panel">
            <!-- Botón de salir (visible en desktop) -->
            <button class="tool-btn close-editor-btn" title="Salir" onclick="cancelarEditor()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
                    <polyline points="16 17 21 12 16 7"/>
                    <line x1="21" y1="12" x2="9" y2="12"/>
                </svg>
            </button>
            <div class="tools-divider desktop-only"></div>
            <button class="tool-btn active" data-tool="text" title="Texto" onclick="seleccionarHerramienta('text')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="sticker" title="Stickers" onclick="seleccionarHerramienta('sticker')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                    <line x1="9" y1="9" x2="9.01" y2="9"/>
                    <line x1="15" y1="9" x2="15.01" y2="9"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="gif" title="GIFs" onclick="seleccionarHerramienta('gif')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="2" y="4" width="20" height="16" rx="2"/>
                    <path d="M8 10h1.5c.5 0 1 .5 1 1v2c0 .5-.5 1-1 1H8v-4z"/>
                    <path d="M13 10v4"/>
                    <path d="M16 10v4M16 12h2"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="mention" title="Mencionar" onclick="seleccionarHerramienta('mention')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="4"/>
                    <path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="draw" title="Dibujar" onclick="seleccionarHerramienta('draw')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                    <path d="M2 2l7.586 7.586"/>
                    <circle cx="11" cy="11" r="2"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="music" title="Música" onclick="seleccionarHerramienta('music')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="link" title="Enlace" onclick="seleccionarHerramienta('link')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="effects" title="Efectos" onclick="seleccionarHerramienta('effects')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 3v3m0 12v3M3 12h3m12 0h3"/>
                    <path d="M5.64 5.64l2.12 2.12m8.48 8.48l2.12 2.12M5.64 18.36l2.12-2.12m8.48-8.48l2.12-2.12"/>
                    <circle cx="12" cy="12" r="4"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="adjust" title="Ajustes" onclick="seleccionarHerramienta('adjust')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="crop" title="Recortar" onclick="seleccionarHerramienta('crop')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M6 2v14a2 2 0 0 0 2 2h14"/>
                    <path d="M18 22V8a2 2 0 0 0-2-2H2"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="background" title="Fondos" onclick="seleccionarHerramienta('background')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21 15 16 10 5 21"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="template" title="Plantillas" onclick="seleccionarHerramienta('template')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="9"/>
                    <rect x="14" y="3" width="7" height="5"/>
                    <rect x="14" y="12" width="7" height="9"/>
                    <rect x="3" y="16" width="7" height="5"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="beatsync" title="Beat Sync" onclick="seleccionarHerramienta('beatsync')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M2 12h2l2-6 3 12 3-8 2 4h8"/>
                    <circle cx="20" cy="12" r="2"/>
                </svg>
            </button>

            <div class="tools-divider"></div>

            <button class="tool-btn" title="Deshacer" onclick="deshacerCambio()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 7v6h6"/>
                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                </svg>
            </button>
            <button class="tool-btn" title="Eliminar selección" onclick="eliminarSeleccion()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="3 6 5 6 21 6"/>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                </svg>
            </button>
        </div>

        <!-- Canvas central -->
        <div class="canvas-area">
            <div class="canvas-wrapper" id="canvasWrapper">
                <!-- Overlay de upload inicial -->
                <div class="upload-overlay" id="uploadOverlay" onclick="document.getElementById('fileInput').click()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <polyline points="21 15 16 10 5 21"/>
                    </svg>
                    <p><span>Toca para subir</span> una foto o video</p>
                </div>
                <input type="file" id="fileInput" accept="image/*,video/*,.heic,.heif" style="display:none;" onchange="cargarMedia(this)">

                <!-- Video de fondo (para cuando se sube un video) -->
                <video id="videoBackground" muted loop playsinline></video>

                <!-- Canvas de Fabric.js (superpuesto) -->
                <canvas id="storyCanvas"></canvas>
            </div>
        </div>

        <!-- Panel de opciones -->
        <div class="options-panel" id="optionsPanel">
            <div class="options-header">
                <div class="options-header-title-row">
                    <h3 id="optionsTitle">Texto</h3>
                    <!-- Barra de progreso BeatSync en header -->
                    <div class="beatsync-header-progress" id="beatsyncHeaderProgress">
                        <div class="beatsync-header-progress-bar">
                            <div class="beatsync-header-progress-fill" id="beatsyncHeaderProgressFill"></div>
                        </div>
                        <span class="beatsync-header-progress-text" id="beatsyncHeaderProgressText"></span>
                    </div>
                </div>
                <div class="options-header-actions">
                    <button class="expand-btn" id="expandPanelBtn" onclick="toggleExpandPanel()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20" class="expand-icon">
                            <polyline points="15 3 21 3 21 9"></polyline>
                            <polyline points="9 21 3 21 3 15"></polyline>
                            <line x1="21" y1="3" x2="14" y2="10"></line>
                            <line x1="3" y1="21" x2="10" y2="14"></line>
                        </svg>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20" class="collapse-icon" style="display:none;">
                            <polyline points="4 14 10 14 10 20"></polyline>
                            <polyline points="20 10 14 10 14 4"></polyline>
                            <line x1="14" y1="10" x2="21" y2="3"></line>
                            <line x1="3" y1="21" x2="10" y2="14"></line>
                        </svg>
                    </button>
                    <button class="close-btn" onclick="cerrarPanelOpciones()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="options-content">
                <!-- TEXTO -->
                <div class="option-section active" id="textOptions">
                    <div class="option-group">
                        <label class="option-label">Tu texto</label>
                        <textarea class="text-input" id="textInput" rows="3" placeholder="Escribe aquí..." oninput="actualizarTextoSeleccionado()"></textarea>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Fuente</label>
                        <div class="link-fonts-grid" style="grid-template-columns: repeat(4, 1fr);">
                            <div class="link-font-option selected" data-font="Poppins" onclick="cambiarFuente('Poppins', this)">
                                <span style="font-family: 'Poppins';">Poppins</span>
                            </div>
                            <div class="link-font-option" data-font="Montserrat" onclick="cambiarFuente('Montserrat', this)">
                                <span style="font-family: 'Montserrat';">Montserrat</span>
                            </div>
                            <div class="link-font-option" data-font="Roboto" onclick="cambiarFuente('Roboto', this)">
                                <span style="font-family: 'Roboto';">Roboto</span>
                            </div>
                            <div class="link-font-option" data-font="Oswald" onclick="cambiarFuente('Oswald', this)">
                                <span style="font-family: 'Oswald';">Oswald</span>
                            </div>
                            <div class="link-font-option" data-font="Bebas Neue" onclick="cambiarFuente('Bebas Neue', this)">
                                <span style="font-family: 'Bebas Neue';">BEBAS</span>
                            </div>
                            <div class="link-font-option" data-font="Anton" onclick="cambiarFuente('Anton', this)">
                                <span style="font-family: 'Anton';">ANTON</span>
                            </div>
                            <div class="link-font-option" data-font="Playfair Display" onclick="cambiarFuente('Playfair Display', this)">
                                <span style="font-family: 'Playfair Display';">Playfair</span>
                            </div>
                            <div class="link-font-option" data-font="Lobster" onclick="cambiarFuente('Lobster', this)">
                                <span style="font-family: 'Lobster';">Lobster</span>
                            </div>
                            <div class="link-font-option" data-font="Pacifico" onclick="cambiarFuente('Pacifico', this)">
                                <span style="font-family: 'Pacifico';">Pacifico</span>
                            </div>
                            <div class="link-font-option" data-font="Dancing Script" onclick="cambiarFuente('Dancing Script', this)">
                                <span style="font-family: 'Dancing Script';">Dancing</span>
                            </div>
                            <div class="link-font-option" data-font="Permanent Marker" onclick="cambiarFuente('Permanent Marker', this)">
                                <span style="font-family: 'Permanent Marker';">Marker</span>
                            </div>
                            <div class="link-font-option" data-font="Satisfy" onclick="cambiarFuente('Satisfy', this)">
                                <span style="font-family: 'Satisfy';">Satisfy</span>
                            </div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Tamaño: <span id="fontSizeLabel">32</span>px</label>
                        <input type="range" class="size-slider" id="fontSizeSlider" min="16" max="72" value="32" oninput="cambiarTamanoTexto(this.value)">
                    </div>
                    <div class="option-group">
                        <label class="option-label">Color del texto</label>
                        <div class="color-picker" id="textColorPicker">
                            <div class="color-option selected" style="background: #ffffff;" onclick="cambiarColorTexto('#ffffff', this)"></div>
                            <div class="color-option" style="background: #000000;" onclick="cambiarColorTexto('#000000', this)"></div>
                            <div class="color-option" style="background: #ff3b5c;" onclick="cambiarColorTexto('#ff3b5c', this)"></div>
                            <div class="color-option" style="background: #00d4ff;" onclick="cambiarColorTexto('#00d4ff', this)"></div>
                            <div class="color-option" style="background: #ffdd00;" onclick="cambiarColorTexto('#ffdd00', this)"></div>
                            <div class="color-option" style="background: #00ff88;" onclick="cambiarColorTexto('#00ff88', this)"></div>
                            <div class="color-option" style="background: #ff00ff;" onclick="cambiarColorTexto('#ff00ff', this)"></div>
                            <div class="color-option" style="background: #ff8800;" onclick="cambiarColorTexto('#ff8800', this)"></div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Fondo del texto</label>
                        <div class="color-picker" id="textBgPicker">
                            <div class="color-option selected" style="background: transparent; border: 2px dashed #666;" onclick="cambiarFondoTexto('transparent', this)"></div>
                            <div class="color-option" style="background: rgba(0,0,0,0.7);" onclick="cambiarFondoTexto('rgba(0,0,0,0.7)', this)"></div>
                            <div class="color-option" style="background: rgba(255,255,255,0.9);" onclick="cambiarFondoTexto('rgba(255,255,255,0.9)', this)"></div>
                            <div class="color-option" style="background: rgba(70,130,180,0.8);" onclick="cambiarFondoTexto('rgba(70,130,180,0.8)', this)"></div>
                        </div>
                    </div>

                    <!-- ANIMACIONES DE TEXTO -->
                    <div class="option-group">
                        <label class="option-label">Animación de entrada</label>
                        <div class="text-animation-grid">
                            <button class="text-anim-btn active" data-anim="none" onclick="seleccionarAnimacionEntrada('none', this)">
                                <span class="anim-preview">Aa</span>
                                <span>Sin efecto</span>
                            </button>
                            <button class="text-anim-btn" data-anim="fade" onclick="seleccionarAnimacionEntrada('fade', this)">
                                <span class="anim-preview anim-demo-fade">Aa</span>
                                <span>Fade</span>
                            </button>
                            <button class="text-anim-btn" data-anim="slide-up" onclick="seleccionarAnimacionEntrada('slide-up', this)">
                                <span class="anim-preview anim-demo-slide">Aa</span>
                                <span>Slide</span>
                            </button>
                            <button class="text-anim-btn" data-anim="bounce" onclick="seleccionarAnimacionEntrada('bounce', this)">
                                <span class="anim-preview anim-demo-bounce">Aa</span>
                                <span>Bounce</span>
                            </button>
                            <button class="text-anim-btn" data-anim="typewriter" onclick="seleccionarAnimacionEntrada('typewriter', this)">
                                <span class="anim-preview anim-demo-typewriter">Aa</span>
                                <span>Typewriter</span>
                            </button>
                            <button class="text-anim-btn" data-anim="scale" onclick="seleccionarAnimacionEntrada('scale', this)">
                                <span class="anim-preview anim-demo-scale">Aa</span>
                                <span>Scale</span>
                            </button>
                        </div>
                    </div>

                    <div class="option-group">
                        <label class="option-label">Efecto continuo</label>
                        <div class="text-animation-grid">
                            <button class="text-anim-btn active" data-effect="none" onclick="seleccionarEfectoContinuo('none', this)">
                                <span class="anim-preview">Aa</span>
                                <span>Sin efecto</span>
                            </button>
                            <button class="text-anim-btn" data-effect="glow" onclick="seleccionarEfectoContinuo('glow', this)">
                                <span class="anim-preview effect-demo-glow">Aa</span>
                                <span>Glow</span>
                            </button>
                            <button class="text-anim-btn" data-effect="shadow3d" onclick="seleccionarEfectoContinuo('shadow3d', this)">
                                <span class="anim-preview effect-demo-shadow">Aa</span>
                                <span>Shadow 3D</span>
                            </button>
                            <button class="text-anim-btn" data-effect="colorshift" onclick="seleccionarEfectoContinuo('colorshift', this)">
                                <span class="anim-preview effect-demo-colorshift">Aa</span>
                                <span>Color Shift</span>
                            </button>
                            <button class="text-anim-btn" data-effect="float" onclick="seleccionarEfectoContinuo('float', this)">
                                <span class="anim-preview effect-demo-float">Aa</span>
                                <span>Float</span>
                            </button>
                            <button class="text-anim-btn" data-effect="shake" onclick="seleccionarEfectoContinuo('shake', this)">
                                <span class="anim-preview effect-demo-shake">Aa</span>
                                <span>Shake</span>
                            </button>
                        </div>
                    </div>

                    <button class="btn btn-primary" style="width: 100%; margin-top: 12px;" onclick="agregarTexto()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Agregar texto
                    </button>
                </div>

                <!-- STICKERS -->
                <div class="option-section" id="stickerOptions">
                    <div class="option-group">
                        <label class="option-label">Emojis populares</label>
                        <div class="sticker-grid" id="emojiGrid">
                            <!-- Se llena con JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- GIFs ANIMADOS -->
                <div class="option-section" id="gifOptions">
                    <div class="option-group">
                        <label class="option-label">Buscar GIFs</label>
                        <div class="gif-search-container">
                            <input type="text" class="text-input" id="gifSearchInput" placeholder="Buscar GIFs..." oninput="buscarGifsDebounced(this.value)">
                            <div class="gif-search-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="11" cy="11" r="8"/>
                                    <path d="M21 21l-4.35-4.35"/>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Categorías</label>
                        <div class="gif-categories" id="gifCategories">
                            <button class="gif-category-btn active" data-categoria="trending" onclick="cargarGifsCategoria('trending', this)">Tendencias</button>
                            <button class="gif-category-btn" data-categoria="reacciones" onclick="cargarGifsCategoria('reacciones', this)">Reacciones</button>
                            <button class="gif-category-btn" data-categoria="amor" onclick="cargarGifsCategoria('amor', this)">Amor</button>
                            <button class="gif-category-btn" data-categoria="fiesta" onclick="cargarGifsCategoria('fiesta', this)">Fiesta</button>
                            <button class="gif-category-btn" data-categoria="risa" onclick="cargarGifsCategoria('risa', this)">Risa</button>
                            <button class="gif-category-btn" data-categoria="bailar" onclick="cargarGifsCategoria('bailar', this)">Bailar</button>
                        </div>
                    </div>
                    <div class="option-group">
                        <div class="gif-grid-container">
                            <div class="gif-grid" id="gifGrid">
                                <div class="gif-loading" id="gifLoading">
                                    <div class="loading-spinner"></div>
                                    <span>Cargando GIFs...</span>
                                </div>
                            </div>
                        </div>
                        <div class="giphy-attribution">
                            <span>Powered by</span>
                            <img src="https://giphy.com/static/img/giphy-logo-square-180.png" alt="GIPHY" height="20">
                        </div>
                    </div>
                </div>

                <!-- MENCIONES -->
                <div class="option-section" id="mentionOptions">
                    <div class="option-group">
                        <label class="option-label">Buscar usuario</label>
                        <div class="mention-search">
                            <input type="text" class="text-input" id="mentionSearch" placeholder="@@usuario" oninput="buscarUsuarios(this.value)">
                            <div class="mention-results" id="mentionResults"></div>
                        </div>
                    </div>
                </div>

                <!-- DIBUJO -->
                <div class="option-section" id="drawOptions">
                    <div class="option-group">
                        <label class="option-label">Grosor del pincel</label>
                        <div class="brush-sizes">
                            <div class="brush-size selected" onclick="cambiarGrosorPincel(3, this)">
                                <div class="brush-size-dot" style="width: 6px; height: 6px;"></div>
                            </div>
                            <div class="brush-size" onclick="cambiarGrosorPincel(6, this)">
                                <div class="brush-size-dot" style="width: 10px; height: 10px;"></div>
                            </div>
                            <div class="brush-size" onclick="cambiarGrosorPincel(12, this)">
                                <div class="brush-size-dot" style="width: 16px; height: 16px;"></div>
                            </div>
                            <div class="brush-size" onclick="cambiarGrosorPincel(20, this)">
                                <div class="brush-size-dot" style="width: 22px; height: 22px;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Color del pincel</label>
                        <div class="color-picker" id="brushColorPicker">
                            <div class="color-option selected" style="background: #ff3b5c;" onclick="cambiarColorPincel('#ff3b5c', this)"></div>
                            <div class="color-option" style="background: #ffffff;" onclick="cambiarColorPincel('#ffffff', this)"></div>
                            <div class="color-option" style="background: #000000;" onclick="cambiarColorPincel('#000000', this)"></div>
                            <div class="color-option" style="background: #00d4ff;" onclick="cambiarColorPincel('#00d4ff', this)"></div>
                            <div class="color-option" style="background: #ffdd00;" onclick="cambiarColorPincel('#ffdd00', this)"></div>
                            <div class="color-option" style="background: #00ff88;" onclick="cambiarColorPincel('#00ff88', this)"></div>
                        </div>
                    </div>
                    <button class="btn btn-secondary" style="width: 100%; margin-top: 12px;" onclick="borrarDibujo()">
                        Borrar todo el dibujo
                    </button>
                </div>

                <!-- MÚSICA -->
                <div class="option-section" id="musicOptions">
                    <!-- Audio Cutter - Canción seleccionada -->
                    <div class="option-group" id="selectedMusicContainer" style="display: none;">
                        <div class="audio-cutter" id="audioCutterContainer">
                            <div class="audio-cutter-header">
                                <div class="audio-cutter-filename" id="selectedMusicTitle">-</div>
                                <div style="display: flex; align-items: center;">
                                    <div class="audio-cutter-info">
                                        <span id="cutterDuration">00:00</span>
                                    </div>
                                    <button type="button" class="btn-remove-music" onclick="quitarMusica()" title="Quitar musica">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </div>
                            </div>

                            <!-- Contenedor de forma de onda -->
                            <div class="waveform-container" id="waveformContainer">
                                <canvas class="waveform-canvas" id="waveformCanvas"></canvas>
                                <div class="waveform-selection" id="waveformSelection">
                                    <div class="selection-handle handle-left" id="handleLeft">
                                        <div class="handle-bar"></div>
                                    </div>
                                    <div class="selection-handle handle-right" id="handleRight">
                                        <div class="handle-bar"></div>
                                    </div>
                                </div>
                                <div class="waveform-playhead" id="waveformPlayhead"></div>
                                <div class="waveform-time" id="waveformTime">00:00.0</div>
                            </div>

                            <!-- Controles del cutter -->
                            <div class="audio-cutter-controls">
                                <button type="button" class="cutter-play-btn" id="cutterPlayBtn">
                                    <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M8 5v14l11-7z"/>
                                    </svg>
                                    <svg class="pause-icon" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                                    </svg>
                                </button>

                                <div class="cutter-time-inputs">
                                    <div class="time-input-group">
                                        <label>Desde</label>
                                        <input type="text" class="time-input" id="cutStartInput" value="00:00.0" readonly>
                                    </div>
                                    <div class="time-input-group">
                                        <label>Hasta</label>
                                        <input type="text" class="time-input" id="cutEndInput" value="00:15.0" readonly>
                                    </div>
                                    <div class="time-input-group duration-group">
                                        <label>Duracion</label>
                                        <span class="selection-duration" id="selectionDuration">15.0s</span>
                                    </div>
                                </div>

                                <div class="cutter-volume">
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                                    </svg>
                                    <input type="range" class="volume-slider" id="cutterVolumeSlider" min="0" max="100" value="70">
                                    <span class="volume-value" id="cutterVolumeValue">70%</span>
                                </div>
                            </div>

                            <div class="cutter-hint">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
                                </svg>
                                Arrastra los controles para seleccionar el fragmento
                            </div>

                            <!-- Botón confirmar música -->
                            <button type="button" class="btn-confirm-music" id="btnConfirmMusic" onclick="confirmarMusica()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                                <span>Usar esta música</span>
                            </button>
                        </div>
                    </div>

                    <!-- Selector de música estilo TikTok -->
                    <div class="music-selector">
                        <!-- Header -->
                        <div class="music-selector-header">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                            </svg>
                            <span>Agregar música</span>
                        </div>

                        <!-- Subir música propia -->
                        <div class="music-upload-section">
                            <label class="music-upload-btn" for="musicFileInput">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="17 8 12 3 7 8"></polyline>
                                    <line x1="12" y1="3" x2="12" y2="15"></line>
                                </svg>
                                <span>Subir tu propia música</span>
                                <input type="file" id="musicFileInput" accept="audio/*" onchange="handleMusicUpload(this)">
                            </label>
                        </div>

                        <!-- Tabs -->
                        <div class="music-tabs">
                            <button type="button" class="music-tab active" data-tab="popular" onclick="cambiarTabMusica('popular', this)">Popular</button>
                            <button type="button" class="music-tab" data-tab="parati" onclick="cambiarTabMusica('parati', this)">Para ti</button>
                            <button type="button" class="music-tab" data-tab="favoritos" onclick="cambiarTabMusica('favoritos', this)">Favoritos</button>
                            <button type="button" class="music-tab" data-tab="recientes" onclick="cambiarTabMusica('recientes', this)">Recientes</button>
                            <button type="button" class="music-search-btn" onclick="toggleMusicSearch()" title="Buscar">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <path d="m21 21-4.35-4.35"></path>
                                </svg>
                            </button>
                        </div>

                        <!-- Búsqueda -->
                        <div class="music-search-container" id="musicSearchContainer">
                            <input type="text" class="music-search-input" id="musicSearch" placeholder="Buscar canciones..." oninput="buscarMusica(this.value)">
                        </div>

                        <!-- Lista de canciones -->
                        <div id="musicList" class="music-list-container">
                            <div class="music-empty">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                                </svg>
                                <p>Cargando musica...</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- LINK -->
                <div class="option-section" id="linkOptions">
                    <div class="option-group">
                        <label class="option-label">URL del enlace</label>
                        <input type="url" class="text-input" id="linkUrl" placeholder="https://ejemplo.com" />
                    </div>
                    <div class="option-group">
                        <label class="option-label">Texto del boton</label>
                        <input type="text" class="text-input" id="linkText" placeholder="Ver mas" maxlength="25" value="Ver mas" />
                    </div>
                    <div class="option-group">
                        <label class="option-label">Estilo del boton</label>
                        <div class="link-styles-grid">
                            <!-- Fila 1: Botones solidos -->
                            <div class="link-style-option selected" data-style="pill" onclick="cambiarEstiloLink('pill', this)">
                                <div class="link-preview-pill">Ver mas</div>
                                <span>Pill</span>
                            </div>
                            <div class="link-style-option" data-style="rounded" onclick="cambiarEstiloLink('rounded', this)">
                                <div class="link-preview-rounded">Ver mas</div>
                                <span>Rounded</span>
                            </div>
                            <div class="link-style-option" data-style="square" onclick="cambiarEstiloLink('square', this)">
                                <div class="link-preview-square">Ver mas</div>
                                <span>Square</span>
                            </div>
                            <!-- Fila 2: Botones con borde -->
                            <div class="link-style-option" data-style="outline-pill" onclick="cambiarEstiloLink('outline-pill', this)">
                                <div class="link-preview-outline-pill">Ver mas</div>
                                <span>Outline</span>
                            </div>
                            <div class="link-style-option" data-style="outline-square" onclick="cambiarEstiloLink('outline-square', this)">
                                <div class="link-preview-outline-square">Ver mas</div>
                                <span>Border</span>
                            </div>
                            <div class="link-style-option" data-style="glass" onclick="cambiarEstiloLink('glass', this)">
                                <div class="link-preview-glass">Ver mas</div>
                                <span>Glass</span>
                            </div>
                            <!-- Fila 3: Estilos especiales -->
                            <div class="link-style-option" data-style="gradient" onclick="cambiarEstiloLink('gradient', this)">
                                <div class="link-preview-gradient">Ver mas</div>
                                <span>Gradient</span>
                            </div>
                            <div class="link-style-option" data-style="swipe" onclick="cambiarEstiloLink('swipe', this)">
                                <div class="link-preview-swipe">
                                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"/></svg>
                                    Desliza
                                </div>
                                <span>Swipe</span>
                            </div>
                            <div class="link-style-option" data-style="minimal" onclick="cambiarEstiloLink('minimal', this)">
                                <div class="link-preview-minimal">Ver mas →</div>
                                <span>Minimal</span>
                            </div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Color del boton</label>
                        <div class="color-picker" id="linkColorPicker">
                            <div class="color-option selected" style="background: #4682B4;" onclick="cambiarColorLink('#4682B4', this)"></div>
                            <div class="color-option" style="background: #000000;" onclick="cambiarColorLink('#000000', this)"></div>
                            <div class="color-option" style="background: #ffffff;" onclick="cambiarColorLink('#ffffff', this)"></div>
                            <div class="color-option" style="background: #ff3b5c;" onclick="cambiarColorLink('#ff3b5c', this)"></div>
                            <div class="color-option" style="background: #00d4ff;" onclick="cambiarColorLink('#00d4ff', this)"></div>
                            <div class="color-option" style="background: #ffdd00;" onclick="cambiarColorLink('#ffdd00', this)"></div>
                            <div class="color-option" style="background: #00ff88;" onclick="cambiarColorLink('#00ff88', this)"></div>
                            <div class="color-option" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);" onclick="cambiarColorLink('gradient-purple', this)"></div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Tipografia</label>
                        <div class="link-fonts-grid">
                            <div class="link-font-option selected" data-font="Poppins" onclick="cambiarFuenteLink('Poppins', this)">
                                <span style="font-family: 'Poppins', sans-serif; font-weight: 600;">Poppins</span>
                            </div>
                            <div class="link-font-option" data-font="Montserrat" onclick="cambiarFuenteLink('Montserrat', this)">
                                <span style="font-family: 'Montserrat', sans-serif; font-weight: 700;">Montserrat</span>
                            </div>
                            <div class="link-font-option" data-font="Roboto" onclick="cambiarFuenteLink('Roboto', this)">
                                <span style="font-family: 'Roboto', sans-serif; font-weight: 700;">Roboto</span>
                            </div>
                            <div class="link-font-option" data-font="Oswald" onclick="cambiarFuenteLink('Oswald', this)">
                                <span style="font-family: 'Oswald', sans-serif; font-weight: 600;">Oswald</span>
                            </div>
                            <div class="link-font-option" data-font="Bebas Neue" onclick="cambiarFuenteLink('Bebas Neue', this)">
                                <span style="font-family: 'Bebas Neue', sans-serif;">BEBAS</span>
                            </div>
                            <div class="link-font-option" data-font="Anton" onclick="cambiarFuenteLink('Anton', this)">
                                <span style="font-family: 'Anton', sans-serif;">ANTON</span>
                            </div>
                            <div class="link-font-option" data-font="Playfair Display" onclick="cambiarFuenteLink('Playfair Display', this)">
                                <span style="font-family: 'Playfair Display', serif; font-weight: 700;">Playfair</span>
                            </div>
                            <div class="link-font-option" data-font="Lobster" onclick="cambiarFuenteLink('Lobster', this)">
                                <span style="font-family: 'Lobster', cursive;">Lobster</span>
                            </div>
                            <div class="link-font-option" data-font="Pacifico" onclick="cambiarFuenteLink('Pacifico', this)">
                                <span style="font-family: 'Pacifico', cursive;">Pacifico</span>
                            </div>
                            <div class="link-font-option" data-font="Dancing Script" onclick="cambiarFuenteLink('Dancing Script', this)">
                                <span style="font-family: 'Dancing Script', cursive; font-weight: 700;">Dancing</span>
                            </div>
                            <div class="link-font-option" data-font="Permanent Marker" onclick="cambiarFuenteLink('Permanent Marker', this)">
                                <span style="font-family: 'Permanent Marker', cursive;">Marker</span>
                            </div>
                            <div class="link-font-option" data-font="Satisfy" onclick="cambiarFuenteLink('Satisfy', this)">
                                <span style="font-family: 'Satisfy', cursive;">Satisfy</span>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 12px;" onclick="agregarLink()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                        </svg>
                        Agregar enlace
                    </button>
                    <div id="linkAddedIndicator" style="display: none; margin-top: 12px; padding: 10px; background: rgba(0,255,136,0.1); border: 1px solid #00ff88; border-radius: 8px; text-align: center;">
                        <span style="color: #00ff88; font-size: 13px;">
                            <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14" style="vertical-align: middle; margin-right: 4px;"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                            Enlace agregado - puedes moverlo
                        </span>
                        <button onclick="eliminarLinkActual()" style="display: block; margin: 8px auto 0; padding: 4px 12px; background: transparent; border: 1px solid #ff3b5c; color: #ff3b5c; border-radius: 4px; cursor: pointer; font-size: 11px;">
                            Eliminar enlace
                        </button>
                    </div>
                </div>

                <!-- EFECTOS DE VIDEO -->
                <div class="option-section" id="effectsOptions">
                    <div class="option-group">
                        <label class="option-label">Velocidad</label>
                        <div class="effects-grid">
                            <button class="effect-btn" data-effect="normal" onclick="aplicarEfectoVideo('normal', this)">
                                <div class="effect-icon">1x</div>
                                <span>Normal</span>
                            </button>
                            <button class="effect-btn" data-effect="slowmo" onclick="aplicarEfectoVideo('slowmo', this)">
                                <div class="effect-icon">0.5x</div>
                                <span>Lento</span>
                            </button>
                            <button class="effect-btn" data-effect="fast" onclick="aplicarEfectoVideo('fast', this)">
                                <div class="effect-icon">2x</div>
                                <span>Rápido</span>
                            </button>
                            <button class="effect-btn" data-effect="reverse" onclick="aplicarEfectoVideo('reverse', this)">
                                <div class="effect-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                                    </svg>
                                </div>
                                <span>Reversa</span>
                            </button>
                            <button class="effect-btn" data-effect="boomerang" onclick="aplicarEfectoVideo('boomerang', this)">
                                <div class="effect-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                        <path d="M17 1l4 4-4 4"/>
                                        <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                                        <path d="M7 23l-4-4 4-4"/>
                                        <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
                                    </svg>
                                </div>
                                <span>Boomerang</span>
                            </button>
                        </div>
                    </div>

                    <div class="option-group">
                        <label class="option-label">Estilo</label>
                        <div class="effects-grid">
                            <button class="effect-btn" data-effect="none" onclick="aplicarEstiloVideo('none', this)">
                                <div class="effect-preview effect-none"></div>
                                <span>Original</span>
                            </button>
                            <button class="effect-btn" data-effect="glitch" onclick="aplicarEstiloVideo('glitch', this)">
                                <div class="effect-preview effect-glitch"></div>
                                <span>Glitch</span>
                            </button>
                            <button class="effect-btn" data-effect="vhs" onclick="aplicarEstiloVideo('vhs', this)">
                                <div class="effect-preview effect-vhs"></div>
                                <span>VHS</span>
                            </button>
                            <button class="effect-btn" data-effect="retro" onclick="aplicarEstiloVideo('retro', this)">
                                <div class="effect-preview effect-retro"></div>
                                <span>Retro</span>
                            </button>
                            <button class="effect-btn" data-effect="cinematic" onclick="aplicarEstiloVideo('cinematic', this)">
                                <div class="effect-preview effect-cinematic"></div>
                                <span>Cine</span>
                            </button>
                            <button class="effect-btn" data-effect="noir" onclick="aplicarEstiloVideo('noir', this)">
                                <div class="effect-preview effect-noir"></div>
                                <span>Noir</span>
                            </button>
                        </div>
                    </div>

                    <div class="option-group" id="effectIntensityGroup" style="display: none;">
                        <label class="option-label">Intensidad: <span id="effectIntensityValue">50%</span></label>
                        <input type="range" class="size-slider" id="effectIntensity" min="0" max="100" value="50" oninput="ajustarIntensidadEfecto(this.value)">
                    </div>

                    <div class="effect-info">
                        <small>Los efectos se aplicarán al video final. El preview es aproximado.</small>
                    </div>
                </div>

                <!-- AJUSTES DE IMAGEN/VIDEO -->
                <div class="option-section" id="adjustOptions">
                    <!-- Voltear -->
                    <div class="option-group">
                        <label class="option-label">Voltear</label>
                        <div class="adjust-buttons">
                            <button class="adjust-btn" onclick="voltearHorizontal()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/>
                                </svg>
                                Horizontal
                            </button>
                            <button class="adjust-btn" onclick="voltearVertical()">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <path d="M21 8V3h-5M3 16l18-13M3 8V3h5M9 9L3 3M21 16v5h-5M15 15l6 6"/>
                                </svg>
                                Vertical
                            </button>
                        </div>
                    </div>

                    <!-- Rotar -->
                    <div class="option-group">
                        <label class="option-label">Rotar</label>
                        <div class="adjust-buttons">
                            <button class="adjust-btn" onclick="rotarImagen(-90)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <path d="M2.5 2v6h6M2.66 15.57a10 10 0 1 0 .57-8.38"/>
                                </svg>
                                -90°
                            </button>
                            <button class="adjust-btn" onclick="rotarImagen(90)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <path d="M21.5 2v6h-6M21.34 15.57a10 10 0 1 1-.57-8.38"/>
                                </svg>
                                +90°
                            </button>
                        </div>
                    </div>

                    <!-- Filtros -->
                    <div class="option-group">
                        <label class="option-label">Filtros</label>
                        <div class="filters-grid">
                            <div class="filter-option selected" onclick="aplicarFiltro('none', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                                <span>Original</span>
                            </div>
                            <div class="filter-option" onclick="aplicarFiltro('grayscale', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #555, #999); filter: grayscale(100%);"></div>
                                <span>B&N</span>
                            </div>
                            <div class="filter-option" onclick="aplicarFiltro('sepia', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #704214, #c4a35a);"></div>
                                <span>Sepia</span>
                            </div>
                            <div class="filter-option" onclick="aplicarFiltro('vintage', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #8b7355, #d4a574);"></div>
                                <span>Vintage</span>
                            </div>
                            <div class="filter-option" onclick="aplicarFiltro('cold', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #1e3c72, #2a5298);"></div>
                                <span>Frio</span>
                            </div>
                            <div class="filter-option" onclick="aplicarFiltro('warm', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #f12711, #f5af19);"></div>
                                <span>Calido</span>
                            </div>
                            <div class="filter-option" onclick="aplicarFiltro('contrast', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #000, #fff);"></div>
                                <span>Contraste</span>
                            </div>
                            <div class="filter-option" onclick="aplicarFiltro('brightness', this)">
                                <div class="filter-preview" style="background: linear-gradient(135deg, #ffecd2, #fcb69f);"></div>
                                <span>Brillo</span>
                            </div>
                        </div>
                    </div>

                    <!-- Ajustes manuales -->
                    <div class="option-group">
                        <label class="option-label">Brillo: <span id="brightnessLabel">0</span></label>
                        <input type="range" class="size-slider" id="brightnessSlider" min="-100" max="100" value="0" oninput="ajustarBrillo(this.value)">
                    </div>
                    <div class="option-group">
                        <label class="option-label">Contraste: <span id="contrastLabel">0</span></label>
                        <input type="range" class="size-slider" id="contrastSlider" min="-100" max="100" value="0" oninput="ajustarContraste(this.value)">
                    </div>
                    <div class="option-group">
                        <label class="option-label">Saturacion: <span id="saturationLabel">0</span></label>
                        <input type="range" class="size-slider" id="saturationSlider" min="-100" max="100" value="0" oninput="ajustarSaturacion(this.value)">
                    </div>

                    <!-- Resetear -->
                    <button class="btn btn-secondary" style="width: 100%; margin-top: 12px;" onclick="resetearAjustes()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                        </svg>
                        Resetear ajustes
                    </button>
                </div>

                <!-- RECORTAR / CROP -->
                <div class="option-section" id="cropOptions">
                    <div class="option-group">
                        <label class="option-label">Proporcion</label>
                        <div class="adjust-buttons" style="flex-wrap: wrap;">
                            <button class="adjust-btn active" data-aspect="free" onclick="seleccionarAspectRatio('free', this)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                                </svg>
                                Libre
                            </button>
                            <button class="adjust-btn" data-aspect="9:16" onclick="seleccionarAspectRatio('9:16', this)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <rect x="6" y="2" width="12" height="20" rx="2"/>
                                </svg>
                                9:16
                            </button>
                            <button class="adjust-btn" data-aspect="1:1" onclick="seleccionarAspectRatio('1:1', this)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <rect x="4" y="4" width="16" height="16" rx="2"/>
                                </svg>
                                1:1
                            </button>
                            <button class="adjust-btn" data-aspect="4:5" onclick="seleccionarAspectRatio('4:5', this)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                    <rect x="5" y="3" width="14" height="18" rx="2"/>
                                </svg>
                                4:5
                            </button>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Zoom</label>
                        <input type="range" class="size-slider" id="cropZoomSlider" min="100" max="200" value="100" oninput="ajustarZoomCrop(this.value)">
                    </div>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 12px;" onclick="abrirRecortador()">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <path d="M6 2v14a2 2 0 0 0 2 2h14"/>
                            <path d="M18 22V8a2 2 0 0 0-2-2H2"/>
                        </svg>
                        Abrir recortador
                    </button>
                    <p style="font-size: 11px; color: var(--muted); margin-top: 8px; text-align: center;">
                        Tambien puedes hacer zoom con pinch o scroll sobre la imagen
                    </p>
                </div>

                <!-- FONDOS / BACKGROUNDS -->
                <div class="option-section" id="backgroundOptions">
                    <div class="option-group">
                        <label class="option-label">Colores solidos</label>
                        <div class="bg-colors-grid">
                            <div class="bg-color-option" style="background: #000000;" onclick="aplicarFondoColor('#000000', this)"></div>
                            <div class="bg-color-option" style="background: #ffffff;" onclick="aplicarFondoColor('#ffffff', this)"></div>
                            <div class="bg-color-option" style="background: #1a1a2e;" onclick="aplicarFondoColor('#1a1a2e', this)"></div>
                            <div class="bg-color-option" style="background: #16213e;" onclick="aplicarFondoColor('#16213e', this)"></div>
                            <div class="bg-color-option" style="background: #0f3460;" onclick="aplicarFondoColor('#0f3460', this)"></div>
                            <div class="bg-color-option" style="background: #e94560;" onclick="aplicarFondoColor('#e94560', this)"></div>
                            <div class="bg-color-option" style="background: #ff6b6b;" onclick="aplicarFondoColor('#ff6b6b', this)"></div>
                            <div class="bg-color-option" style="background: #feca57;" onclick="aplicarFondoColor('#feca57', this)"></div>
                            <div class="bg-color-option" style="background: #48dbfb;" onclick="aplicarFondoColor('#48dbfb', this)"></div>
                            <div class="bg-color-option" style="background: #1dd1a1;" onclick="aplicarFondoColor('#1dd1a1', this)"></div>
                            <div class="bg-color-option" style="background: #5f27cd;" onclick="aplicarFondoColor('#5f27cd', this)"></div>
                            <div class="bg-color-option" style="background: #ff9ff3;" onclick="aplicarFondoColor('#ff9ff3', this)"></div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Gradientes</label>
                        <div class="backgrounds-grid" id="gradientsGrid">
                            <div class="bg-option" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #667eea 0%, #764ba2 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #fa709a 0%, #fee140 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #ff0844 0%, #ffb199 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #ff0844 0%, #ffb199 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #30cfd0 0%, #330867 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(180deg, #2c3e50 0%, #3498db 100%);" onclick="aplicarFondoGradiente('linear-gradient(180deg, #2c3e50 0%, #3498db 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(180deg, #232526 0%, #414345 100%);" onclick="aplicarFondoGradiente('linear-gradient(180deg, #232526 0%, #414345 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #ee0979 0%, #ff6a00 100%)', this)"></div>
                            <div class="bg-option" style="background: linear-gradient(135deg, #7f00ff 0%, #e100ff 100%);" onclick="aplicarFondoGradiente('linear-gradient(135deg, #7f00ff 0%, #e100ff 100%)', this)"></div>
                        </div>
                    </div>
                    <div class="option-group">
                        <label class="option-label">Efecto blur del fondo</label>
                        <input type="range" class="size-slider" id="bgBlurSlider" min="0" max="20" value="0" oninput="aplicarBlurFondo(this.value)">
                    </div>
                </div>

                <!-- PLANTILLAS / TEMPLATES -->
                <div class="option-section" id="templateOptions">
                    <div class="templates-tabs" id="templatesTabs">
                        <button class="template-tab active" data-category="all" onclick="filtrarPlantillas('all', this)">Todas</button>
                        <button class="template-tab" data-category="promo" onclick="filtrarPlantillas('promo', this)">Promo</button>
                        <button class="template-tab" data-category="quote" onclick="filtrarPlantillas('quote', this)">Frases</button>
                        <button class="template-tab" data-category="social" onclick="filtrarPlantillas('social', this)">Social</button>
                        <button class="template-tab" data-category="neon" onclick="filtrarPlantillas('neon', this)">Neon</button>
                        <button class="template-tab" data-category="minimal" onclick="filtrarPlantillas('minimal', this)">Minimal</button>
                        <button class="template-tab" data-category="birthday" onclick="filtrarPlantillas('birthday', this)">Cumple</button>
                        <button class="template-tab" data-category="sale" onclick="filtrarPlantillas('sale', this)">Ventas</button>
                    </div>
                    <div class="templates-grid" id="templatesGrid">
                        <!-- Se llenan dinámicamente -->
                    </div>
                </div>

                <!-- BEAT SYNC - Video musical -->
                <div class="option-section" id="beatsyncOptions">
                    <div class="beatsync-container">
                        <!-- Título y Progress (arriba) -->
                        <div class="beatsync-header">
                            <h3 class="beatsync-title">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M9 18V5l12-2v13"/>
                                    <circle cx="6" cy="18" r="3"/>
                                    <circle cx="18" cy="16" r="3"/>
                                </svg>
                                Beat Sync
                            </h3>
                            <div class="beatsync-progress" id="beatsyncProgress">
                                <div class="beatsync-progress-bar">
                                    <div class="beatsync-progress-fill" id="beatsyncProgressFill" style="width: 0%;"></div>
                                </div>
                                <div class="beatsync-progress-text" id="beatsyncProgressText">Analizando audio...</div>
                            </div>
                        </div>

                        <!-- Sección: Música -->
                        <div class="beatsync-section">
                            <div class="beatsync-section-title">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M9 18V5l12-2v13"/>
                                    <circle cx="6" cy="18" r="3"/>
                                    <circle cx="18" cy="16" r="3"/>
                                </svg>
                                Música
                            </div>

                            <!-- Tabs: Subir / Biblioteca -->
                            <div class="beatsync-music-tabs">
                                <button class="beatsync-music-tab active" data-tab="upload" onclick="cambiarTabMusica('upload', this)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    Subir
                                </button>
                                <button class="beatsync-music-tab" data-tab="library" onclick="cambiarTabMusica('library', this)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M9 18V5l12-2v13"/>
                                        <circle cx="6" cy="18" r="3"/>
                                        <circle cx="18" cy="16" r="3"/>
                                    </svg>
                                    Biblioteca
                                </button>
                            </div>

                            <!-- Tab: Subir música -->
                            <div class="beatsync-music-tab-content active" id="beatsyncTabUpload">
                                <div class="beatsync-music-upload" id="beatsyncMusicUpload" onclick="document.getElementById('beatsyncMusicInput').click()">
                                    <svg class="beatsync-music-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M9 18V5l12-2v13"/>
                                        <circle cx="6" cy="18" r="3"/>
                                        <circle cx="18" cy="16" r="3"/>
                                    </svg>
                                    <div class="beatsync-music-text">Toca para subir una canción</div>
                                    <div class="beatsync-music-name" id="beatsyncMusicName" style="display: none;"></div>
                                </div>
                            </div>
                            <input type="file" id="beatsyncMusicInput" accept="audio/*" style="display: none;" onchange="handleBeatSyncMusic(event)">

                            <!-- Tab: Biblioteca de música -->
                            <div class="beatsync-music-tab-content" id="beatsyncTabLibrary">
                                <!-- Búsqueda -->
                                <div class="beatsync-music-search">
                                    <input type="text" id="beatsyncMusicSearch" placeholder="Buscar canciones..." oninput="buscarMusicaLibraryDebounced(this.value)">
                                </div>

                                <!-- Categorías -->
                                <div class="beatsync-music-categories" id="beatsyncMusicCategories">
                                    <button class="beatsync-music-category active" data-category="all" onclick="filtrarMusicaCategoria('all', this)">Todas</button>
                                    <button class="beatsync-music-category" data-category="trending" onclick="filtrarMusicaCategoria('trending', this)">Trending</button>
                                    <button class="beatsync-music-category" data-category="pop" onclick="filtrarMusicaCategoria('pop', this)">Pop</button>
                                    <button class="beatsync-music-category" data-category="electronic" onclick="filtrarMusicaCategoria('electronic', this)">Electro</button>
                                    <button class="beatsync-music-category" data-category="hiphop" onclick="filtrarMusicaCategoria('hiphop', this)">Hip Hop</button>
                                    <button class="beatsync-music-category" data-category="latin" onclick="filtrarMusicaCategoria('latin', this)">Latino</button>
                                </div>

                                <!-- Lista de tracks -->
                                <div class="beatsync-music-library" id="beatsyncMusicLibrary">
                                    <div class="beatsync-library-loading" id="beatsyncLibraryLoading">
                                        <span>Cargando música...</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Audio Cutter Visual (se muestra después de cargar música) -->
                            <div class="beatsync-audio-cutter" id="beatsyncAudioCutter" style="display: none;">
                                    <div class="beatsync-cutter-header">
                                        <div class="beatsync-cutter-filename" id="beatsyncCutterFilename">Audio</div>
                                        <div class="beatsync-cutter-info">
                                            <span id="beatsyncCutterDuration">00:00</span>
                                            <span>•</span>
                                            <span id="beatsyncCutterBeats">0 beats</span>
                                        </div>
                                    </div>

                                    <!-- Waveform visual con selección -->
                                    <div class="beatsync-waveform-visual" id="beatsyncWaveformVisual">
                                        <canvas class="beatsync-waveform-canvas" id="beatsyncWaveformCanvas2"></canvas>
                                        <!-- Overlays para oscurecer fuera de selección -->
                                        <div class="beatsync-waveform-overlay-left" id="beatsyncOverlayLeft"></div>
                                        <div class="beatsync-waveform-overlay-right" id="beatsyncOverlayRight"></div>
                                        <!-- Área de selección (solo visual) -->
                                        <div class="beatsync-waveform-selection" id="beatsyncWaveformSelection"></div>
                                        <!-- Handles independientes -->
                                        <div class="beatsync-selection-handle handle-left" id="beatsyncHandleLeft">
                                            <div class="handle-bar"></div>
                                        </div>
                                        <div class="beatsync-selection-handle handle-right" id="beatsyncHandleRight">
                                            <div class="handle-bar"></div>
                                        </div>
                                        <div class="beatsync-waveform-playhead" id="beatsyncCutterPlayhead"></div>
                                    </div>

                                    <!-- Controles del cutter -->
                                    <div class="beatsync-cutter-controls">
                                        <button type="button" class="beatsync-cutter-play-btn" id="beatsyncCutterPlayBtn" onclick="toggleCutterPlayback()">
                                            <svg class="play-icon" viewBox="0 0 24 24">
                                                <path d="M8 5v14l11-7z"/>
                                            </svg>
                                            <svg class="pause-icon" viewBox="0 0 24 24">
                                                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                                            </svg>
                                        </button>

                                        <div class="beatsync-time-group beatsync-duration-group">
                                            <label>Dur.</label>
                                            <input type="number" class="beatsync-duration-input" id="beatsyncCutDuration" value="30" min="5" max="300" step="1" onchange="onDurationChange(this.value)">
                                        </div>

                                        <div class="beatsync-cutter-times">
                                            <div class="beatsync-time-group">
                                                <label>Desde</label>
                                                <span class="beatsync-time-value" id="beatsyncCutStart">00:00.0</span>
                                            </div>
                                            <div class="beatsync-time-group beatsync-current-time">
                                                <label>Actual</label>
                                                <span class="beatsync-time-value" id="beatsyncCurrentTime">00:00.0</span>
                                            </div>
                                            <div class="beatsync-time-group">
                                                <label>Hasta</label>
                                                <span class="beatsync-time-value" id="beatsyncCutEnd">00:30.0</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="beatsync-cutter-hint">
                                        <svg viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
                                        </svg>
                                        Arrastra los controles para seleccionar el fragmento
                                    </div>

                                    <!-- Info de beats -->
                                    <div class="beatsync-beats-info" style="margin-top: 12px;">
                                        <div class="beatsync-beats-stat">
                                            <div class="beatsync-beats-dot" id="beatsyncBeatDot"></div>
                                            <span class="beatsync-beats-text">
                                                <span class="beatsync-beats-count" id="beatsyncBeatsCount">0</span> beats detectados
                                            </span>
                                        </div>
                                    </div>

                                    <!-- Modo de detección -->
                                    <div class="beatsync-mode-selector" style="margin-top: 10px;">
                                        <button class="beatsync-mode-btn active" data-mode="auto" onclick="setBeatSyncMode('auto', this)">Auto</button>
                                        <button class="beatsync-mode-btn" data-mode="bass" onclick="setBeatSyncMode('bass', this)">Solo Bajos</button>
                                        <button class="beatsync-mode-btn" data-mode="all" onclick="setBeatSyncMode('all', this)">Todos</button>
                                    </div>
                                </div>
                        </div>

                        <!-- Sección: Subir fotos -->
                        <div class="beatsync-section">
                            <div class="beatsync-section-title">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                    <circle cx="8.5" cy="8.5" r="1.5"/>
                                    <polyline points="21 15 16 10 5 21"/>
                                </svg>
                                Fotos (<span id="beatsyncPhotosCountLabel">0</span>)
                            </div>
                            <div class="beatsync-photos-upload" id="beatsyncPhotosUpload" onclick="document.getElementById('beatsyncPhotosInput').click()">
                                <svg class="beatsync-music-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                    <line x1="12" y1="8" x2="12" y2="16"/>
                                    <line x1="8" y1="12" x2="16" y2="12"/>
                                </svg>
                                <div class="beatsync-music-text">Toca para agregar fotos</div>
                            </div>
                            <div class="beatsync-photos-grid" id="beatsyncPhotosGrid" style="display: none;"></div>
                            <div class="beatsync-photos-actions" id="beatsyncPhotosInfo" style="display: none;">
                                <span class="beatsync-photos-hint">Arrastra para reordenar</span>
                                <button class="beatsync-shuffle-btn" onclick="shuffleBeatSyncPhotos()" title="Orden aleatorio">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                                        <polyline points="16 3 21 3 21 8"/>
                                        <line x1="4" y1="20" x2="21" y2="3"/>
                                        <polyline points="21 16 21 21 16 21"/>
                                        <line x1="15" y1="15" x2="21" y2="21"/>
                                        <line x1="4" y1="4" x2="9" y2="9"/>
                                    </svg>
                                    Mezclar
                                </button>
                            </div>
                            <input type="file" id="beatsyncPhotosInput" accept="image/*,.heic,.heif" multiple style="display: none;" onchange="handleBeatSyncPhotos(event)">
                        </div>

                        <!-- Sección: Configuración -->
                        <div class="beatsync-section">
                            <div class="beatsync-section-title">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                                </svg>
                                Configuración
                            </div>
                            <div class="beatsync-config">
                                <div class="beatsync-config-row">
                                    <span class="beatsync-config-label">Transición</span>
                                    <select class="beatsync-select" id="beatsyncTransition">
                                        <option value="cut">Corte directo</option>
                                        <option value="fade">Fundido</option>
                                        <option value="zoom">Zoom In</option>
                                        <option value="zoom-out">Zoom Out</option>
                                        <option value="flash">Flash</option>
                                        <option value="slide">Deslizar</option>
                                        <option value="wipe-left">Barrido ←</option>
                                        <option value="wipe-right">Barrido →</option>
                                        <option value="wipe-up">Barrido ↑</option>
                                        <option value="wipe-down">Barrido ↓</option>
                                        <option value="spin">Giro</option>
                                        <option value="pixelize">Pixelado</option>
                                        <option value="blur">Desenfoque</option>
                                        <option value="glitch">Glitch</option>
                                        <option value="shake">Temblor</option>
                                    </select>
                                </div>
                                <div class="beatsync-config-row">
                                    <span class="beatsync-config-label">Sensibilidad</span>
                                    <div class="beatsync-slider-container">
                                        <input type="range" class="beatsync-slider" id="beatsyncSensitivity" min="1" max="20" value="10" oninput="updateSensitivityLabel(this.value); onSensitivityChange();" onchange="onSensitivityChangeImmediate()">
                                        <span class="beatsync-slider-value" id="beatsyncSensitivityValue">10</span>
                                    </div>
                                </div>
                                <div class="beatsync-config-row">
                                    <span class="beatsync-config-label">Umbral</span>
                                    <div class="beatsync-slider-container">
                                        <input type="range" class="beatsync-slider" id="beatsyncThreshold" min="1" max="10" value="3" oninput="updateThresholdLabel(this.value); onSensitivityChange();" onchange="onSensitivityChangeImmediate()">
                                        <span class="beatsync-slider-value" id="beatsyncThresholdValue">3 (bajo)</span>
                                    </div>
                                </div>
                                <div class="beatsync-config-row">
                                    <span class="beatsync-config-label">Agudeza</span>
                                    <div class="beatsync-slider-container">
                                        <input type="range" class="beatsync-slider" id="beatsyncSharpness" min="1" max="10" value="3" oninput="updateSharpnessLabel(this.value); onSensitivityChange();" onchange="onSensitivityChangeImmediate()">
                                        <span class="beatsync-slider-value" id="beatsyncSharpnessValue">3 (suave)</span>
                                    </div>
                                </div>
                                <div class="beatsync-config-row">
                                    <span class="beatsync-config-label">Intervalo mín.</span>
                                    <div class="beatsync-slider-container">
                                        <input type="range" class="beatsync-slider" id="beatsyncMinInterval" min="0.01" max="1" step="0.01" value="0.08" oninput="updateMinIntervalLabel(this.value); onSensitivityChange();" onchange="onSensitivityChangeImmediate()">
                                        <span class="beatsync-slider-value" id="beatsyncMinIntervalValue">80ms</span>
                                    </div>
                                </div>

                                <!-- Partículas animadas -->
                                <div class="beatsync-particles-section">
                                    <div class="beatsync-particles-title">Partículas en beats</div>
                                    <div class="beatsync-particles-grid">
                                        <div class="beatsync-particle-option selected" data-particle="none" onclick="seleccionarParticula('none', this)">
                                            <span class="beatsync-particle-icon">🚫</span>
                                            <span class="beatsync-particle-label">Ninguna</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="confetti" onclick="seleccionarParticula('confetti', this)">
                                            <span class="beatsync-particle-icon">🎊</span>
                                            <span class="beatsync-particle-label">Confetti</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="hearts" onclick="seleccionarParticula('hearts', this)">
                                            <span class="beatsync-particle-icon">💕</span>
                                            <span class="beatsync-particle-label">Corazones</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="stars" onclick="seleccionarParticula('stars', this)">
                                            <span class="beatsync-particle-icon">⭐</span>
                                            <span class="beatsync-particle-label">Estrellas</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="sparkles" onclick="seleccionarParticula('sparkles', this)">
                                            <span class="beatsync-particle-icon">✨</span>
                                            <span class="beatsync-particle-label">Brillos</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="fire" onclick="seleccionarParticula('fire', this)">
                                            <span class="beatsync-particle-icon">🔥</span>
                                            <span class="beatsync-particle-label">Fuego</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="bubbles" onclick="seleccionarParticula('bubbles', this)">
                                            <span class="beatsync-particle-icon">🫧</span>
                                            <span class="beatsync-particle-label">Burbujas</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="snow" onclick="seleccionarParticula('snow', this)">
                                            <span class="beatsync-particle-icon">❄️</span>
                                            <span class="beatsync-particle-label">Nieve</span>
                                        </div>
                                        <div class="beatsync-particle-option" data-particle="petals" onclick="seleccionarParticula('petals', this)">
                                            <span class="beatsync-particle-icon">🌸</span>
                                            <span class="beatsync-particle-label">Pétalos</span>
                                        </div>
                                    </div>
                                    <!-- Configuración de intensidad -->
                                    <div class="beatsync-particles-config" id="beatsyncParticlesConfig">
                                        <div class="beatsync-config-row">
                                            <span class="beatsync-config-label">Intensidad</span>
                                            <div class="beatsync-slider-container">
                                                <input type="range" class="beatsync-slider" id="beatsyncParticleIntensity" min="1" max="10" value="5" oninput="updateParticleIntensityLabel(this.value)">
                                                <span class="beatsync-slider-value" id="beatsyncParticleIntensityValue">5</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Preview mejorado -->
                        <div class="beatsync-preview-container" id="beatsyncPreviewSection" style="display: none;">
                            <div class="beatsync-preview" id="beatsyncPreviewWrapper">
                                <canvas id="beatsyncPreviewCanvas" class="beatsync-preview-canvas"></canvas>
                                <div class="beatsync-beat-flash" id="beatsyncBeatFlash"></div>
                                <div class="beatsync-photo-indicator" id="beatsyncPhotoIndicator">1 / 1</div>
                                <div class="beatsync-preview-overlay" id="beatsyncPreviewOverlay">
                                    <button class="beatsync-preview-play" onclick="toggleBeatSyncPreview()">
                                        <svg viewBox="0 0 24 24" fill="currentColor">
                                            <polygon points="5 3 19 12 5 21 5 3"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="beatsync-preview-controls">
                                <button class="beatsync-control-btn" id="beatsyncStopBtn" onclick="stopBeatSyncPreview()" title="Detener">
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <rect x="6" y="6" width="12" height="12"/>
                                    </svg>
                                </button>
                                <button class="beatsync-control-btn main" id="beatsyncPlayPauseBtn" onclick="toggleBeatSyncPreview()" title="Play/Pause">
                                    <svg id="beatsyncPlayIcon" viewBox="0 0 24 24" fill="currentColor">
                                        <polygon points="5 3 19 12 5 21 5 3"/>
                                    </svg>
                                </button>
                                <div class="beatsync-timeline" id="beatsyncTimeline" onclick="seekBeatSyncTimeline(event)">
                                    <div class="beatsync-timeline-progress" id="beatsyncTimelineProgress"></div>
                                </div>
                                <span class="beatsync-timeline-time" id="beatsyncTimeDisplay">0:00 / 0:00</span>
                            </div>
                        </div>

                        <!-- Botones de acción -->
                        <div class="beatsync-actions">
                            <button class="beatsync-btn beatsync-btn-outline" id="beatsyncRegenerateBtn" onclick="reanalyzeBeatSync()" title="Volver a analizar los beats">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                                    <path d="M3 3v5h5"/>
                                </svg>
                                Regenerar
                            </button>
                            <button class="beatsync-btn beatsync-btn-secondary" id="beatsyncPreviewBtn" onclick="previewBeatSync()" disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polygon points="5 3 19 12 5 21 5 3"/>
                                </svg>
                                Preview
                            </button>
                            <button class="beatsync-btn beatsync-btn-primary" id="beatsyncGenerateBtn" onclick="generateBeatSync()" disabled>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M23 7l-7 5 7 5V7z"/>
                                    <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                                </svg>
                                Generar
                            </button>
                        </div>
                    </div>
                </div>

                <!-- PUBLICAR -->
                <div class="option-section" id="publishOptions">
                    <div class="option-group">
                        <label class="option-label">Visibilidad</label>
                        <div class="lado-selector">
                            <div class="lado-option selected" data-lado="LadoA" onclick="seleccionarLado('LadoA', this)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24" style="margin-bottom: 4px;">
                                    <circle cx="12" cy="12" r="10"/>
                                </svg>
                                <div style="font-weight: 600;">Lado A</div>
                                <div style="font-size: 11px; color: var(--muted);">Visible para todos</div>
                            </div>
                            @if (usuarioVerificado)
                            {
                            <div class="lado-option" data-lado="LadoB" onclick="seleccionarLado('LadoB', this)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24" style="margin-bottom: 4px;">
                                    <path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zM2 12h20"/>
                                </svg>
                                <div style="font-weight: 600;">Lado B</div>
                                <div style="font-size: 11px; color: var(--muted);">Solo suscriptores</div>
                            </div>
                            }
                        </div>
                    </div>

                    <!-- Opción: Publicar también en Feed -->
                    <div class="option-group" style="margin-top: 16px;">
                        <label class="toggle-option" style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--surface); border-radius: 8px; cursor: pointer;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20" style="color: var(--primary);">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                    <line x1="3" y1="9" x2="21" y2="9"/>
                                    <line x1="9" y1="21" x2="9" y2="9"/>
                                </svg>
                                <div>
                                    <div style="font-weight: 500; font-size: 13px;">Publicar también en Feed</div>
                                    <div style="font-size: 11px; color: var(--muted);">Crear un post permanente con este contenido</div>
                                </div>
                            </div>
                            <input type="checkbox" id="publicarEnFeed" style="width: 18px; height: 18px; accent-color: var(--primary);">
                        </label>
                    </div>
                </div>
            </div>

            <div class="options-footer">
                <button class="btn btn-secondary" onclick="cancelarEditor()">Cancelar</button>
                <button class="btn btn-outline-primary" id="downloadBtn" onclick="descargarMedia()" disabled title="Descargar antes de publicar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <button class="btn btn-primary" id="publishBtn" onclick="abrirModalPublicar()" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                    @textoPublicar
                </button>
            </div>
        </div>
    </div>

    <!-- Modal de Publicación -->
    <div class="publish-modal-overlay" id="publishModalOverlay" onclick="cerrarModalPublicar(event)">
        <div class="publish-modal" onclick="event.stopPropagation()">
            <div class="publish-modal-header">
                <h3>Publicar @(modo == "reel" ? "Reel" : "Historia")</h3>
                <button class="publish-modal-close" onclick="cerrarModalPublicar()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="publish-modal-body">
                <!-- Selector de Visibilidad -->
                <div class="publish-section">
                    <div class="publish-section-title">Visibilidad</div>
                    <div class="publish-lado-selector">
                        <div class="publish-lado-option selected" data-lado="LadoA" onclick="seleccionarLadoPublish('LadoA', this)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M2 12h20"/>
                            </svg>
                            <div class="publish-lado-info">
                                <div class="publish-lado-name">Lado A</div>
                                <div class="publish-lado-desc">Visible para todos</div>
                            </div>
                            <div class="publish-lado-check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </div>
                        </div>
                        @if (usuarioVerificado)
                        {
                        <div class="publish-lado-option" data-lado="LadoB" onclick="seleccionarLadoPublish('LadoB', this)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M12 2a10 10 0 0 0 0 20"/>
                                <path d="M2 12h10"/>
                            </svg>
                            <div class="publish-lado-info">
                                <div class="publish-lado-name">Lado B</div>
                                <div class="publish-lado-desc">Solo para suscriptores</div>
                            </div>
                            <div class="publish-lado-check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </div>
                        </div>
                        }
                    </div>
                </div>

                <!-- Opción: Publicar en Feed -->
                <div class="publish-section">
                    <div class="publish-toggle-option" onclick="togglePublicarEnFeed()">
                        <div class="publish-toggle-info">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <line x1="3" y1="9" x2="21" y2="9"/>
                                <line x1="9" y1="21" x2="9" y2="9"/>
                            </svg>
                            <div class="publish-toggle-text">
                                <h4>Publicar también en Feed</h4>
                                <p>Crear un post permanente con este contenido</p>
                            </div>
                        </div>
                        <div class="publish-toggle-switch" id="publishFeedToggle"></div>
                    </div>
                </div>
            </div>
            <div class="publish-modal-footer">
                <button class="btn btn-secondary" onclick="cerrarModalPublicar()">Cancelar</button>
                <button class="btn btn-primary" onclick="confirmarPublicacion()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                    Publicar
                </button>
            </div>
        </div>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <p id="loadingText">Publicando @(modo == "reel" ? "reel" : "historia")...</p>
    </div>

    <!-- Crop overlay -->
    <div class="crop-overlay" id="cropOverlay">
        <div class="crop-header">
            <h4>Recortar</h4>
            <div class="crop-actions">
                <button class="crop-btn crop-btn-cancel" onclick="cancelarCrop()">Cancelar</button>
                <button class="crop-btn crop-btn-apply" onclick="aplicarCrop()">Aplicar</button>
            </div>
        </div>
        <div class="crop-container" id="cropContainer">
            <canvas id="cropCanvas"></canvas>
            <div class="crop-box" id="cropBox">
                <div class="crop-handle crop-handle-tl" data-handle="tl"></div>
                <div class="crop-handle crop-handle-tr" data-handle="tr"></div>
                <div class="crop-handle crop-handle-bl" data-handle="bl"></div>
                <div class="crop-handle crop-handle-br" data-handle="br"></div>
            </div>
        </div>
        <div class="crop-footer">
            <button class="aspect-btn active" onclick="setCropAspect('free', this)">Libre</button>
            <button class="aspect-btn" onclick="setCropAspect('9:16', this)">9:16</button>
            <button class="aspect-btn" onclick="setCropAspect('1:1', this)">1:1</button>
            <button class="aspect-btn" onclick="setCropAspect('4:5', this)">4:5</button>
            <button class="aspect-btn" onclick="setCropAspect('16:9', this)">16:9</button>
        </div>
    </div>

    <script>
        // ========================================
        // VARIABLES GLOBALES
        // ========================================
        const MODO_EDITOR = '@modo';
        const URL_CREAR = MODO_EDITOR === 'reel' ? '/Stories/CrearReel' : '/Stories/Crear';
        const URL_REDIRECT = MODO_EDITOR === 'reel' ? '/Feed' : '/Feed';

        let canvas;
        let currentTool = 'text';
        let selectedLado = 'LadoA';
        let selectedMusic = null;
        let musicDuration = 0;
        let musicTrimStart = 0;
        let musicVolume = 70;
        let previewAudio = null;
        let listPreviewAudio = null;
        let mediaFile = null;
        let mediaUrl = null;
        let canvasHistory = [];
        let historyIndex = -1;

        // GIFs
        let gifsYaCargados = false;
        let gifSearchTimeout = null;
        let gifsAnimados = []; // Para tracking de GIFs en canvas

        // Efectos de video
        let videoEffects = {
            speed: 'normal',      // normal, slowmo, fast, reverse, boomerang
            style: 'none',        // none, glitch, vhs, retro, cinematic, noir
            intensity: 50         // 0-100
        };

        // Animaciones de texto
        let textAnimation = {
            entrada: 'none',      // none, fade, slide-up, bounce, typewriter, scale
            continuo: 'none'      // none, glow, shadow3d, colorshift, float, shake
        };

        // Configuración de texto
        let textConfig = {
            font: 'Poppins',
            size: 32,
            color: '#ffffff',
            backgroundColor: 'transparent'
        };

        // Configuración de dibujo
        let drawConfig = {
            color: '#ff3b5c',
            width: 3
        };

        // Configuración de link
        let linkConfig = {
            url: '',
            text: 'Ver mas',
            style: 'pill',
            color: '#4682B4',
            font: 'Poppins'
        };
        let storyLinkObject = null; // El objeto fabric del link en canvas

        // Configuración de crop
        let cropConfig = {
            aspectRatio: 'free',
            zoom: 100
        };
        let originalMediaUrl = null;

        // Configuración de fondo
        let backgroundConfig = {
            type: 'none', // none, color, gradient
            value: null,
            blur: 0
        };

        // Plantillas estilo Canva - 70+ plantillas
        const templates = [
            // ============ PROMO (10) ============
            { id: 1, category: 'promo', name: 'Oferta Flash', bg: 'linear-gradient(135deg, #ff0844 0%, #ffb199 100%)', texts: [{ text: 'OFERTA', font: 'Bebas Neue', size: 48, color: '#ffffff', y: 30 }, { text: '50% OFF', font: 'Anton', size: 64, color: '#ffdd00', y: 50 }, { text: 'Solo por hoy', font: 'Poppins', size: 20, color: '#ffffff', y: 70 }] },
            { id: 2, category: 'promo', name: 'Nuevo Producto', bg: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', texts: [{ text: 'NUEVO', font: 'Oswald', size: 36, color: '#ffffff', y: 25 }, { text: 'Descubre', font: 'Playfair Display', size: 42, color: '#ffffff', y: 50 }, { text: 'Disponible ahora', font: 'Poppins', size: 18, color: 'rgba(255,255,255,0.8)', y: 75 }] },
            { id: 3, category: 'promo', name: 'Descuento', bg: 'linear-gradient(180deg, #1a1a2e 0%, #16213e 100%)', texts: [{ text: '-30%', font: 'Anton', size: 72, color: '#e94560', y: 45 }, { text: 'EN TODO', font: 'Montserrat', size: 28, color: '#ffffff', y: 65 }] },
            { id: 4, category: 'promo', name: 'Coming Soon', bg: 'linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 100%)', texts: [{ text: 'COMING', font: 'Bebas Neue', size: 42, color: '#ffffff', y: 38 }, { text: 'SOON', font: 'Bebas Neue', size: 56, color: '#e94560', y: 55 }] },
            { id: 5, category: 'promo', name: 'Lanzamiento', bg: 'linear-gradient(135deg, #f5af19 0%, #f12711 100%)', texts: [{ text: '🚀', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'NUEVO', font: 'Anton', size: 44, color: '#ffffff', y: 45 }, { text: 'LANZAMIENTO', font: 'Anton', size: 36, color: '#ffffff', y: 62 }] },
            { id: 6, category: 'promo', name: 'Exclusivo', bg: 'linear-gradient(135deg, #c9b037 0%, #dcce82 50%, #c9b037 100%)', texts: [{ text: '✦ EXCLUSIVO ✦', font: 'Playfair Display', size: 32, color: '#1a1a1a', y: 45 }, { text: 'Solo para ti', font: 'Poppins', size: 20, color: '#333', y: 60 }] },
            { id: 7, category: 'promo', name: 'Gratis', bg: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)', texts: [{ text: 'GRATIS', font: 'Anton', size: 64, color: '#ffffff', y: 40 }, { text: 'Por tiempo limitado', font: 'Poppins', size: 18, color: '#ffffff', y: 60 }] },
            { id: 8, category: 'promo', name: 'Hot Deal', bg: 'linear-gradient(135deg, #eb3349 0%, #f45c43 100%)', texts: [{ text: '🔥', font: 'Poppins', size: 56, color: '#ffffff', y: 25 }, { text: 'HOT DEAL', font: 'Bebas Neue', size: 52, color: '#ffffff', y: 50 }] },
            { id: 9, category: 'promo', name: 'Limited Edition', bg: '#1a1a1a', texts: [{ text: 'LIMITED', font: 'Oswald', size: 36, color: '#c9b037', y: 38 }, { text: 'EDITION', font: 'Oswald', size: 48, color: '#ffffff', y: 55 }] },
            { id: 10, category: 'promo', name: '2x1', bg: 'linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%)', texts: [{ text: '2x1', font: 'Anton', size: 80, color: '#ffffff', y: 42 }, { text: 'HOY', font: 'Montserrat', size: 28, color: '#ffffff', y: 65 }] },

            // ============ QUOTE / FRASES (12) ============
            { id: 11, category: 'quote', name: 'Cita Inspiradora', bg: 'linear-gradient(135deg, #232526 0%, #414345 100%)', texts: [{ text: '"', font: 'Playfair Display', size: 80, color: 'rgba(255,255,255,0.3)', y: 20 }, { text: 'La vida es bella', font: 'Playfair Display', size: 32, color: '#ffffff', y: 45 }, { text: '- Autor', font: 'Poppins', size: 16, color: 'rgba(255,255,255,0.6)', y: 70 }] },
            { id: 12, category: 'quote', name: 'Motivacional', bg: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', texts: [{ text: 'NUNCA', font: 'Bebas Neue', size: 48, color: '#ffffff', y: 35 }, { text: 'te rindas', font: 'Dancing Script', size: 44, color: '#ffffff', y: 55 }] },
            { id: 13, category: 'quote', name: 'Good Vibes', bg: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)', texts: [{ text: 'good', font: 'Pacifico', size: 42, color: '#5d4e37', y: 40 }, { text: 'vibes only', font: 'Pacifico', size: 36, color: '#5d4e37', y: 58 }] },
            { id: 14, category: 'quote', name: 'Dream Big', bg: 'linear-gradient(135deg, #2c3e50 0%, #4ca1af 100%)', texts: [{ text: 'DREAM', font: 'Bebas Neue', size: 52, color: '#ffffff', y: 38 }, { text: 'BIG', font: 'Bebas Neue', size: 64, color: '#f39c12', y: 58 }] },
            { id: 15, category: 'quote', name: 'Positive', bg: 'linear-gradient(135deg, #74ebd5 0%, #acb6e5 100%)', texts: [{ text: '☀️', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'Piensa', font: 'Dancing Script', size: 36, color: '#2d3436', y: 45 }, { text: 'POSITIVO', font: 'Montserrat', size: 32, color: '#2d3436', y: 62 }] },
            { id: 16, category: 'quote', name: 'Be Yourself', bg: 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%)', texts: [{ text: 'Be', font: 'Pacifico', size: 36, color: '#c0392b', y: 35 }, { text: 'YOURSELF', font: 'Montserrat', size: 40, color: '#2d3436', y: 52 }] },
            { id: 17, category: 'quote', name: 'Love Yourself', bg: 'linear-gradient(135deg, #ee9ca7 0%, #ffdde1 100%)', texts: [{ text: '💕', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'Love', font: 'Dancing Script', size: 44, color: '#c0392b', y: 45 }, { text: 'YOURSELF', font: 'Montserrat', size: 28, color: '#2d3436', y: 62 }] },
            { id: 18, category: 'quote', name: 'Hustle', bg: '#0a0a0a', texts: [{ text: 'HUSTLE', font: 'Anton', size: 52, color: '#ffffff', y: 38 }, { text: 'harder', font: 'Dancing Script', size: 44, color: '#f39c12', y: 58 }] },
            { id: 19, category: 'quote', name: 'Stay Strong', bg: 'linear-gradient(135deg, #434343 0%, #000000 100%)', texts: [{ text: 'STAY', font: 'Bebas Neue', size: 44, color: '#ffffff', y: 35 }, { text: 'STRONG', font: 'Bebas Neue', size: 56, color: '#e74c3c', y: 55 }] },
            { id: 20, category: 'quote', name: 'Make It Happen', bg: 'linear-gradient(135deg, #3a1c71 0%, #d76d77 50%, #ffaf7b 100%)', texts: [{ text: 'MAKE IT', font: 'Oswald', size: 36, color: '#ffffff', y: 38 }, { text: 'HAPPEN', font: 'Anton', size: 52, color: '#ffffff', y: 55 }] },
            { id: 21, category: 'quote', name: 'Blessed', bg: 'linear-gradient(135deg, #c9d6ff 0%, #e2e2e2 100%)', texts: [{ text: '🙏', font: 'Poppins', size: 48, color: '#ffffff', y: 30 }, { text: 'BLESSED', font: 'Playfair Display', size: 44, color: '#2d3436', y: 55 }] },
            { id: 22, category: 'quote', name: 'Keep Going', bg: 'linear-gradient(135deg, #56ab2f 0%, #a8e063 100%)', texts: [{ text: 'KEEP', font: 'Bebas Neue', size: 48, color: '#ffffff', y: 35 }, { text: 'GOING', font: 'Bebas Neue', size: 56, color: '#ffffff', y: 55 }] },

            // ============ SOCIAL (10) ============
            { id: 23, category: 'social', name: 'Pregunta', bg: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)', texts: [{ text: '¿Que opinas?', font: 'Montserrat', size: 36, color: '#ffffff', y: 45 }, { text: 'Responde en DM', font: 'Poppins', size: 18, color: 'rgba(255,255,255,0.8)', y: 65 }] },
            { id: 24, category: 'social', name: 'Encuesta', bg: 'linear-gradient(180deg, #ee0979 0%, #ff6a00 100%)', texts: [{ text: 'ESTO O', font: 'Anton', size: 42, color: '#ffffff', y: 35 }, { text: 'AQUELLO', font: 'Anton', size: 42, color: '#ffffff', y: 55 }] },
            { id: 25, category: 'social', name: 'AMA', bg: 'linear-gradient(135deg, #30cfd0 0%, #330867 100%)', texts: [{ text: 'ASK ME', font: 'Bebas Neue', size: 56, color: '#ffffff', y: 40 }, { text: 'ANYTHING', font: 'Bebas Neue', size: 56, color: '#30cfd0', y: 55 }] },
            { id: 26, category: 'social', name: 'Link Bio', bg: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)', texts: [{ text: 'LINK EN', font: 'Montserrat', size: 28, color: '#ffffff', y: 40 }, { text: 'BIO', font: 'Anton', size: 64, color: '#ffffff', y: 58 }] },
            { id: 27, category: 'social', name: 'New Post', bg: 'linear-gradient(135deg, #f857a6 0%, #ff5858 100%)', texts: [{ text: '📸', font: 'Poppins', size: 48, color: '#ffffff', y: 28 }, { text: 'NEW POST', font: 'Bebas Neue', size: 44, color: '#ffffff', y: 52 }] },
            { id: 28, category: 'social', name: 'DM Me', bg: 'linear-gradient(135deg, #0052d4 0%, #65c7f7 50%, #9cecfb 100%)', texts: [{ text: '💬', font: 'Poppins', size: 48, color: '#ffffff', y: 28 }, { text: 'DM ME', font: 'Anton', size: 52, color: '#ffffff', y: 52 }] },
            { id: 29, category: 'social', name: 'Tag Me', bg: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)', texts: [{ text: '@@', font: 'Anton', size: 64, color: '#ffffff', y: 35 }, { text: 'TAG ME', font: 'Montserrat', size: 32, color: '#ffffff', y: 58 }] },
            { id: 30, category: 'social', name: 'Follow', bg: 'linear-gradient(135deg, #e1eec3 0%, #f05053 100%)', texts: [{ text: '👆', font: 'Poppins', size: 48, color: '#ffffff', y: 28 }, { text: 'FOLLOW', font: 'Anton', size: 48, color: '#ffffff', y: 52 }] },
            { id: 31, category: 'social', name: 'Rate This', bg: 'linear-gradient(135deg, #ff9966 0%, #ff5e62 100%)', texts: [{ text: '⭐⭐⭐⭐⭐', font: 'Poppins', size: 24, color: '#ffffff', y: 35 }, { text: 'RATE THIS', font: 'Bebas Neue', size: 44, color: '#ffffff', y: 55 }] },
            { id: 32, category: 'social', name: 'Giveaway', bg: 'linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%)', texts: [{ text: '🎁', font: 'Poppins', size: 56, color: '#ffffff', y: 25 }, { text: 'GIVEAWAY', font: 'Anton', size: 44, color: '#ffffff', y: 52 }, { text: 'Participa ahora', font: 'Poppins', size: 16, color: '#ffffff', y: 70 }] },

            // ============ NEON (8) ============
            { id: 33, category: 'neon', name: 'Neon Pink', bg: '#0a0a0a', texts: [{ text: 'VIBES', font: 'Bebas Neue', size: 56, color: '#ff00ff', y: 45, shadow: '0 0 20px #ff00ff, 0 0 40px #ff00ff' }] },
            { id: 34, category: 'neon', name: 'Neon Blue', bg: '#0a0a0a', texts: [{ text: 'GLOW', font: 'Anton', size: 64, color: '#00ffff', y: 45, shadow: '0 0 20px #00ffff, 0 0 40px #00ffff' }] },
            { id: 35, category: 'neon', name: 'Neon Multi', bg: 'linear-gradient(180deg, #0a0a0a 0%, #1a0a2e 100%)', texts: [{ text: 'NEON', font: 'Bebas Neue', size: 48, color: '#ff00ff', y: 35, shadow: '0 0 15px #ff00ff' }, { text: 'NIGHTS', font: 'Bebas Neue', size: 48, color: '#00ffff', y: 55, shadow: '0 0 15px #00ffff' }] },
            { id: 36, category: 'neon', name: 'Neon Green', bg: '#0a0a0a', texts: [{ text: 'FRESH', font: 'Anton', size: 56, color: '#39ff14', y: 45, shadow: '0 0 20px #39ff14, 0 0 40px #39ff14' }] },
            { id: 37, category: 'neon', name: 'Neon Orange', bg: '#0a0a0a', texts: [{ text: 'FIRE', font: 'Bebas Neue', size: 64, color: '#ff6600', y: 45, shadow: '0 0 20px #ff6600, 0 0 40px #ff6600' }] },
            { id: 38, category: 'neon', name: 'Electric', bg: 'linear-gradient(180deg, #0f0c29 0%, #302b63 50%, #24243e 100%)', texts: [{ text: '⚡', font: 'Poppins', size: 48, color: '#ffff00', y: 28, shadow: '0 0 20px #ffff00' }, { text: 'ELECTRIC', font: 'Anton', size: 44, color: '#ffff00', y: 55, shadow: '0 0 15px #ffff00' }] },
            { id: 39, category: 'neon', name: 'Retro Wave', bg: 'linear-gradient(180deg, #0a0a0a 0%, #1a0a2e 100%)', texts: [{ text: 'RETRO', font: 'Bebas Neue', size: 44, color: '#ff00ff', y: 35, shadow: '0 0 15px #ff00ff' }, { text: 'WAVE', font: 'Bebas Neue', size: 44, color: '#00ffff', y: 52, shadow: '0 0 15px #00ffff' }, { text: '1985', font: 'Oswald', size: 24, color: '#ffff00', y: 68, shadow: '0 0 10px #ffff00' }] },
            { id: 40, category: 'neon', name: 'Cyber', bg: '#0a0a0a', texts: [{ text: 'CYBER', font: 'Anton', size: 52, color: '#ff00ff', y: 38, shadow: '0 0 20px #ff00ff' }, { text: 'PUNK', font: 'Anton', size: 52, color: '#00ffff', y: 58, shadow: '0 0 20px #00ffff' }] },

            // ============ MINIMAL (8) ============
            { id: 41, category: 'minimal', name: 'Clean White', bg: '#ffffff', texts: [{ text: 'SIMPLE', font: 'Montserrat', size: 32, color: '#000000', y: 45 }, { text: 'is better', font: 'Poppins', size: 20, color: '#666666', y: 58 }] },
            { id: 42, category: 'minimal', name: 'Dark Minimal', bg: '#1a1a1a', texts: [{ text: 'MENOS', font: 'Oswald', size: 36, color: '#ffffff', y: 42 }, { text: 'es mas', font: 'Poppins', size: 22, color: '#888888', y: 56 }] },
            { id: 43, category: 'minimal', name: 'Lineas', bg: '#f5f5f5', texts: [{ text: '___', font: 'Poppins', size: 24, color: '#333', y: 35 }, { text: 'Tu texto', font: 'Poppins', size: 20, color: '#333', y: 50 }, { text: '___', font: 'Poppins', size: 24, color: '#333', y: 65 }] },
            { id: 44, category: 'minimal', name: 'Beige', bg: '#f5f0e8', texts: [{ text: 'ELEGANT', font: 'Playfair Display', size: 36, color: '#5d4e37', y: 45 }, { text: '& simple', font: 'Poppins', size: 18, color: '#8b7355', y: 60 }] },
            { id: 45, category: 'minimal', name: 'B&W', bg: '#ffffff', texts: [{ text: '●', font: 'Poppins', size: 32, color: '#000000', y: 35 }, { text: 'BLACK', font: 'Montserrat', size: 28, color: '#000000', y: 50 }, { text: '& WHITE', font: 'Poppins', size: 20, color: '#666', y: 62 }] },
            { id: 46, category: 'minimal', name: 'Grid', bg: '#f8f8f8', texts: [{ text: '+', font: 'Montserrat', size: 48, color: '#e0e0e0', y: 30 }, { text: 'MINIMAL', font: 'Oswald', size: 32, color: '#333', y: 50 }] },
            { id: 47, category: 'minimal', name: 'Soft Gray', bg: '#e8e8e8', texts: [{ text: 'Breathe', font: 'Dancing Script', size: 44, color: '#555', y: 45 }] },
            { id: 48, category: 'minimal', name: 'Pure', bg: '#ffffff', texts: [{ text: '○', font: 'Poppins', size: 64, color: '#ddd', y: 35 }, { text: 'PURE', font: 'Montserrat', size: 36, color: '#333', y: 60 }] },

            // ============ BIRTHDAY (10) ============
            { id: 49, category: 'birthday', name: 'Feliz Cumple', bg: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)', texts: [{ text: '🎂', font: 'Poppins', size: 64, color: '#ffffff', y: 25 }, { text: 'FELIZ', font: 'Bebas Neue', size: 48, color: '#ffffff', y: 50 }, { text: 'CUMPLEAÑOS', font: 'Bebas Neue', size: 36, color: '#ffffff', y: 65 }] },
            { id: 50, category: 'birthday', name: 'Party Time', bg: 'linear-gradient(135deg, #7f00ff 0%, #e100ff 100%)', texts: [{ text: '🎉', font: 'Poppins', size: 48, color: '#ffffff', y: 20 }, { text: 'PARTY', font: 'Anton', size: 56, color: '#ffffff', y: 45 }, { text: 'TIME', font: 'Anton', size: 56, color: '#ffdd00', y: 62 }] },
            { id: 51, category: 'birthday', name: 'Celebremos', bg: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)', texts: [{ text: '✨', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'Celebremos', font: 'Dancing Script', size: 44, color: '#ffffff', y: 48 }, { text: 'JUNTOS', font: 'Montserrat', size: 28, color: '#ffffff', y: 68 }] },
            { id: 52, category: 'birthday', name: 'Happy Bday', bg: 'linear-gradient(135deg, #f6d365 0%, #fda085 100%)', texts: [{ text: '🎈', font: 'Poppins', size: 48, color: '#ffffff', y: 22 }, { text: 'HAPPY', font: 'Anton', size: 44, color: '#ffffff', y: 45 }, { text: 'BIRTHDAY', font: 'Anton', size: 36, color: '#ffffff', y: 62 }] },
            { id: 53, category: 'birthday', name: 'Wishes', bg: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)', texts: [{ text: '🎁', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'Best', font: 'Dancing Script', size: 36, color: '#5d4e37', y: 45 }, { text: 'WISHES', font: 'Montserrat', size: 32, color: '#5d4e37', y: 62 }] },
            { id: 54, category: 'birthday', name: 'Surprise', bg: 'linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%)', texts: [{ text: '🎊', font: 'Poppins', size: 56, color: '#ffffff', y: 25 }, { text: 'SURPRISE', font: 'Bebas Neue', size: 48, color: '#c0392b', y: 52 }] },
            { id: 55, category: 'birthday', name: 'Its My Bday', bg: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', texts: [{ text: '👑', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'ITS MY', font: 'Montserrat', size: 28, color: '#ffffff', y: 45 }, { text: 'BIRTHDAY', font: 'Anton', size: 44, color: '#ffdd00', y: 62 }] },
            { id: 56, category: 'birthday', name: 'Cheers', bg: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', texts: [{ text: '🥳', font: 'Poppins', size: 56, color: '#ffffff', y: 28 }, { text: 'CHEERS', font: 'Bebas Neue', size: 48, color: '#ffffff', y: 55 }] },
            { id: 57, category: 'birthday', name: 'Make a Wish', bg: 'linear-gradient(135deg, #0c3483 0%, #a2b6df 100%)', texts: [{ text: '🌟', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'Make a', font: 'Dancing Script', size: 32, color: '#ffffff', y: 45 }, { text: 'WISH', font: 'Anton', size: 52, color: '#ffffff', y: 62 }] },
            { id: 58, category: 'birthday', name: 'Age Up', bg: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)', texts: [{ text: '🎂', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'LEVEL UP', font: 'Anton', size: 44, color: '#ffffff', y: 50 }, { text: '+1 Year', font: 'Poppins', size: 20, color: '#ffffff', y: 68 }] },

            // ============ SALE (10) ============
            { id: 59, category: 'sale', name: 'Black Friday', bg: '#000000', texts: [{ text: 'BLACK', font: 'Anton', size: 48, color: '#ffffff', y: 35 }, { text: 'FRIDAY', font: 'Anton', size: 48, color: '#ff0000', y: 52 }, { text: 'Hasta 70% OFF', font: 'Poppins', size: 18, color: '#ffffff', y: 72 }] },
            { id: 60, category: 'sale', name: 'Flash Sale', bg: 'linear-gradient(135deg, #f12711 0%, #f5af19 100%)', texts: [{ text: '⚡', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'FLASH SALE', font: 'Bebas Neue', size: 44, color: '#ffffff', y: 50 }, { text: '24 HORAS', font: 'Montserrat', size: 22, color: '#ffffff', y: 68 }] },
            { id: 61, category: 'sale', name: 'Liquidacion', bg: 'linear-gradient(180deg, #2c3e50 0%, #3498db 100%)', texts: [{ text: 'LIQUIDACION', font: 'Oswald', size: 36, color: '#ffffff', y: 35 }, { text: 'TOTAL', font: 'Oswald', size: 48, color: '#ffdd00', y: 52 }, { text: 'Ultimas unidades', font: 'Poppins', size: 16, color: 'rgba(255,255,255,0.8)', y: 72 }] },
            { id: 62, category: 'sale', name: 'Cyber Monday', bg: 'linear-gradient(135deg, #0052d4 0%, #4364f7 50%, #6fb1fc 100%)', texts: [{ text: 'CYBER', font: 'Anton', size: 44, color: '#ffffff', y: 35 }, { text: 'MONDAY', font: 'Anton', size: 44, color: '#00ff88', y: 52 }] },
            { id: 63, category: 'sale', name: 'Super Oferta', bg: 'linear-gradient(135deg, #eb3349 0%, #f45c43 100%)', texts: [{ text: '🔥', font: 'Poppins', size: 48, color: '#ffffff', y: 22 }, { text: 'SUPER', font: 'Bebas Neue', size: 44, color: '#ffffff', y: 42 }, { text: 'OFERTA', font: 'Bebas Neue', size: 52, color: '#ffdd00', y: 60 }] },
            { id: 64, category: 'sale', name: 'Mega Sale', bg: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)', texts: [{ text: 'MEGA', font: 'Anton', size: 52, color: '#ffffff', y: 38 }, { text: 'SALE', font: 'Anton', size: 64, color: '#ffdd00', y: 58 }] },
            { id: 65, category: 'sale', name: 'Last Chance', bg: 'linear-gradient(135deg, #200122 0%, #6f0000 100%)', texts: [{ text: '⏰', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'LAST', font: 'Bebas Neue', size: 44, color: '#ffffff', y: 45 }, { text: 'CHANCE', font: 'Bebas Neue', size: 48, color: '#ff0000', y: 62 }] },
            { id: 66, category: 'sale', name: 'Hot Price', bg: 'linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%)', texts: [{ text: 'HOT', font: 'Anton', size: 56, color: '#ffffff', y: 35 }, { text: 'PRICE', font: 'Anton', size: 56, color: '#ffdd00', y: 55 }] },
            { id: 67, category: 'sale', name: 'Rebajas', bg: 'linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%)', texts: [{ text: 'REBAJAS', font: 'Bebas Neue', size: 52, color: '#ffffff', y: 40 }, { text: 'Hasta -60%', font: 'Montserrat', size: 24, color: '#ffffff', y: 60 }] },
            { id: 68, category: 'sale', name: 'Outlet', bg: '#1a1a1a', texts: [{ text: 'OUTLET', font: 'Anton', size: 52, color: '#ffffff', y: 40 }, { text: '-70% OFF', font: 'Montserrat', size: 28, color: '#ff0000', y: 60 }] },

            // ============ EXTRAS / BONUS (12) ============
            { id: 69, category: 'promo', name: 'Save Date', bg: 'linear-gradient(135deg, #c9b037 0%, #dcce82 50%, #c9b037 100%)', texts: [{ text: 'SAVE', font: 'Playfair Display', size: 36, color: '#1a1a1a', y: 35 }, { text: 'THE DATE', font: 'Playfair Display', size: 32, color: '#1a1a1a', y: 52 }] },
            { id: 70, category: 'social', name: 'POV', bg: 'linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%)', texts: [{ text: 'POV:', font: 'Montserrat', size: 28, color: '#ffffff', y: 40 }, { text: 'Tu texto', font: 'Poppins', size: 22, color: 'rgba(255,255,255,0.8)', y: 55 }] },
            { id: 71, category: 'quote', name: 'Mood', bg: 'linear-gradient(135deg, #654ea3 0%, #eaafc8 100%)', texts: [{ text: 'mood:', font: 'Montserrat', size: 24, color: '#ffffff', y: 40 }, { text: '💭', font: 'Poppins', size: 48, color: '#ffffff', y: 58 }] },
            { id: 72, category: 'social', name: 'Swipe Up', bg: 'linear-gradient(135deg, #00b09b 0%, #96c93d 100%)', texts: [{ text: '👆', font: 'Poppins', size: 48, color: '#ffffff', y: 30 }, { text: 'SWIPE UP', font: 'Bebas Neue', size: 44, color: '#ffffff', y: 55 }] },
            { id: 73, category: 'neon', name: 'Vaporwave', bg: 'linear-gradient(180deg, #0a0a0a 0%, #240046 50%, #3c096c 100%)', texts: [{ text: 'VAPOR', font: 'Bebas Neue', size: 44, color: '#ff00ff', y: 35, shadow: '0 0 15px #ff00ff' }, { text: 'WAVE', font: 'Bebas Neue', size: 44, color: '#00ffff', y: 52, shadow: '0 0 15px #00ffff' }, { text: '美学', font: 'Poppins', size: 24, color: '#ff00ff', y: 68 }] },
            { id: 74, category: 'minimal', name: 'Aesthetic', bg: '#f5f0e8', texts: [{ text: 'a e s t h e t i c', font: 'Montserrat', size: 20, color: '#8b7355', y: 45 }] },
            { id: 75, category: 'quote', name: 'Weekend', bg: 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%)', texts: [{ text: '🌴', font: 'Poppins', size: 48, color: '#ffffff', y: 25 }, { text: 'WEEKEND', font: 'Bebas Neue', size: 44, color: '#c0392b', y: 48 }, { text: 'vibes', font: 'Dancing Script', size: 32, color: '#5d4e37', y: 65 }] },
            { id: 76, category: 'promo', name: 'Disponible', bg: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)', texts: [{ text: '✓', font: 'Poppins', size: 56, color: '#ffffff', y: 30 }, { text: 'DISPONIBLE', font: 'Montserrat', size: 32, color: '#ffffff', y: 55 }] },
            { id: 77, category: 'social', name: 'Collab', bg: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', texts: [{ text: '🤝', font: 'Poppins', size: 48, color: '#ffffff', y: 28 }, { text: 'COLLAB', font: 'Anton', size: 48, color: '#ffffff', y: 52 }] },
            { id: 78, category: 'quote', name: 'Thank You', bg: 'linear-gradient(135deg, #ee9ca7 0%, #ffdde1 100%)', texts: [{ text: '💖', font: 'Poppins', size: 48, color: '#ffffff', y: 28 }, { text: 'THANK', font: 'Playfair Display', size: 36, color: '#c0392b', y: 48 }, { text: 'YOU', font: 'Playfair Display', size: 36, color: '#c0392b', y: 65 }] },
            { id: 79, category: 'birthday', name: 'Confetti', bg: 'linear-gradient(135deg, #f6d365 0%, #fda085 100%)', texts: [{ text: '🎊🎉🎊', font: 'Poppins', size: 32, color: '#ffffff', y: 28 }, { text: 'PARTY', font: 'Anton', size: 52, color: '#ffffff', y: 52 }] },
            { id: 80, category: 'sale', name: 'Final Sale', bg: '#1a1a1a', texts: [{ text: 'FINAL', font: 'Bebas Neue', size: 48, color: '#ffffff', y: 35 }, { text: 'SALE', font: 'Bebas Neue', size: 64, color: '#ff0000', y: 55 }] },
        ];

        // Emojis populares
        const emojis = [
            '😀', '😍', '🥳', '😎', '🤩', '😂', '🥰', '😘', '🤗', '🙌',
            '❤️', '🔥', '✨', '💯', '🎉', '🎊', '💪', '👏', '🙏', '💕',
            '🌟', '⭐', '💫', '🌈', '☀️', '🌙', '💖', '💝', '💗', '💓',
            '👑', '🦋', '🌸', '🌺', '🌻', '🍀', '🎵', '🎶', '🎤', '🎧',
            '📸', '🎬', '🎨', '✌️', '🤟', '👍', '💋', '👀', '💅', '💄'
        ];

        // ========================================
        // INICIALIZACIÓN
        // ========================================

        // iOS Audio Unlock - Desbloquear audio en primer toque
        let audioUnlocked = false;
        let globalAudioContext = null;

        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }

        function unlockAudioForIOS() {
            if (audioUnlocked) return;

            try {
                // Crear AudioContext global si no existe
                if (!globalAudioContext) {
                    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Resumir si está suspendido
                if (globalAudioContext.state === 'suspended') {
                    globalAudioContext.resume();
                }

                // Crear y reproducir un buffer silencioso para desbloquear
                const buffer = globalAudioContext.createBuffer(1, 1, 22050);
                const source = globalAudioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(globalAudioContext.destination);
                source.start(0);

                // También desbloquear HTMLAudioElement
                const silentAudio = new Audio();
                silentAudio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
                silentAudio.volume = 0;
                silentAudio.play().catch(() => {});

                audioUnlocked = true;
                console.log('Audio desbloqueado para iOS');

                // Remover listeners después de desbloquear
                document.removeEventListener('touchstart', unlockAudioForIOS);
                document.removeEventListener('touchend', unlockAudioForIOS);
                document.removeEventListener('click', unlockAudioForIOS);
            } catch (e) {
                console.log('Error desbloqueando audio:', e);
            }
        }

        // Agregar listeners para desbloquear audio en iOS
        if (isIOS()) {
            document.addEventListener('touchstart', unlockAudioForIOS, { once: false, passive: true });
            document.addEventListener('touchend', unlockAudioForIOS, { once: false, passive: true });
            document.addEventListener('click', unlockAudioForIOS, { once: false, passive: true });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Reaplicar tema al cargar el DOM (por si acaso)
            var savedTheme = ThemeStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            document.body.classList.remove('theme-light', 'theme-dark');
            document.body.classList.add('theme-' + savedTheme);

            initCanvas();
            initEmojis();

            // También intentar desbloquear audio en el primer click general (para iOS)
            if (isIOS()) {
                document.body.addEventListener('click', unlockAudioForIOS, { once: true });
            }
        });

        function initCanvas() {
            try {
                const wrapper = document.getElementById('canvasWrapper');
                if (!wrapper) {
                    throw new Error('Canvas wrapper element not found');
                }
                const width = wrapper.clientWidth || 380;
                const height = wrapper.clientHeight || 675;

                EditorLog.canvas('info', 'Inicializando canvas', { width, height });

                canvas = new fabric.Canvas('storyCanvas', {
                    width: width,
                    height: height,
                    backgroundColor: '#000',
                    selection: true,
                    preserveObjectStacking: true,
                    allowTouchScrolling: false,
                    stopContextMenu: true,
                    fireRightClick: true
                });

                if (!canvas) {
                    throw new Error('Failed to create Fabric.js canvas');
                }

                // Inicializar brush de dibujo
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.color = drawConfig.color;
                canvas.freeDrawingBrush.width = drawConfig.width;
                canvas.freeDrawingBrush.decimate = 5;

                // Guardar estado inicial
                saveHistory();

                // Eventos de selección
                canvas.on('selection:created', onObjectSelected);
                canvas.on('selection:updated', onObjectSelected);
                canvas.on('selection:cleared', onSelectionCleared);

                EditorLog.canvas('info', 'Canvas inicializado correctamente');
            } catch (error) {
                EditorLog.canvas('error', 'Error inicializando canvas', {
                    error: error.message,
                    stack: error.stack
                });
                console.error('Error initCanvas:', error);
                alert('Error al inicializar el editor. Por favor recarga la página.');
            }
        }

        function initEmojis() {
            const grid = document.getElementById('emojiGrid');
            emojis.forEach(emoji => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.textContent = emoji;
                item.onclick = () => agregarSticker(emoji);
                grid.appendChild(item);
            });
        }

        // ========================================
        // GIFs ANIMADOS - Funciones
        // ========================================

        // Buscar GIFs con debounce
        function buscarGifsDebounced(query) {
            if (gifSearchTimeout) {
                clearTimeout(gifSearchTimeout);
            }
            gifSearchTimeout = setTimeout(() => {
                buscarGifs(query);
            }, 400);
        }

        // Buscar GIFs en el servidor
        async function buscarGifs(query) {
            const grid = document.getElementById('gifGrid');
            grid.innerHTML = `
                <div class="gif-loading">
                    <div class="loading-spinner"></div>
                    <span>Buscando GIFs...</span>
                </div>
            `;

            try {
                const url = query && query.trim()
                    ? `/Stories/BuscarGifs?q=${encodeURIComponent(query.trim())}&limit=24`
                    : `/Stories/GifsTrending?limit=24`;

                const response = await fetch(url);
                const data = await response.json();

                if (data.success && data.gifs && data.gifs.length > 0) {
                    renderizarGifs(data.gifs);
                } else {
                    grid.innerHTML = `
                        <div class="gif-no-results">
                            <p>No se encontraron GIFs</p>
                            <small>Intenta con otra búsqueda</small>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error buscando GIFs:', error);
                grid.innerHTML = `
                    <div class="gif-no-results">
                        <p>Error al cargar GIFs</p>
                        <small>Intenta de nuevo</small>
                    </div>
                `;
            }
        }

        // Cargar GIFs por categoría
        async function cargarGifsCategoria(categoria, btnElement = null) {
            // Actualizar botones activos
            if (btnElement) {
                document.querySelectorAll('.gif-category-btn').forEach(btn => btn.classList.remove('active'));
                btnElement.classList.add('active');
            }

            // Limpiar búsqueda
            const searchInput = document.getElementById('gifSearchInput');
            if (searchInput) searchInput.value = '';

            const grid = document.getElementById('gifGrid');
            grid.innerHTML = `
                <div class="gif-loading">
                    <div class="loading-spinner"></div>
                    <span>Cargando ${categoria}...</span>
                </div>
            `;

            try {
                EditorLog.gif('info', 'Cargando GIFs por categoría', { categoria });
                const response = await fetch(`/Stories/GifsCategoria/${encodeURIComponent(categoria)}?limit=24`);
                const data = await response.json();

                if (data.success && data.gifs && data.gifs.length > 0) {
                    renderizarGifs(data.gifs);
                    EditorLog.gif('info', 'GIFs cargados', { categoria, count: data.gifs.length });
                } else {
                    EditorLog.gif('warning', 'No hay GIFs en categoría', { categoria });
                    grid.innerHTML = `
                        <div class="gif-no-results">
                            <p>No hay GIFs en esta categoría</p>
                        </div>
                    `;
                }
            } catch (error) {
                EditorLog.gif('error', 'Error cargando GIFs por categoría', {
                    categoria,
                    error: error.message
                });
                grid.innerHTML = `
                    <div class="gif-no-results">
                        <p>Error al cargar GIFs</p>
                    </div>
                `;
            }
        }

        // Renderizar GIFs en el grid
        function renderizarGifs(gifs) {
            const grid = document.getElementById('gifGrid');
            grid.innerHTML = '';

            gifs.forEach(gif => {
                const item = document.createElement('div');
                item.className = 'gif-item';
                item.onclick = () => agregarGifAlCanvas(gif);

                const img = document.createElement('img');
                img.src = gif.previewUrl || gif.url;
                img.alt = gif.title || 'GIF';
                img.loading = 'lazy';

                // Manejar errores de carga de imagen
                img.onerror = () => {
                    // Si falla el preview, intentar con la URL principal
                    if (img.src === gif.previewUrl && gif.url) {
                        img.src = gif.url;
                    } else {
                        // Mostrar placeholder si ambas fallan
                        item.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;width:100%;height:100%;color:#666;font-size:12px;">GIF no disponible</div>';
                    }
                };

                // Al hacer hover, cargar el GIF completo
                item.onmouseenter = () => {
                    if (gif.url && gif.url !== gif.previewUrl) {
                        img.src = gif.url;
                    }
                };
                item.onmouseleave = () => {
                    if (gif.previewUrl) {
                        img.src = gif.previewUrl;
                    }
                };

                item.appendChild(img);
                grid.appendChild(item);
            });
        }

        // Agregar GIF al canvas como imagen animada
        async function agregarGifAlCanvas(gif) {
            try {
                if (!gif || !gif.url) {
                    EditorLog.gif('error', 'GIF inválido', { gif });
                    alert('El GIF seleccionado no es válido.');
                    return;
                }

                EditorLog.gif('info', 'Cargando GIF', { id: gif.id, title: gif.title });

                // Cargar el GIF como imagen
                const img = new Image();
                img.crossOrigin = 'anonymous';

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = (e) => {
                        EditorLog.gif('error', 'Error cargando imagen GIF', { url: gif.url });
                        reject(new Error('No se pudo cargar el GIF. El archivo puede no estar disponible.'));
                    };
                    img.src = gif.url;
                });

                // Verificar que la imagen se cargó correctamente
                if (!img.width || !img.height) {
                    throw new Error('La imagen del GIF no tiene dimensiones válidas.');
                }

                // Crear objeto de imagen en Fabric.js
                const fabricImg = new fabric.Image(img, {
                    left: canvas.width / 2,
                    top: canvas.height / 2,
                    originX: 'center',
                    originY: 'center',
                    scaleX: Math.min(1, canvas.width * 0.4 / img.width),
                    scaleY: Math.min(1, canvas.width * 0.4 / img.width),
                    hasControls: true,
                    hasBorders: true,
                    selectable: true,
                    // Metadata para identificar como GIF
                    isGif: true,
                    gifUrl: gif.url,
                    gifId: gif.id
                });

                canvas.add(fabricImg);
                canvas.setActiveObject(fabricImg);
                canvas.renderAll();

                // Guardar referencia para animación durante la exportación
                gifsAnimados.push({
                    fabricObj: fabricImg,
                    url: gif.url,
                    id: gif.id
                });

                EditorLog.gif('info', 'GIF agregado al canvas', {
                    id: gif.id,
                    title: gif.title,
                    size: `${img.width}x${img.height}`
                });
            } catch (error) {
                EditorLog.gif('error', 'Error agregando GIF al canvas', {
                    error: error.message,
                    gifId: gif?.id
                });
                alert(error.message || 'Error al agregar el GIF. Intenta con otro.');
            }
        }

        // ========================================
        // EFECTOS DE VIDEO - Funciones
        // ========================================

        // Aplicar efecto de velocidad
        function aplicarEfectoVideo(efecto, btnElement) {
            try {
                // Actualizar estado
                videoEffects.speed = efecto;

                // Actualizar UI - marcar botón activo
                document.querySelectorAll('#effectsOptions .effects-grid:first-child .effect-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (btnElement) btnElement.classList.add('active');

                // Obtener el video de fondo
                const video = document.querySelector('#mediaPreview video');
                if (!video) {
                    EditorLog.efectos('info', 'No hay video para aplicar efecto de velocidad', { efecto });
                    return;
                }

                // Aplicar efecto según tipo
                switch (efecto) {
                    case 'normal':
                        video.playbackRate = 1.0;
                        video.style.transform = '';
                        break;
                    case 'slowmo':
                        video.playbackRate = 0.5;
                        break;
                    case 'fast':
                        video.playbackRate = 2.0;
                        break;
                    case 'reverse':
                        // Reverse requiere manipulación especial
                        // Por ahora, solo marcamos que se aplicará en backend
                        video.playbackRate = 1.0;
                        break;
                    case 'boomerang':
                        // Boomerang también se aplica en backend
                        video.playbackRate = 1.0;
                        break;
                }

                EditorLog.efectos('info', 'Efecto de velocidad aplicado', { efecto, playbackRate: video.playbackRate });
            } catch (error) {
                EditorLog.efectos('error', 'Error aplicando efecto de velocidad', {
                    efecto,
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        // Aplicar estilo visual
        function aplicarEstiloVideo(estilo, btnElement) {
            try {
                // Actualizar estado
                videoEffects.style = estilo;

                // Actualizar UI - marcar botón activo
                document.querySelectorAll('#effectsOptions .effects-grid:last-of-type .effect-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (btnElement) btnElement.classList.add('active');

                // Mostrar/ocultar slider de intensidad
                const intensityGroup = document.getElementById('effectIntensityGroup');
                if (estilo !== 'none') {
                    intensityGroup.style.display = 'block';
                } else {
                    intensityGroup.style.display = 'none';
                }

                // Aplicar estilo al preview
                aplicarEstiloAlPreview(estilo);

                EditorLog.efectos('info', 'Estilo visual aplicado', { estilo });
            } catch (error) {
                EditorLog.efectos('error', 'Error aplicando estilo visual', {
                    estilo,
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        // Aplicar estilo CSS al preview
        function aplicarEstiloAlPreview(estilo) {
            try {
                const mediaPreview = document.getElementById('mediaPreview');
                const canvasContainer = document.querySelector('.canvas-container');

                // Remover clases de efectos anteriores
                const effectClasses = ['video-effect-glitch', 'video-effect-vhs', 'video-effect-retro', 'video-effect-cinematic', 'video-effect-noir'];
                effectClasses.forEach(cls => {
                    mediaPreview?.classList.remove(cls);
                    canvasContainer?.classList.remove(cls);
                });

                // Aplicar nuevo efecto
                if (estilo !== 'none') {
                    const effectClass = `video-effect-${estilo}`;
                    mediaPreview?.classList.add(effectClass);
                    // También al canvas para que se vea el efecto
                    canvasContainer?.classList.add(effectClass);
                }
            } catch (error) {
                EditorLog.efectos('error', 'Error aplicando estilo al preview', {
                    estilo,
                    error: error.message
                });
            }
        }

        // Ajustar intensidad del efecto
        function ajustarIntensidadEfecto(valor) {
            videoEffects.intensity = parseInt(valor);
            document.getElementById('effectIntensityValue').textContent = valor + '%';

            // La intensidad se aplicará en el render final con FFmpeg
            // Para preview, podemos ajustar la opacidad del efecto
            const intensity = valor / 100;

            // Ajustar CSS filter si hay estilo aplicado
            const mediaPreview = document.getElementById('mediaPreview');
            if (mediaPreview && videoEffects.style !== 'none') {
                // Mezclar efecto con la intensidad
                switch (videoEffects.style) {
                    case 'retro':
                        mediaPreview.style.filter = `sepia(${40 * intensity}%) saturate(${100 - 20 * intensity}%) brightness(${100 + 10 * intensity}%)`;
                        break;
                    case 'noir':
                        mediaPreview.style.filter = `grayscale(${100 * intensity}%) contrast(${100 + 20 * intensity}%)`;
                        break;
                    case 'cinematic':
                        mediaPreview.style.filter = `contrast(${100 + 10 * intensity}%) saturate(${100 - 10 * intensity}%)`;
                        break;
                    case 'vhs':
                        mediaPreview.style.filter = `saturate(${100 + 20 * intensity}%) contrast(${100 + 10 * intensity}%)`;
                        break;
                }
            }
        }

        // Obtener parámetros de efectos para el backend
        function obtenerParametrosEfectos() {
            return {
                speed: videoEffects.speed,
                style: videoEffects.style,
                intensity: videoEffects.intensity
            };
        }

        // ========================================
        // ANIMACIONES DE TEXTO - Funciones
        // ========================================

        // Seleccionar animación de entrada
        function seleccionarAnimacionEntrada(animacion, btnElement) {
            textAnimation.entrada = animacion;

            // Actualizar UI
            document.querySelectorAll('.text-animation-grid .text-anim-btn[data-anim]').forEach(btn => {
                btn.classList.remove('active');
            });
            if (btnElement) btnElement.classList.add('active');

            // Si hay un texto seleccionado, actualizar su animación
            const activeObject = canvas.getActiveObject();
            if (activeObject && activeObject.type === 'textbox') {
                activeObject.set('animacionEntrada', animacion);
                canvas.renderAll();
            }

            console.log('Animación de entrada seleccionada:', animacion);
        }

        // Seleccionar efecto continuo
        function seleccionarEfectoContinuo(efecto, btnElement) {
            textAnimation.continuo = efecto;

            // Actualizar UI
            document.querySelectorAll('.text-animation-grid .text-anim-btn[data-effect]').forEach(btn => {
                btn.classList.remove('active');
            });
            if (btnElement) btnElement.classList.add('active');

            // Si hay un texto seleccionado, actualizar su efecto
            const activeObject = canvas.getActiveObject();
            if (activeObject && activeObject.type === 'textbox') {
                activeObject.set('efectoContinuo', efecto);

                // Aplicar efecto visual de preview
                aplicarEfectoTextoPreview(activeObject, efecto);
            }

            console.log('Efecto continuo seleccionado:', efecto);
        }

        // Aplicar efecto visual de preview al texto en canvas
        function aplicarEfectoTextoPreview(textObj, efecto) {
            // Resetear efectos
            textObj.set({
                shadow: null
            });

            switch (efecto) {
                case 'glow':
                    textObj.set({
                        shadow: new fabric.Shadow({
                            color: textObj.fill || '#ffffff',
                            blur: 15,
                            offsetX: 0,
                            offsetY: 0
                        })
                    });
                    break;
                case 'shadow3d':
                    textObj.set({
                        shadow: new fabric.Shadow({
                            color: 'rgba(0,0,0,0.5)',
                            blur: 0,
                            offsetX: 4,
                            offsetY: 4
                        })
                    });
                    break;
                case 'colorshift':
                case 'float':
                case 'shake':
                    // Estos efectos se aplican durante el render, no en el canvas estático
                    break;
            }

            canvas.renderAll();
        }

        // Obtener parámetros de animación de texto
        function obtenerParametrosAnimacionTexto() {
            return {
                entrada: textAnimation.entrada,
                continuo: textAnimation.continuo
            };
        }

        // Resetear selección de animación (cuando se deselecciona texto)
        function resetearAnimacionTexto() {
            textAnimation.entrada = 'none';
            textAnimation.continuo = 'none';

            // Resetear UI
            document.querySelectorAll('.text-animation-grid .text-anim-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('.text-anim-btn[data-anim="none"]')?.classList.add('active');
            document.querySelector('.text-anim-btn[data-effect="none"]')?.classList.add('active');
        }

        // Cargar animación del texto seleccionado
        function cargarAnimacionTextoSeleccionado(textObj) {
            const entrada = textObj.animacionEntrada || 'none';
            const continuo = textObj.efectoContinuo || 'none';

            textAnimation.entrada = entrada;
            textAnimation.continuo = continuo;

            // Actualizar UI
            document.querySelectorAll('.text-anim-btn[data-anim]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.anim === entrada);
            });
            document.querySelectorAll('.text-anim-btn[data-effect]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.effect === continuo);
            });
        }

        // ========================================
        // HEIC/HEIF Support - Convertir a JPEG
        // ========================================
        async function convertHeicToJpeg(file) {
            // Verificar si es HEIC/HEIF por:
            // 1. MIME type explícito
            // 2. Extensión del archivo (más confiable en algunos navegadores)
            // 3. MIME vacío o genérico + extensión HEIC (iOS/Chrome puede reportar '' o 'application/octet-stream')
            const fileName = file.name.toLowerCase();
            const hasHeicExtension = fileName.endsWith('.heic') || fileName.endsWith('.heif');
            const hasHeicMime = file.type === 'image/heic' || file.type === 'image/heif';
            const hasUnknownMime = !file.type || file.type === '' || file.type === 'application/octet-stream';

            const isHeic = hasHeicMime || hasHeicExtension || (hasUnknownMime && hasHeicExtension);

            if (!isHeic) {
                return file; // No es HEIC, devolver original
            }

            console.log('Detectado archivo HEIC:', file.name);

            // Método 1: Intentar con canvas nativo (funciona en Safari macOS/iOS)
            try {
                const nativeResult = await convertHeicNative(file);
                if (nativeResult) {
                    console.log('HEIC convertido con canvas nativo');
                    return nativeResult;
                }
            } catch (e) {
                console.log('Canvas nativo no soporta HEIC, intentando heic2any...');
            }

            // Método 2: Usar heic2any
            if (typeof heic2any !== 'undefined') {
                try {
                    console.log('Convirtiendo HEIC con heic2any...');
                    const jpegBlob = await heic2any({
                        blob: file,
                        toType: 'image/jpeg',
                        quality: 0.92
                    });

                    const blob = Array.isArray(jpegBlob) ? jpegBlob[0] : jpegBlob;
                    const jpegFile = new File(
                        [blob],
                        file.name.replace(/\.(heic|heif)$/i, '.jpg'),
                        { type: 'image/jpeg' }
                    );

                    console.log('HEIC convertido exitosamente:', jpegFile.name);
                    return jpegFile;
                } catch (error) {
                    console.error('heic2any falló:', error);
                }
            }

            // Método 3: Usar servidor como último recurso
            try {
                console.log('Intentando conversión en servidor...');
                const serverResult = await convertHeicServer(file);
                if (serverResult) {
                    console.log('HEIC convertido en servidor');
                    return serverResult;
                }
            } catch (e) {
                console.error('Conversión en servidor falló:', e);
            }

            // Si todo falla, mostrar mensaje útil
            alert('No se pudo convertir la imagen HEIC.\n\nOpciones:\n1. Usa Safari en Mac/iPhone (soporta HEIC nativo)\n2. Convierte la imagen a JPG antes de subirla\n3. Usa una app como "HEIC Converter" en tu dispositivo');
            return null;
        }

        // Convertir HEIC usando el servidor
        async function convertHeicServer(file) {
            const formData = new FormData();
            formData.append('archivo', file);

            const response = await fetch('/Stories/ConvertirHeic', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error || 'Error del servidor');
            }

            const blob = await response.blob();
            return new File(
                [blob],
                file.name.replace(/\.(heic|heif)$/i, '.jpg'),
                { type: 'image/jpeg' }
            );
        }

        // Intentar convertir HEIC usando canvas nativo (Safari)
        function convertHeicNative(file) {
            return new Promise((resolve, reject) => {
                const url = URL.createObjectURL(file);
                const img = new Image();

                img.onload = () => {
                    try {
                        // Crear canvas y dibujar imagen
                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;

                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        // Exportar como JPEG
                        canvas.toBlob((blob) => {
                            URL.revokeObjectURL(url);
                            if (blob) {
                                const jpegFile = new File(
                                    [blob],
                                    file.name.replace(/\.(heic|heif)$/i, '.jpg'),
                                    { type: 'image/jpeg' }
                                );
                                resolve(jpegFile);
                            } else {
                                reject(new Error('No se pudo crear blob'));
                            }
                        }, 'image/jpeg', 0.92);
                    } catch (e) {
                        URL.revokeObjectURL(url);
                        reject(e);
                    }
                };

                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    reject(new Error('Navegador no soporta HEIC'));
                };

                img.src = url;
            });
        }

        // ========================================
        // CARGAR MEDIA
        // ========================================
        let isVideoMedia = false; // Para saber si el media actual es video

        async function cargarMedia(input) {
            try {
                if (!input.files || !input.files[0]) {
                    EditorLog.media('warning', 'cargarMedia llamado sin archivo');
                    return;
                }

                let file = input.files[0];
                const fileInfo = {
                    name: file.name,
                    type: file.type,
                    size: Math.round(file.size / 1024) + 'KB'
                };

                EditorLog.media('info', 'Iniciando carga de media', fileInfo);

                // Verificar si es HEIC y convertir
                const isHeic = file.name.toLowerCase().endsWith('.heic') ||
                              file.name.toLowerCase().endsWith('.heif');

                if (isHeic) {
                    EditorLog.conversion('info', 'Detectado archivo HEIC, iniciando conversión', fileInfo);

                    // Mostrar indicador de conversión
                    const overlay = document.getElementById('uploadOverlay');
                    if (overlay) {
                        overlay.querySelector('p').innerHTML = '<span>Convirtiendo HEIC...</span>';
                    }

                    const converted = await convertHeicToJpeg(file);
                    if (converted) {
                        file = converted;
                        EditorLog.conversion('info', 'HEIC convertido exitosamente', {
                            originalName: fileInfo.name,
                            newSize: Math.round(converted.size / 1024) + 'KB'
                        });
                    } else {
                        EditorLog.conversion('error', 'Falló conversión HEIC', fileInfo);
                        alert('No se pudo convertir la imagen HEIC. Intenta con otro formato.');
                        return;
                    }
                }

                mediaFile = file;

                // Usar URL.createObjectURL para carga más rápida (sin base64)
                const objectUrl = URL.createObjectURL(file);
                mediaUrl = objectUrl;
                const videoElement = document.getElementById('videoBackground');

                // Verificar tipo de archivo
                const isImage = file.type.startsWith('image/') || isHeic;
                const isVideo = file.type.startsWith('video/');

                if (isImage) {
                    // Es una imagen
                    isVideoMedia = false;
                    videoElement.classList.remove('active');
                    videoElement.pause();
                    videoElement.src = '';

                    EditorLog.media('info', 'Cargando imagen en canvas', fileInfo);

                    // Cargar imagen con Fabric.js (más rápido con object URL)
                    fabric.Image.fromURL(objectUrl, function(img) {
                        try {
                            // Escalar para cubrir todo el canvas
                            const scale = Math.max(
                                canvas.width / img.width,
                                canvas.height / img.height
                            );
                            img.scale(scale);
                            img.set({
                                left: canvas.width / 2,
                                top: canvas.height / 2,
                                originX: 'center',
                                originY: 'center',
                                selectable: false,
                                evented: false,
                                lockMovementX: true,
                                lockMovementY: true
                            });
                            canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                            saveHistory();

                            // Ocultar overlay de upload
                            document.getElementById('uploadOverlay').classList.add('hidden');
                            habilitarBotonPublicar();

                            EditorLog.media('info', 'Imagen cargada exitosamente', {
                                originalSize: `${img.width}x${img.height}`,
                                scale: scale.toFixed(2)
                            });
                        } catch (imgError) {
                            EditorLog.media('error', 'Error procesando imagen en canvas', {
                                error: imgError.message,
                                file: fileInfo
                            });
                        }
                    }, { crossOrigin: 'anonymous' });
                } else if (isVideo) {
                    // Es un video
                    isVideoMedia = true;

                    EditorLog.media('info', 'Cargando video', fileInfo);

                    // Limpiar fondo del canvas (hacerlo transparente)
                    canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
                    canvas.backgroundColor = 'transparent';
                    canvas.renderAll();

                    // Configurar el video
                    videoElement.src = objectUrl;
                    videoElement.classList.add('active');

                    // Esperar a que el video cargue para mostrar el primer frame
                    videoElement.onloadeddata = function() {
                        // Ir a un frame visible (0.1 segundos)
                        videoElement.currentTime = 0.1;
                        EditorLog.media('info', 'Video loadeddata', {
                            duration: videoElement.duration,
                            videoWidth: videoElement.videoWidth,
                            videoHeight: videoElement.videoHeight
                        });
                    };

                    // Error al cargar video
                    videoElement.onerror = function(e) {
                        EditorLog.media('error', 'Error cargando video', {
                            errorCode: videoElement.error?.code,
                            errorMessage: videoElement.error?.message,
                            file: fileInfo
                        });
                    };

                    // Cuando esté listo para reproducir
                    videoElement.oncanplay = function() {
                        // Reproducir automáticamente
                        videoElement.play().catch(err => {
                            EditorLog.media('warning', 'Autoplay bloqueado, mostrando frame', {
                                error: err.message
                            });
                            videoElement.currentTime = 0.1;
                        });
                    };

                    // Cargar el video
                    videoElement.load();
                    saveHistory();

                    // Ocultar overlay de upload
                    document.getElementById('uploadOverlay').classList.add('hidden');
                    habilitarBotonPublicar();
                } else {
                    EditorLog.media('warning', 'Tipo de archivo no soportado', fileInfo);
                    alert('Tipo de archivo no soportado. Usa imágenes o videos.');
                }
            } catch (error) {
                EditorLog.media('error', 'Error en cargarMedia', {
                    error: error.message,
                    stack: error.stack
                });
                alert('Error al cargar el archivo. Intenta de nuevo.');
            }
        }

        // ========================================
        // HERRAMIENTAS
        // ========================================
        function seleccionarHerramienta(tool) {
            // Limpiar recursos de Beat Sync al cambiar de herramienta
            if (currentTool === 'beatsync' && tool !== 'beatsync') {
                stopBeatSyncPreview();
                stopCutterPlayback();
            }

            currentTool = tool;

            // Actualizar botones
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });

            // Mostrar panel de opciones correspondiente
            document.querySelectorAll('.option-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(tool + 'Options').classList.add('active');

            // Actualizar título
            const titles = {
                'text': 'Texto',
                'sticker': 'Stickers',
                'gif': 'GIFs',
                'mention': 'Mencionar',
                'draw': 'Dibujar',
                'music': 'Música',
                'link': 'Enlace',
                'effects': 'Efectos',
                'adjust': 'Ajustes',
                'crop': 'Recortar',
                'background': 'Fondos',
                'template': 'Plantillas',
                'beatsync': 'Beat Sync'
            };
            document.getElementById('optionsTitle').textContent = titles[tool] || 'Opciones';

            // Cargar GIFs trending al seleccionar la herramienta
            if (tool === 'gif' && !gifsYaCargados) {
                cargarGifsCategoria('trending');
                gifsYaCargados = true;
            }

            // Modo dibujo
            canvas.isDrawingMode = (tool === 'draw');
            if (tool === 'draw') {
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.color = drawConfig.color;
                canvas.freeDrawingBrush.width = drawConfig.width;
                canvas.freeDrawingBrush.decimate = 5;
            }

            // Cargar música cuando se selecciona esa herramienta
            if (tool === 'music') {
                cargarMusicaPopular();
            }

            // Cargar plantillas cuando se selecciona esa herramienta
            if (tool === 'template') {
                renderizarPlantillas('all');
            }

            // Abrir panel en móvil
            if (window.innerWidth <= 768) {
                abrirPanelOpciones();
            }
        }

        function abrirPanelOpciones() {
            document.getElementById('optionsPanel').classList.add('open');
            document.getElementById('optionsBackdrop').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function cerrarPanelOpciones() {
            const panel = document.getElementById('optionsPanel');
            panel.classList.remove('open');
            panel.classList.remove('expanded');
            document.getElementById('optionsBackdrop').classList.remove('active');
            document.body.style.overflow = '';
        }

        function toggleExpandPanel() {
            const panel = document.getElementById('optionsPanel');
            panel.classList.toggle('expanded');
        }

        // ========================================
        // TEXTO
        // ========================================
        function agregarTexto() {
            try {
                const texto = document.getElementById('textInput').value.trim();
                if (!texto) {
                    EditorLog.texto('warning', 'agregarTexto llamado sin texto');
                    return;
                }

                const textObj = new fabric.IText(texto, {
                    left: canvas.width / 2,
                    top: canvas.height / 2,
                    originX: 'center',
                    originY: 'center',
                    fontFamily: textConfig.font,
                    fontSize: textConfig.size,
                    fill: textConfig.color,
                    textBackgroundColor: textConfig.backgroundColor === 'transparent' ? '' : textConfig.backgroundColor,
                    padding: 8,
                    borderRadius: 4,
                    // Propiedades de interaccion
                    selectable: true,
                    evented: true,
                    hasControls: true,
                    hasBorders: true,
                    cornerColor: '#4682B4',
                    cornerStyle: 'circle',
                    borderColor: '#4682B4',
                    transparentCorners: false,
                    cornerSize: 10,
                    // Propiedades de animación
                    animacionEntrada: textAnimation.entrada,
                    efectoContinuo: textAnimation.continuo
                });

                // Aplicar efecto de preview si hay uno seleccionado
                if (textAnimation.continuo !== 'none') {
                    aplicarEfectoTextoPreview(textObj, textAnimation.continuo);
                }

                canvas.add(textObj);
                canvas.setActiveObject(textObj);
                canvas.bringToFront(textObj);
                canvas.renderAll();
                saveHistory();

                // Limpiar input
                document.getElementById('textInput').value = '';

                EditorLog.texto('info', 'Texto agregado', {
                    length: texto.length,
                    font: textConfig.font,
                    size: textConfig.size,
                    animacionEntrada: textAnimation.entrada,
                    efectoContinuo: textAnimation.continuo
                });
            } catch (error) {
                EditorLog.texto('error', 'Error en agregarTexto', {
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        function actualizarTextoSeleccionado() {
            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                obj.set('text', document.getElementById('textInput').value);
                canvas.renderAll();
            }
        }

        function cambiarFuente(font, el) {
            textConfig.font = font;
            // Deseleccionar en el grupo de fuentes de texto
            el.closest('.link-fonts-grid').querySelectorAll('.link-font-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');

            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                obj.set('fontFamily', font);
                canvas.renderAll();
            }
        }

        function cambiarTamanoTexto(size) {
            textConfig.size = parseInt(size);
            document.getElementById('fontSizeLabel').textContent = size;

            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                obj.set('fontSize', parseInt(size));
                canvas.renderAll();
            }
        }

        function cambiarColorTexto(color, el) {
            textConfig.color = color;
            document.querySelectorAll('#textColorPicker .color-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');

            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                obj.set('fill', color);
                canvas.renderAll();
            }
        }

        function cambiarFondoTexto(color, el) {
            textConfig.backgroundColor = color;
            document.querySelectorAll('#textBgPicker .color-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');

            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                obj.set('textBackgroundColor', color === 'transparent' ? '' : color);
                canvas.renderAll();
            }
        }

        // ========================================
        // STICKERS
        // ========================================
        function agregarSticker(emoji) {
            const text = new fabric.Text(emoji, {
                left: canvas.width / 2,
                top: canvas.height / 2,
                originX: 'center',
                originY: 'center',
                fontSize: 64,
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                cornerColor: '#4682B4',
                cornerStyle: 'circle',
                borderColor: '#4682B4',
                transparentCorners: false,
                cornerSize: 10
            });

            canvas.add(text);
            canvas.setActiveObject(text);
            canvas.bringToFront(text);
            canvas.renderAll();
            saveHistory();
        }

        // ========================================
        // MENCIONES
        // ========================================
        let searchTimeout;

        async function buscarUsuarios(query) {
            clearTimeout(searchTimeout);
            const resultsDiv = document.getElementById('mentionResults');

            if (query.length < 2) {
                resultsDiv.classList.remove('active');
                return;
            }

            searchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(`/Stories/BuscarUsuarios?query=${encodeURIComponent(query)}`);
                    const data = await response.json();

                    if (data.success && data.usuarios && data.usuarios.length > 0) {
                        resultsDiv.innerHTML = data.usuarios.map(u => `
                            <div class="mention-item" onclick="agregarMencion('${escapeHtml(u.id)}', '${escapeHtml(u.username)}', '${escapeHtml(u.avatar || '')}')">
                                ${u.avatar
                                    ? `<img src="${escapeHtml(u.avatar)}" class="mention-avatar" />`
                                    : `<div class="mention-avatar" style="display:flex;align-items:center;justify-content:center;color:#fff;font-weight:600;">${escapeHtml(u.nombre?.charAt(0) || '?')}</div>`
                                }
                                <div>
                                    <div style="font-weight:600;">@@${escapeHtml(u.username)}</div>
                                    <div style="font-size:12px;color:var(--muted);">${escapeHtml(u.nombre)}</div>
                                </div>
                            </div>
                        `).join('');
                        resultsDiv.classList.add('active');
                    } else {
                        resultsDiv.innerHTML = '<div style="padding:12px;color:var(--muted);">No se encontraron usuarios</div>';
                        resultsDiv.classList.add('active');
                    }
                } catch (error) {
                }
            }, 300);
        }

        function agregarMencion(userId, username, avatar) {
            const text = new fabric.IText('@@' + username, {
                left: canvas.width / 2,
                top: canvas.height / 2,
                originX: 'center',
                originY: 'center',
                fontFamily: 'Arial',
                fontSize: 28,
                fill: '#ffffff',
                fontWeight: 'bold',
                textBackgroundColor: 'rgba(0,0,0,0.5)',
                padding: 6,
                userId: userId,     // Metadata para guardar
                username: username  // Username sin arroba
            });

            canvas.add(text);
            canvas.setActiveObject(text);
            canvas.renderAll();
            saveHistory();

            // Cerrar resultados
            document.getElementById('mentionResults').classList.remove('active');
            document.getElementById('mentionSearch').value = '';
        }

        // ========================================
        // DIBUJO
        // ========================================
        function cambiarGrosorPincel(width, el) {
            try {
                drawConfig.width = width;
                canvas.freeDrawingBrush.width = width;
                document.querySelectorAll('.brush-size').forEach(btn => btn.classList.remove('selected'));
                el.classList.add('selected');
                EditorLog.tools('info', 'Grosor de pincel cambiado', { width });
            } catch (error) {
                EditorLog.tools('error', 'Error cambiando grosor de pincel', {
                    width,
                    error: error.message
                });
            }
        }

        function cambiarColorPincel(color, el) {
            try {
                drawConfig.color = color;
                canvas.freeDrawingBrush.color = color;
                document.querySelectorAll('#brushColorPicker .color-option').forEach(opt => opt.classList.remove('selected'));
                el.classList.add('selected');
                EditorLog.tools('info', 'Color de pincel cambiado', { color });
            } catch (error) {
                EditorLog.tools('error', 'Error cambiando color de pincel', {
                    color,
                    error: error.message
                });
            }
        }

        function borrarDibujo() {
            try {
                const objects = canvas.getObjects().filter(obj => obj.type === 'path');
                const count = objects.length;
                objects.forEach(obj => canvas.remove(obj));
                canvas.renderAll();
                saveHistory();
                EditorLog.tools('info', 'Dibujos borrados', { count });
            } catch (error) {
                EditorLog.tools('error', 'Error borrando dibujos', {
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        // ========================================
        // MÚSICA - Estilo TikTok
        // ========================================
        let currentMusicTab = 'popular';
        let musicaFavoritos = JSON.parse(localStorage.getItem('musicaFavoritos') || '[]');
        let musicaRecientes = JSON.parse(localStorage.getItem('musicaRecientes') || '[]');

        function toggleMusicSearch() {
            const container = document.getElementById('musicSearchContainer');
            const input = document.getElementById('musicSearch');
            container.classList.toggle('active');
            if (container.classList.contains('active')) {
                input.focus();
            } else {
                input.value = '';
                cargarMusicaTab(currentMusicTab);
            }
        }

        function cambiarTabMusica(tab, el) {
            currentMusicTab = tab;
            document.querySelectorAll('.music-tab').forEach(t => t.classList.remove('active'));
            el.classList.add('active');

            // Cerrar búsqueda si está abierta
            document.getElementById('musicSearchContainer').classList.remove('active');
            document.getElementById('musicSearch').value = '';

            cargarMusicaTab(tab);
        }

        // Construir URL de audio usando el proxy para evitar CORS en iOS/móviles
        function getAudioProxyUrl(pista) {
            // Si tiene ID, usar el endpoint proxy que tiene headers CORS correctos
            if (pista.id && !pista.esPersonalizada) {
                return `/api/Musica/audio/${pista.id}`;
            }
            // Para música personalizada (subida por usuario), usar la URL original
            return pista.audioUrl || pista.rutaArchivo || pista.url;
        }

        // Transformar pista para usar URL proxy
        function transformPistaForProxy(p) {
            return {
                ...p,
                audioUrl: getAudioProxyUrl(p),
                originalAudioUrl: p.audioUrl || p.rutaArchivo || p.url
            };
        }

        async function cargarMusicaTab(tab) {
            try {
                EditorLog.audio('info', 'Cargando tab de música', { tab });
                const listDiv = document.getElementById('musicList');
                listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>Cargando...</p></div>';

                if (tab === 'favoritos') {
                    if (musicaFavoritos.length > 0) {
                        mostrarListaMusica(musicaFavoritos);
                        EditorLog.audio('info', 'Favoritos cargados', { count: musicaFavoritos.length });
                    } else {
                        listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><p>No tienes favoritos</p></div>';
                    }
                    return;
                }

                if (tab === 'recientes') {
                    if (musicaRecientes.length > 0) {
                        mostrarListaMusica(musicaRecientes);
                        EditorLog.audio('info', 'Recientes cargados', { count: musicaRecientes.length });
                    } else {
                        listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/></svg><p>No hay recientes</p></div>';
                    }
                    return;
                }

                const response = await fetch('/Stories/BuscarMusica?query=');
                const data = await response.json();

                if (data.success && data.pistas && data.pistas.length > 0) {
                    mostrarListaMusica(data.pistas);
                    EditorLog.audio('info', 'Música popular cargada', { count: data.pistas.length });
                } else {
                    listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>No hay canciones disponibles</p></div>';
                }
            } catch (error) {
                EditorLog.audio('error', 'Error cargando tab de música', { tab, error: error.message });
                const listDiv = document.getElementById('musicList');
                listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>Error al cargar</p></div>';
            }
        }

        async function buscarMusica(query) {
            const listDiv = document.getElementById('musicList');

            if (query.length < 2) {
                cargarMusicaTab(currentMusicTab);
                return;
            }

            EditorLog.audio('info', 'Buscando música', { query });
            listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>Buscando...</p></div>';

            try {
                const response = await fetch(`/Stories/BuscarMusica?query=${encodeURIComponent(query)}`);
                const data = await response.json();

                if (data.success && data.pistas && data.pistas.length > 0) {
                    mostrarListaMusica(data.pistas);
                    EditorLog.audio('info', 'Búsqueda de música exitosa', { query, count: data.pistas.length });
                } else {
                    EditorLog.audio('info', 'Búsqueda sin resultados', { query });
                    listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>No se encontraron canciones</p></div>';
                }
            } catch (error) {
                EditorLog.audio('error', 'Error buscando música', { query, error: error.message });
                listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>Error al buscar</p></div>';
            }
        }

        async function cargarMusicaPopular() {
            cargarMusicaTab('popular');
        }

        function toggleFavorito(pista, btn, e) {
            e.stopPropagation();
            const index = musicaFavoritos.findIndex(f => f.id === pista.id);

            if (index > -1) {
                musicaFavoritos.splice(index, 1);
                btn.classList.remove('favorited');
            } else {
                musicaFavoritos.unshift(pista);
                btn.classList.add('favorited');
            }

            localStorage.setItem('musicaFavoritos', JSON.stringify(musicaFavoritos));
        }

        function agregarARecientes(pista) {
            // Remover si ya existe
            musicaRecientes = musicaRecientes.filter(r => r.id !== pista.id);
            // Agregar al inicio
            musicaRecientes.unshift(pista);
            // Mantener solo los últimos 20
            musicaRecientes = musicaRecientes.slice(0, 20);
            localStorage.setItem('musicaRecientes', JSON.stringify(musicaRecientes));
        }

        function mostrarListaMusica(pistas) {
            const listDiv = document.getElementById('musicList');

            if (!pistas || pistas.length === 0) {
                listDiv.innerHTML = '<div class="music-empty"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg><p>No hay canciones</p></div>';
                return;
            }

            listDiv.innerHTML = pistas.map(p => {
                // Transformar la pista para usar URL del proxy (evita CORS en iOS)
                const pistaProxy = transformPistaForProxy(p);
                const isFavorito = musicaFavoritos.some(f => f.id === p.id);
                const isSelected = selectedMusic?.id === p.id;
                const pistaJson = JSON.stringify(pistaProxy).replace(/"/g, '&quot;');

                return `
                <div class="music-item ${isSelected ? 'selected' : ''}" data-music-id="${p.id}" onclick="seleccionarMusica(${pistaJson})">
                    <img src="${escapeHtml(p.portada) || '/images/music-placeholder.svg'}" class="music-cover" onerror="this.src='/images/music-placeholder.svg'" />
                    <div class="music-info">
                        <div class="music-title-row">
                            <span class="music-playing-icon">
                                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                            </span>
                            <span class="music-title">${escapeHtml(p.titulo)}</span>
                        </div>
                        <div class="music-meta">
                            <span>${escapeHtml(p.artista)}</span>
                            <span>${formatDuration(p.duracion || 0)}</span>
                        </div>
                    </div>
                    <div class="music-actions">
                        <button type="button" class="music-action-btn" onclick="event.stopPropagation(); seleccionarMusica(${pistaJson})" title="Usar">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <line x1="12" y1="18" x2="12" y2="12"/>
                                <line x1="9" y1="15" x2="15" y2="15"/>
                            </svg>
                        </button>
                        <button type="button" class="music-action-btn ${isFavorito ? 'favorited' : ''}" onclick="toggleFavorito(${pistaJson}, this, event)" title="${isFavorito ? 'Quitar de favoritos' : 'Agregar a favoritos'}">
                            <svg viewBox="0 0 24 24" fill="${isFavorito ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
                                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `}).join('');
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ========================================
        // AUDIO CUTTER - Waveform Editor
        // ========================================
        const audioCutter = document.getElementById('audioCutterContainer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const waveformContainer = document.getElementById('waveformContainer');
        const waveformSelection = document.getElementById('waveformSelection');
        const handleLeft = document.getElementById('handleLeft');
        const handleRight = document.getElementById('handleRight');
        const waveformPlayhead = document.getElementById('waveformPlayhead');
        const waveformTime = document.getElementById('waveformTime');
        const cutStartInput = document.getElementById('cutStartInput');
        const cutEndInput = document.getElementById('cutEndInput');
        const selectionDurationSpan = document.getElementById('selectionDuration');
        const cutterPlayBtn = document.getElementById('cutterPlayBtn');
        const cutterVolumeSlider = document.getElementById('cutterVolumeSlider');
        const cutterVolumeValue = document.getElementById('cutterVolumeValue');
        const cutterDuration = document.getElementById('cutterDuration');

        let audioContext = null;
        let audioBuffer = null;
        let audioDuration = 0;
        let selectionStart = 0;
        let selectionEnd = 15;
        let isPlaying = false;
        let playbackSource = null;
        let playbackStartTime = 0;
        let playbackAnimationId = null;
        let isDragging = false;
        let dragHandle = null;
        let cutterAudioElement = null; // HTMLAudioElement para reproducción (mejor en iOS)
        let currentMusicUrl = null;

        function seleccionarMusica(pista) {
            try {
                EditorLog.audio('info', 'Seleccionando música', {
                    id: pista?.id,
                    titulo: pista?.titulo,
                    artista: pista?.artista,
                    duracion: pista?.duracion
                });

                // Detener cualquier preview en reproducción
                stopAllPreviews();

                selectedMusic = pista;
                musicDuration = pista.duracion || 180;
                musicTrimStart = 0;
                musicVolume = 70;
                selectionStart = 0;
                selectionEnd = Math.min(15, musicDuration);

                // Agregar a recientes (solo si no es personalizada)
                if (!pista.esPersonalizada) {
                    agregarARecientes(pista);
                }

                // Marcar como seleccionada en la lista
                document.querySelectorAll('.music-item').forEach(item => item.classList.remove('selected'));
                const musicItem = document.querySelector(`.music-item[data-music-id="${pista.id}"]`);
                if (musicItem) musicItem.classList.add('selected');

                // Mostrar el panel de música seleccionada
                const container = document.getElementById('selectedMusicContainer');
                container.style.display = 'block';

                // Mostrar el selector de música (por si estaba oculto)
                const selector = document.querySelector('.music-selector');
                if (selector) selector.style.display = 'block';

                // Resetear botón de confirmar
                const btnConfirm = document.getElementById('btnConfirmMusic');
                if (btnConfirm) {
                    btnConfirm.classList.remove('confirmed');
                    btnConfirm.querySelector('span').textContent = 'Usar esta música';
                }

                // Actualizar info de la canción
                document.getElementById('selectedMusicTitle').textContent = `${pista.titulo} - ${pista.artista}`;

                // Inicializar audio cutter
                if (pista.audioUrl) {
                    currentMusicUrl = pista.audioUrl;
                    initAudioCutter(pista.audioUrl);

                    // Crear elemento de audio para reproducción (más compatible con iOS)
                    if (cutterAudioElement) {
                        cutterAudioElement.pause();
                        cutterAudioElement.src = '';
                    }
                    cutterAudioElement = new Audio();
                    cutterAudioElement.preload = 'auto';
                    cutterAudioElement.src = pista.audioUrl;
                    cutterAudioElement.load();
                }

                EditorLog.audio('info', 'Música seleccionada exitosamente', { id: pista?.id });
            } catch (error) {
                EditorLog.audio('error', 'Error en seleccionarMusica', {
                    error: error.message,
                    pistaId: pista?.id
                });
            }
        }

        async function initAudioCutter(url) {
            if (!waveformCanvas || !url) return;

            audioCutter.classList.add('loading');

            try {
                // Crear AudioContext con manejo robusto
                if (!audioContext || audioContext.state === 'closed') {
                    // Si hay un contexto global válido, usarlo
                    if (globalAudioContext && globalAudioContext.state !== 'closed') {
                        audioContext = globalAudioContext;
                    } else {
                        // Crear nuevo AudioContext con opciones por defecto del sistema
                        try {
                            audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            globalAudioContext = audioContext;
                        } catch (ctxError) {
                            console.error('Error creando AudioContext:', ctxError);
                            // Intentar con sample rate específico como fallback
                            try {
                                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                                globalAudioContext = audioContext;
                            } catch (e) {
                                throw new Error('No se pudo inicializar el audio');
                            }
                        }
                    }
                }

                // Resumir si está suspendido (importante para iOS y Chrome)
                if (audioContext.state === 'suspended') {
                    try {
                        await audioContext.resume();
                    } catch (resumeError) {
                        console.warn('No se pudo resumir AudioContext:', resumeError);
                    }
                }

                // Cargar audio
                const response = await fetch(url);
                if (!response.ok) throw new Error('Error cargando audio');

                const arrayBuffer = await response.arrayBuffer();

                // Decodificar audio (clonar buffer porque decodeAudioData lo consume)
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
                audioDuration = audioBuffer.duration;

                // Actualizar UI
                if (cutterDuration) cutterDuration.textContent = formatTime(audioDuration);
                selectionEnd = Math.min(15, audioDuration);

                // Dibujar forma de onda
                drawWaveform();
                updateSelection();
                setupDragHandles();

                audioCutter.classList.remove('loading');
            } catch (error) {
                console.error('Error en initAudioCutter:', error);

                // Fallback: usar HTMLAudioElement para obtener la duración
                // Esto funciona mejor en iOS cuando hay problemas de CORS
                try {
                    if (cutterAudioElement) {
                        await new Promise((resolve, reject) => {
                            const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);

                            cutterAudioElement.onloadedmetadata = () => {
                                clearTimeout(timeout);
                                audioDuration = cutterAudioElement.duration;
                                if (cutterDuration) cutterDuration.textContent = formatTime(audioDuration);
                                selectionEnd = Math.min(15, audioDuration);
                                updateSelection();
                                resolve();
                            };

                            cutterAudioElement.onerror = () => {
                                clearTimeout(timeout);
                                reject(new Error('Error cargando audio'));
                            };

                            // Forzar carga si no tiene metadatos
                            if (cutterAudioElement.readyState >= 1) {
                                audioDuration = cutterAudioElement.duration;
                                if (cutterDuration) cutterDuration.textContent = formatTime(audioDuration);
                                selectionEnd = Math.min(15, audioDuration);
                                updateSelection();
                                clearTimeout(timeout);
                                resolve();
                            }
                        });

                        audioCutter.classList.remove('loading');

                        // Mostrar waveform simplificado (barras aleatorias simuladas)
                        drawSimplifiedWaveform();
                        console.log('Usando modo simplificado (sin waveform real)');
                        return;
                    }
                } catch (fallbackError) {
                    console.warn('Fallback también falló:', fallbackError);
                }

                audioCutter.classList.remove('loading');

                // Mostrar mensaje de error al usuario
                const waveformContainer = document.getElementById('waveformContainer');
                if (waveformContainer) {
                    waveformContainer.innerHTML = `
                        <div style="text-align:center;padding:20px;color:var(--text-muted);">
                            <svg style="width:40px;height:40px;margin-bottom:10px;opacity:0.5" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                            </svg>
                            <p style="margin:0;font-size:14px;">Error cargando audio</p>
                            <p style="margin:5px 0 0;font-size:12px;opacity:0.7;">Toca para reintentar</p>
                        </div>
                    `;
                    waveformContainer.onclick = () => {
                        // Restaurar estructura del waveform
                        waveformContainer.innerHTML = `
                            <canvas class="waveform-canvas" id="waveformCanvas"></canvas>
                            <div class="waveform-selection" id="waveformSelection">
                                <div class="selection-handle handle-left" id="handleLeft">
                                    <div class="handle-bar"></div>
                                </div>
                                <div class="selection-handle handle-right" id="handleRight">
                                    <div class="handle-bar"></div>
                                </div>
                            </div>
                            <div class="waveform-playhead" id="waveformPlayhead"></div>
                            <div class="waveform-time" id="waveformTime">00:00.0</div>
                        `;
                        // Reinicializar referencias
                        waveformCanvas = document.getElementById('waveformCanvas');
                        waveformPlayhead = document.getElementById('waveformPlayhead');
                        handleLeft = document.getElementById('handleLeft');
                        handleRight = document.getElementById('handleRight');
                        initAudioCutter(url);
                    };
                }
            }
        }

        // Waveform simplificado cuando no se puede decodificar el audio
        function drawSimplifiedWaveform() {
            if (!waveformCanvas) return;

            const ctx = waveformCanvas.getContext('2d');
            const container = waveformContainer;
            const width = container.offsetWidth;
            const height = container.offsetHeight;

            waveformCanvas.width = width * window.devicePixelRatio;
            waveformCanvas.height = height * window.devicePixelRatio;
            waveformCanvas.style.width = width + 'px';
            waveformCanvas.style.height = height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            // Dibujar barras simuladas
            const barWidth = 3;
            const gap = 2;
            const bars = Math.floor(width / (barWidth + gap));
            const centerY = height / 2;

            // Gradiente
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(45, 212, 191, 0.8)');
            gradient.addColorStop(0.5, 'rgba(45, 212, 191, 0.4)');
            gradient.addColorStop(1, 'rgba(45, 212, 191, 0.8)');

            ctx.fillStyle = gradient;

            // Generar patrón de audio simulado (usando seed basada en URL para consistencia)
            const seed = currentMusicUrl ? currentMusicUrl.length : 42;
            for (let i = 0; i < bars; i++) {
                const x = i * (barWidth + gap);
                // Simular forma de onda con patrón semi-aleatorio
                const noise = Math.sin(i * 0.1 + seed) * Math.cos(i * 0.05) + Math.sin(i * 0.3);
                const normalizedHeight = (0.3 + Math.abs(noise) * 0.5) * (height * 0.8);
                const barHeight = Math.max(4, normalizedHeight);

                ctx.fillRect(x, centerY - barHeight / 2, barWidth, barHeight);
            }

            updateSelection();
            setupDragHandles();
        }

        function drawWaveform() {
            if (!audioBuffer || !waveformCanvas) return;

            const ctx = waveformCanvas.getContext('2d');
            const width = waveformContainer.offsetWidth;
            const height = waveformContainer.offsetHeight;

            waveformCanvas.width = width * window.devicePixelRatio;
            waveformCanvas.height = height * window.devicePixelRatio;
            waveformCanvas.style.width = width + 'px';
            waveformCanvas.style.height = height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            // Combinar canales si es stereo
            const channelData = audioBuffer.getChannelData(0);
            const data = audioBuffer.numberOfChannels > 1
                ? mergeChannels(channelData, audioBuffer.getChannelData(1))
                : channelData;

            // Calcular pico máximo para normalizar
            let maxPeak = 0;
            for (let i = 0; i < data.length; i++) {
                const absVal = Math.abs(data[i]);
                if (absVal > maxPeak) maxPeak = absVal;
            }
            maxPeak = maxPeak || 1;

            // Configuración de barras
            const barWidth = 3;
            const barGap = 1;
            const barCount = Math.floor(width / (barWidth + barGap));
            const samplesPerBar = Math.floor(data.length / barCount);
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);

            for (let i = 0; i < barCount; i++) {
                const startSample = i * samplesPerBar;
                const endSample = startSample + samplesPerBar;

                let sumSquares = 0;
                let peakInBar = 0;
                for (let j = startSample; j < endSample && j < data.length; j++) {
                    const val = Math.abs(data[j]);
                    sumSquares += val * val;
                    if (val > peakInBar) peakInBar = val;
                }
                const rms = Math.sqrt(sumSquares / samplesPerBar);
                const normalizedValue = ((rms * 0.7) + (peakInBar * 0.3)) / maxPeak;
                const barHeight = Math.max(2, normalizedValue * height * 0.9);

                const x = i * (barWidth + barGap);
                const y = centerY - (barHeight / 2);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.roundRect(x, y, barWidth, barHeight, 1);
                ctx.fill();
            }
        }

        function mergeChannels(ch1, ch2) {
            const merged = new Float32Array(ch1.length);
            for (let i = 0; i < ch1.length; i++) {
                merged[i] = (ch1[i] + ch2[i]) / 2;
            }
            return merged;
        }

        function updateSelection() {
            if (!waveformContainer || !waveformSelection || !audioDuration) return;

            const startPercent = (selectionStart / audioDuration) * 100;
            const endPercent = (selectionEnd / audioDuration) * 100;

            waveformSelection.style.left = startPercent + '%';
            waveformSelection.style.width = (endPercent - startPercent) + '%';

            // Actualizar inputs de tiempo
            if (cutStartInput) cutStartInput.value = formatTimeMs(selectionStart);
            if (cutEndInput) cutEndInput.value = formatTimeMs(selectionEnd);
            if (selectionDurationSpan) {
                selectionDurationSpan.textContent = (selectionEnd - selectionStart).toFixed(1) + 's';
            }

            // Guardar valores
            musicTrimStart = Math.round(selectionStart);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatTimeMs(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return `${mins.toString().padStart(2, '0')}:${secs.padStart(4, '0')}`;
        }

        // Drag handles para selección
        function setupDragHandles() {
            if (!handleLeft || !handleRight || !waveformContainer) return;

            const startDrag = (e, handle) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                dragHandle = handle;

                document.body.style.cursor = 'ew-resize';
                if (handle === 'left') {
                    handleLeft.classList.add('dragging');
                } else {
                    handleRight.classList.add('dragging');
                }

                document.addEventListener('mousemove', onDrag);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchmove', onDrag, { passive: false });
                document.addEventListener('touchend', stopDrag);
            };

            handleLeft.addEventListener('mousedown', (e) => startDrag(e, 'left'));
            handleRight.addEventListener('mousedown', (e) => startDrag(e, 'right'));
            handleLeft.addEventListener('touchstart', (e) => startDrag(e, 'left'), { passive: false });
            handleRight.addEventListener('touchstart', (e) => startDrag(e, 'right'), { passive: false });
        }

        function onDrag(e) {
            if (!isDragging || !waveformContainer || !audioDuration) return;
            e.preventDefault();

            const rect = waveformContainer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let x = clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width));

            const time = (x / rect.width) * audioDuration;

            if (dragHandle === 'left') {
                selectionStart = Math.min(time, selectionEnd - 1);
                selectionStart = Math.max(0, selectionStart);
            } else {
                selectionEnd = Math.max(time, selectionStart + 1);
                selectionEnd = Math.min(audioDuration, selectionEnd);
            }

            updateSelection();
        }

        function stopDrag() {
            isDragging = false;
            document.body.style.cursor = '';

            if (handleLeft) handleLeft.classList.remove('dragging');
            if (handleRight) handleRight.classList.remove('dragging');

            dragHandle = null;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        // Click en waveform para mover selección
        if (waveformContainer) {
            waveformContainer.addEventListener('click', function(e) {
                if (isDragging) return;
                if (e.target.closest('.selection-handle')) return;
                if (!audioDuration) return;

                const rect = waveformContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickTime = (x / rect.width) * audioDuration;

                const duration = selectionEnd - selectionStart;
                let newStart = clickTime - (duration / 2);
                newStart = Math.max(0, Math.min(newStart, audioDuration - duration));

                selectionStart = newStart;
                selectionEnd = newStart + duration;
                updateSelection();
            });
        }

        // Reproducir selección
        if (cutterPlayBtn) {
            cutterPlayBtn.addEventListener('click', function() {
                if (isPlaying) {
                    stopPlayback();
                } else {
                    playSelection();
                }
            });
        }

        async function playSelection() {
            // Usar HTMLAudioElement si está disponible (mejor compatibilidad iOS)
            if (cutterAudioElement && currentMusicUrl) {
                try {
                    const volume = (cutterVolumeSlider?.value || 70) / 100;
                    cutterAudioElement.volume = volume;
                    cutterAudioElement.currentTime = selectionStart;

                    // Configurar evento para detener al final de la selección
                    const checkEnd = () => {
                        if (cutterAudioElement.currentTime >= selectionEnd) {
                            stopPlayback();
                        }
                    };

                    cutterAudioElement.ontimeupdate = checkEnd;
                    cutterAudioElement.onended = () => stopPlayback();
                    cutterAudioElement.onerror = (e) => {
                        console.error('Error reproduciendo audio:', e);
                        stopPlayback();
                    };

                    await cutterAudioElement.play();
                    isPlaying = true;
                    playbackStartTime = Date.now() / 1000 - selectionStart;
                    updatePlayButton(true);
                    animatePlayheadWithElement();
                    return;
                } catch (e) {
                    console.warn('Error con HTMLAudioElement, intentando con AudioContext:', e);
                    // Fallback a AudioContext
                }
            }

            // Fallback: usar AudioContext (para navegadores que lo soporten mejor)
            if (!audioBuffer) {
                console.warn('No hay audio buffer para reproducir');
                return;
            }

            // Desbloquear audio en iOS primero
            if (isIOS() && !audioUnlocked) {
                unlockAudioForIOS();
            }

            // Crear o recuperar AudioContext si no existe
            if (!audioContext || audioContext.state === 'closed') {
                if (globalAudioContext && globalAudioContext.state !== 'closed') {
                    audioContext = globalAudioContext;
                } else {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        globalAudioContext = audioContext;
                    } catch (e) {
                        console.error('No se pudo crear AudioContext:', e);
                        return;
                    }
                }
            }

            // Esperar a que el AudioContext esté activo
            if (audioContext.state === 'suspended') {
                try {
                    await audioContext.resume();
                } catch (e) {
                    console.warn('No se pudo resumir AudioContext:', e);
                    return;
                }
            }

            const volume = (cutterVolumeSlider?.value || 70) / 100;

            playbackSource = audioContext.createBufferSource();
            playbackSource.buffer = audioBuffer;

            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;

            playbackSource.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const duration = selectionEnd - selectionStart;
            playbackStartTime = audioContext.currentTime;
            playbackSource.start(0, selectionStart, duration);

            playbackSource.onended = () => {
                stopPlayback();
            };

            isPlaying = true;
            updatePlayButton(true);
            animatePlayhead();
        }

        // Animación del playhead usando HTMLAudioElement
        function animatePlayheadWithElement() {
            if (!isPlaying || !waveformPlayhead || !cutterAudioElement) return;

            const currentTime = cutterAudioElement.currentTime;

            if (currentTime >= selectionEnd) {
                stopPlayback();
                return;
            }

            const percent = (currentTime / audioDuration) * 100;
            waveformPlayhead.style.display = 'block';
            waveformPlayhead.style.left = percent + '%';

            if (waveformTime) {
                waveformTime.textContent = formatTimeMs(currentTime);
            }

            playbackAnimationId = requestAnimationFrame(animatePlayheadWithElement);
        }

        function stopPlayback() {
            // Detener HTMLAudioElement si existe
            if (cutterAudioElement) {
                try {
                    cutterAudioElement.pause();
                    cutterAudioElement.ontimeupdate = null;
                } catch(e) {}
            }

            // Detener AudioContext source si existe
            if (playbackSource) {
                try { playbackSource.stop(); } catch(e) {}
                playbackSource = null;
            }

            if (playbackAnimationId) {
                cancelAnimationFrame(playbackAnimationId);
                playbackAnimationId = null;
            }
            isPlaying = false;
            updatePlayButton(false);
            if (waveformPlayhead) {
                waveformPlayhead.style.display = 'none';
            }
        }

        function animatePlayhead() {
            if (!isPlaying || !waveformPlayhead || !audioContext) return;

            const elapsed = audioContext.currentTime - playbackStartTime;
            const currentTime = selectionStart + elapsed;

            if (currentTime >= selectionEnd) {
                stopPlayback();
                return;
            }

            const percent = (currentTime / audioDuration) * 100;
            waveformPlayhead.style.display = 'block';
            waveformPlayhead.style.left = percent + '%';

            if (waveformTime) {
                waveformTime.textContent = formatTimeMs(currentTime);
            }

            playbackAnimationId = requestAnimationFrame(animatePlayhead);
        }

        function updatePlayButton(playing) {
            if (!cutterPlayBtn) return;
            const playIcon = cutterPlayBtn.querySelector('.play-icon');
            const pauseIcon = cutterPlayBtn.querySelector('.pause-icon');

            if (playing) {
                cutterPlayBtn.classList.add('playing');
                if (playIcon) playIcon.style.display = 'none';
                if (pauseIcon) pauseIcon.style.display = 'block';
            } else {
                cutterPlayBtn.classList.remove('playing');
                if (playIcon) playIcon.style.display = 'block';
                if (pauseIcon) pauseIcon.style.display = 'none';
            }
        }

        // Control de volumen
        if (cutterVolumeSlider) {
            cutterVolumeSlider.addEventListener('input', function() {
                const value = parseInt(this.value);
                musicVolume = value;
                if (cutterVolumeValue) {
                    cutterVolumeValue.textContent = value + '%';
                }
            });
        }

        function stopAllPreviews() {
            stopPlayback();
            if (listPreviewAudio) {
                try {
                    listPreviewAudio.pause();
                    listPreviewAudio.src = '';
                    listPreviewAudio.load();
                } catch(e) {}
                listPreviewAudio = null;
            }
            // También detener preview de biblioteca
            detenerPreviewTrack();
            // Resetear iconos de play en la lista
            document.querySelectorAll('.music-play-btn').forEach(btn => {
                const playIcon = btn.querySelector('.play-icon');
                const pauseIcon = btn.querySelector('.pause-icon');
                if (playIcon) playIcon.style.display = 'block';
                if (pauseIcon) pauseIcon.style.display = 'none';
            });
            document.querySelectorAll('.music-item').forEach(item => item.classList.remove('playing'));
        }

        function quitarMusica() {
            stopAllPreviews();
            stopPlayback();

            // Limpiar HTMLAudioElement
            if (cutterAudioElement) {
                cutterAudioElement.pause();
                cutterAudioElement.src = '';
                cutterAudioElement = null;
            }
            currentMusicUrl = null;

            selectedMusic = null;
            musicDuration = 0;
            musicTrimStart = 0;
            musicVolume = 70;
            audioDuration = 0;
            selectionStart = 0;
            selectionEnd = 15;
            audioBuffer = null;

            document.getElementById('selectedMusicContainer').style.display = 'none';
            document.querySelectorAll('.music-item').forEach(item => item.classList.remove('selected'));

            // Resetear botón de confirmar
            const btnConfirm = document.getElementById('btnConfirmMusic');
            if (btnConfirm) {
                btnConfirm.classList.remove('confirmed');
                btnConfirm.querySelector('span').textContent = 'Usar esta música';
            }
        }

        // Función para confirmar la selección de música
        function confirmarMusica() {
            if (!selectedMusic) return;

            const btnConfirm = document.getElementById('btnConfirmMusic');
            btnConfirm.classList.add('confirmed');
            btnConfirm.querySelector('span').textContent = '¡Música agregada!';

            // Guardar los valores actuales
            musicTrimStart = selectionStart;
            musicVolume = parseInt(document.getElementById('cutterVolumeSlider').value);

            // Mostrar notificación
            mostrarNotificacion(`Música "${selectedMusic.titulo}" agregada`, 'success');

            // Ocultar el selector después de un momento
            setTimeout(() => {
                document.querySelector('.music-selector').style.display = 'none';
            }, 500);
        }

        // Función para manejar subida de música propia
        function handleMusicUpload(input) {
            const file = input.files[0];
            if (!file) return;

            // Validar que sea un archivo de audio
            if (!file.type.startsWith('audio/')) {
                mostrarNotificacion('Por favor selecciona un archivo de audio válido', 'error');
                return;
            }

            // Validar tamaño (máximo 20MB)
            if (file.size > 20 * 1024 * 1024) {
                mostrarNotificacion('El archivo es muy grande. Máximo 20MB', 'error');
                return;
            }

            // Crear URL temporal para el archivo
            const audioUrl = URL.createObjectURL(file);

            // Obtener nombre sin extensión
            const fileName = file.name.replace(/\.[^/.]+$/, '');

            // Crear objeto de pista personalizada
            const customTrack = {
                id: 'custom_' + Date.now(),
                titulo: fileName,
                artista: 'Tu música',
                duracion: 0,
                audioUrl: audioUrl,
                portadaUrl: null,
                esPersonalizada: true
            };

            // Obtener duración del audio
            const tempAudio = new Audio(audioUrl);
            tempAudio.addEventListener('loadedmetadata', function() {
                customTrack.duracion = Math.floor(tempAudio.duration);

                // Seleccionar la pista
                seleccionarMusica(customTrack);

                mostrarNotificacion(`"${fileName}" cargado correctamente`, 'success');
            });

            tempAudio.addEventListener('error', function() {
                mostrarNotificacion('Error al cargar el archivo de audio', 'error');
                URL.revokeObjectURL(audioUrl);
            });

            // Limpiar el input para permitir seleccionar el mismo archivo otra vez
            input.value = '';
        }

        function toggleMusicPreview(url, btn) {
            if (!url) return;

            // Desbloquear audio en iOS primero
            if (isIOS() && !audioUnlocked) {
                unlockAudioForIOS();
            }

            const musicItem = btn.closest('.music-item');
            const playIcon = btn.querySelector('.play-icon');
            const pauseIcon = btn.querySelector('.pause-icon');

            // Si ya está reproduciendo, detener
            if (musicItem.classList.contains('playing')) {
                stopAllPreviews();
                return;
            }

            // Detener cualquier otro preview
            stopAllPreviews();

            // Crear audio con streaming
            listPreviewAudio = new Audio();
            listPreviewAudio.preload = 'auto';
            listPreviewAudio.volume = 0.7;

            listPreviewAudio.oncanplaythrough = () => {
                if (listPreviewAudio && listPreviewAudio.src) {
                    listPreviewAudio.play().catch(() => {});
                }
            };

            listPreviewAudio.onplay = () => {
                if (playIcon) playIcon.style.display = 'none';
                if (pauseIcon) pauseIcon.style.display = 'block';
                musicItem.classList.add('playing');
            };

            listPreviewAudio.onended = () => {
                if (playIcon) playIcon.style.display = 'block';
                if (pauseIcon) pauseIcon.style.display = 'none';
                musicItem.classList.remove('playing');
            };

            listPreviewAudio.onerror = () => {
                if (playIcon) playIcon.style.display = 'block';
                if (pauseIcon) pauseIcon.style.display = 'none';
                musicItem.classList.remove('playing');
            };

            listPreviewAudio.onpause = () => {
                if (playIcon) playIcon.style.display = 'block';
                if (pauseIcon) pauseIcon.style.display = 'none';
                musicItem.classList.remove('playing');
            };

            // Iniciar streaming
            listPreviewAudio.src = url;
            listPreviewAudio.load();
        }

        // ========================================
        // LINK
        // ========================================
        function cambiarEstiloLink(style, el) {
            linkConfig.style = style;
            document.querySelectorAll('.link-style-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
        }

        function cambiarColorLink(color, el) {
            linkConfig.color = color;
            document.querySelectorAll('#linkColorPicker .color-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
        }

        function cambiarFuenteLink(font, el) {
            linkConfig.font = font;
            document.querySelectorAll('.link-font-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
        }

        function getTextColorForBg(bgColor) {
            // Devuelve blanco o negro según el color de fondo
            if (bgColor === '#ffffff' || bgColor === '#ffdd00') return '#000000';
            return '#ffffff';
        }

        function getLinkFillColor() {
            if (linkConfig.color === 'gradient-purple') {
                // Fabric.js no soporta gradientes CSS, usar color sólido
                return '#764ba2';
            }
            return linkConfig.color;
        }

        function eliminarLinkActual() {
            try {
                if (storyLinkObject) {
                    const linkUrl = storyLinkObject.linkUrl;
                    canvas.remove(storyLinkObject);
                    storyLinkObject = null;
                    canvas.renderAll();
                    saveHistory();
                    document.getElementById('linkAddedIndicator').style.display = 'none';
                    EditorLog.links('info', 'Link eliminado', { url: linkUrl });
                }
            } catch (error) {
                EditorLog.links('error', 'Error eliminando link', {
                    error: error.message
                });
            }
        }

        function agregarLink() {
            try {
                const url = document.getElementById('linkUrl').value.trim();
                const text = document.getElementById('linkText').value.trim() || 'Ver mas';

                if (!url) {
                    EditorLog.links('warning', 'agregarLink llamado sin URL');
                    alert('Por favor ingresa una URL');
                    return;
                }

                // Validar URL
                let validUrl = url;
                if (!url.startsWith('http://') && !url.startsWith('https://')) {
                    validUrl = 'https://' + url;
                }

                try {
                    new URL(validUrl);
                } catch (e) {
                    EditorLog.links('warning', 'URL inválida', { url: validUrl });
                    alert('La URL no es valida');
                    return;
                }

            // Guardar configuración del link
            linkConfig.url = validUrl;
            linkConfig.text = text;

            // Eliminar link anterior si existe
            if (storyLinkObject) {
                canvas.remove(storyLinkObject);
                storyLinkObject = null;
            }

            // Calcular dimensiones
            const btnWidth = Math.max(text.length * 10 + 50, 100);
            const btnHeight = 40;
            const posX = canvas.width / 2;
            const posY = canvas.height - 100;
            const fillColor = getLinkFillColor();
            const textColor = getTextColorForBg(linkConfig.color);
            const style = linkConfig.style;
            const fontFamily = linkConfig.font;

            // Crear un Textbox con fondo simulado usando fabric.Rect + Text como objetos separados
            // pero agrupados visualmente. Para mejor interaccion, usamos un solo objeto Rect
            // y lo decoramos con texto encima usando toObject override

            // Enfoque simplificado: crear el boton como un Textbox con backgroundColor
            let linkObj;

            if (style === 'minimal') {
                // Estilo minimal: solo texto subrayado
                linkObj = new fabric.IText(text + ' →', {
                    left: posX,
                    top: posY,
                    originX: 'center',
                    originY: 'center',
                    fontSize: 16,
                    fontFamily: fontFamily,
                    fontWeight: 'bold',
                    fill: fillColor,
                    underline: true,
                    shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 4, offsetX: 0, offsetY: 2 }),
                    editable: false
                });
            } else {
                // Para otros estilos, crear Group pero con configuracion correcta
                const rx = style === 'pill' || style === 'glass' || style === 'swipe' ? btnHeight / 2 :
                           style === 'rounded' ? 10 :
                           style === 'outline-pill' ? btnHeight / 2 : 3;

                let bgFill, bgStroke = null, bgStrokeWidth = 0, labelColor = textColor;

                switch (style) {
                    case 'outline-pill':
                    case 'outline-square':
                        bgFill = 'transparent';
                        bgStroke = fillColor;
                        bgStrokeWidth = 3;
                        labelColor = fillColor;
                        break;
                    case 'glass':
                        bgFill = 'rgba(255, 255, 255, 0.25)';
                        bgStroke = 'rgba(255, 255, 255, 0.4)';
                        bgStrokeWidth = 1;
                        labelColor = '#ffffff';
                        break;
                    case 'swipe':
                        bgFill = 'rgba(0, 0, 0, 0.7)';
                        labelColor = '#ffffff';
                        break;
                    case 'gradient':
                        bgFill = fillColor; // Se vera como color solido en canvas
                        break;
                    default:
                        bgFill = fillColor;
                }

                const rect = new fabric.Rect({
                    width: btnWidth,
                    height: btnHeight,
                    rx: rx,
                    ry: rx,
                    fill: bgFill,
                    stroke: bgStroke,
                    strokeWidth: bgStrokeWidth,
                    originX: 'center',
                    originY: 'center',
                    shadow: new fabric.Shadow({ color: 'rgba(0,0,0,0.3)', blur: 8, offsetX: 0, offsetY: 4 })
                });

                const displayText = style === 'swipe' ? '↑ ' + text : text;
                const label = new fabric.Text(displayText, {
                    fontSize: style === 'swipe' ? 14 : 15,
                    fontFamily: fontFamily,
                    fontWeight: 'bold',
                    fill: labelColor,
                    originX: 'center',
                    originY: 'center'
                });

                // Crear grupo con configuracion para interaccion
                linkObj = new fabric.Group([rect, label], {
                    left: posX,
                    top: posY,
                    originX: 'center',
                    originY: 'center',
                    // Propiedades criticas para movimiento
                    subTargetCheck: false,
                    interactive: false
                });
            }

            // Propiedades importantes para visibilidad y movimiento
            linkObj.set({
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                lockScalingFlip: true,
                cornerColor: '#4682B4',
                cornerStyle: 'circle',
                borderColor: '#4682B4',
                borderScaleFactor: 2,
                transparentCorners: false,
                cornerSize: 12,
                padding: 10,
                // Asegurar que el objeto responda a eventos
                hoverCursor: 'move',
                moveCursor: 'move'
            });

            // Marcar como link para identificarlo
            linkObj.isStoryLink = true;
            linkObj.linkUrl = validUrl;
            linkObj.linkText = text;
            linkObj.linkStyle = style;
            linkObj.linkColor = linkConfig.color;
            linkObj.linkFont = fontFamily;

            // Agregar al canvas
            canvas.add(linkObj);

            // Forzar la seleccion del objeto
            canvas.discardActiveObject();
            canvas.setActiveObject(linkObj);
            canvas.bringToFront(linkObj);
            canvas.requestRenderAll();

            // Guardar referencia
            storyLinkObject = linkObj;
            saveHistory();

            // Mostrar indicador
            document.getElementById('linkAddedIndicator').style.display = 'block';

                EditorLog.links('info', 'Link agregado exitosamente', {
                    url: validUrl,
                    text: text,
                    style: linkConfig.style
                });
            } catch (error) {
                EditorLog.links('error', 'Error en agregarLink', {
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        // ========================================
        // AJUSTES DE IMAGEN/VIDEO (Voltear, Rotar, Filtros)
        // ========================================

        // Estado de ajustes
        let adjustState = {
            flipX: false,
            flipY: false,
            rotation: 0,
            filter: 'none',
            brightness: 0,
            contrast: 0,
            saturation: 0
        };

        function voltearHorizontal() {
            adjustState.flipX = !adjustState.flipX;
            aplicarTransformaciones();
        }

        function voltearVertical() {
            adjustState.flipY = !adjustState.flipY;
            aplicarTransformaciones();
        }

        function rotarImagen(grados) {
            adjustState.rotation = (adjustState.rotation + grados) % 360;
            aplicarTransformaciones();
        }

        function aplicarFiltro(filtro, elemento) {
            adjustState.filter = filtro;

            // Actualizar seleccion visual
            document.querySelectorAll('.filter-option').forEach(opt => opt.classList.remove('selected'));
            if (elemento) elemento.classList.add('selected');

            aplicarTransformaciones();
        }

        function ajustarBrillo(valor) {
            adjustState.brightness = parseInt(valor);
            document.getElementById('brightnessLabel').textContent = valor;
            aplicarTransformaciones();
        }

        function ajustarContraste(valor) {
            adjustState.contrast = parseInt(valor);
            document.getElementById('contrastLabel').textContent = valor;
            aplicarTransformaciones();
        }

        function ajustarSaturacion(valor) {
            adjustState.saturation = parseInt(valor);
            document.getElementById('saturationLabel').textContent = valor;
            aplicarTransformaciones();
        }

        function resetearAjustes() {
            adjustState = {
                flipX: false,
                flipY: false,
                rotation: 0,
                filter: 'none',
                brightness: 0,
                contrast: 0,
                saturation: 0
            };

            // Resetear sliders
            document.getElementById('brightnessSlider').value = 0;
            document.getElementById('contrastSlider').value = 0;
            document.getElementById('saturationSlider').value = 0;
            document.getElementById('brightnessLabel').textContent = '0';
            document.getElementById('contrastLabel').textContent = '0';
            document.getElementById('saturationLabel').textContent = '0';

            // Resetear seleccion de filtro
            document.querySelectorAll('.filter-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector('.filter-option')?.classList.add('selected');

            aplicarTransformaciones();
        }

        function aplicarTransformaciones() {
            const videoElement = document.getElementById('videoBackground');
            const bgImage = canvas.backgroundImage;

            // Construir filtro CSS
            let cssFilter = '';

            // Filtros predefinidos
            switch (adjustState.filter) {
                case 'grayscale':
                    cssFilter += 'grayscale(100%) ';
                    break;
                case 'sepia':
                    cssFilter += 'sepia(80%) ';
                    break;
                case 'vintage':
                    cssFilter += 'sepia(30%) contrast(90%) saturate(85%) ';
                    break;
                case 'cold':
                    cssFilter += 'saturate(80%) hue-rotate(180deg) brightness(95%) ';
                    break;
                case 'warm':
                    cssFilter += 'saturate(130%) sepia(20%) brightness(105%) ';
                    break;
                case 'contrast':
                    cssFilter += 'contrast(140%) ';
                    break;
                case 'brightness':
                    cssFilter += 'brightness(120%) contrast(95%) ';
                    break;
            }

            // Ajustes manuales
            if (adjustState.brightness !== 0) {
                cssFilter += `brightness(${100 + adjustState.brightness}%) `;
            }
            if (adjustState.contrast !== 0) {
                cssFilter += `contrast(${100 + adjustState.contrast}%) `;
            }
            if (adjustState.saturation !== 0) {
                cssFilter += `saturate(${100 + adjustState.saturation}%) `;
            }

            // Construir transformacion
            let transform = '';
            if (adjustState.flipX) transform += 'scaleX(-1) ';
            if (adjustState.flipY) transform += 'scaleY(-1) ';
            if (adjustState.rotation !== 0) transform += `rotate(${adjustState.rotation}deg) `;

            // Aplicar a video si esta activo
            if (isVideoMedia && videoElement) {
                videoElement.style.filter = cssFilter.trim() || 'none';
                videoElement.style.transform = transform.trim() || 'none';
            }

            // Aplicar a imagen de fondo del canvas si existe
            // IMPORTANTE: No aplicar transforms al contenedor de Fabric porque rompe la interactividad
            // En su lugar, aplicamos al lower-canvas que contiene la imagen de fondo
            if (bgImage && !isVideoMedia) {
                const lowerCanvas = document.querySelector('.canvas-wrapper .lower-canvas');
                if (lowerCanvas) {
                    lowerCanvas.style.filter = cssFilter.trim() || 'none';
                    lowerCanvas.style.transform = transform.trim() || 'none';
                    lowerCanvas.style.transformOrigin = 'center center';
                }
            }
        }

        // ========================================
        // UTILIDADES
        // ========================================

        // Escapar HTML para prevenir XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function onObjectSelected(e) {
            const obj = e.selected[0];
            if (obj && obj.type === 'i-text') {
                document.getElementById('textInput').value = obj.text;
            }
        }

        function onSelectionCleared() {
            // Opcional: limpiar inputs
        }

        function eliminarSeleccion() {
            const obj = canvas.getActiveObject();
            if (obj) {
                canvas.remove(obj);
                canvas.renderAll();
                saveHistory();
            }
        }

        function saveHistory() {
            historyIndex++;
            canvasHistory = canvasHistory.slice(0, historyIndex);
            canvasHistory.push(canvas.toJSON());
        }

        function deshacerCambio() {
            if (historyIndex > 0) {
                historyIndex--;
                canvas.loadFromJSON(canvasHistory[historyIndex], function() {
                    canvas.renderAll();
                });
            }
        }

        function seleccionarLado(lado, el) {
            selectedLado = lado;
            document.querySelectorAll('.lado-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
        }

        // ========================================
        // MODAL DE PUBLICACIÓN
        // ========================================
        let publishLado = 'LadoA';
        let publishEnFeed = false;

        function abrirModalPublicar() {
            // Resetear opciones
            publishLado = 'LadoA';
            publishEnFeed = false;

            // Resetear UI del modal
            document.querySelectorAll('.publish-lado-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.lado === 'LadoA') {
                    opt.classList.add('selected');
                }
            });
            document.getElementById('publishFeedToggle').classList.remove('active');

            // Mostrar modal
            document.getElementById('publishModalOverlay').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function cerrarModalPublicar(event) {
            // Si se hace click en el overlay (no en el modal), cerrar
            if (event && event.target !== event.currentTarget) return;

            document.getElementById('publishModalOverlay').classList.remove('active');
            document.body.style.overflow = '';
        }

        function seleccionarLadoPublish(lado, el) {
            publishLado = lado;
            document.querySelectorAll('.publish-lado-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
        }

        function togglePublicarEnFeed() {
            publishEnFeed = !publishEnFeed;
            const toggle = document.getElementById('publishFeedToggle');
            if (publishEnFeed) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
        }

        async function confirmarPublicacion() {
            // Cerrar modal
            cerrarModalPublicar();

            // Aplicar marca de agua si es LadoB
            if (publishLado === 'LadoB') {
                await aplicarMarcaAguaLadoB();
            }

            // Actualizar las variables globales usadas por publicarStory
            selectedLado = publishLado;
            document.getElementById('publicarEnFeed').checked = publishEnFeed;

            // Publicar
            await publicarStory();
        }

        async function aplicarMarcaAguaLadoB() {
            // Agregar marca de agua lateral "Lado B" si no existe
            const marcaExistente = canvas.getObjects().find(obj => obj.esMarcaAgua);
            if (marcaExistente) return;

            const marcaAgua = new fabric.Text('LADO B', {
                left: 20,
                top: canvas.height / 2,
                originY: 'center',
                fontFamily: 'Montserrat, sans-serif',
                fontSize: 14,
                fontWeight: '600',
                fill: 'rgba(255, 255, 255, 0.5)',
                angle: -90,
                selectable: false,
                evented: false,
                esMarcaAgua: true
            });

            canvas.add(marcaAgua);
            canvas.renderAll();
        }

        function habilitarBotonPublicar() {
            const publishBtn = document.getElementById('publishBtn');
            const mobilePublishBtn = document.getElementById('mobilePublishBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            if (publishBtn) publishBtn.disabled = false;
            if (mobilePublishBtn) mobilePublishBtn.disabled = false;
            if (downloadBtn) downloadBtn.disabled = false;
        }

        // Descargar el media actual (para verificar antes de publicar)
        async function descargarMedia() {
            if (!mediaFile) {
                alert('No hay contenido para descargar');
                return;
            }

            try {
                const extension = mediaFile.name.split('.').pop()?.toLowerCase() || (mediaType === 'video' ? 'mp4' : 'jpg');
                const fecha = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

                // SIEMPRE convertir videos BeatSync para compatibilidad con WhatsApp/iOS
                // El navegador genera videos con frame rate bajo (~9fps) que WhatsApp rechaza
                // FFmpeg re-encodea a 30fps con perfil compatible
                if (mediaType === 'video' && beatSyncConfig.generated) {
                    console.log('[Descarga] Video BeatSync detectado, convirtiendo a MP4 compatible...');
                    await descargarVideoConvertido();
                    return;
                }

                // Videos no-BeatSync WebM también necesitan conversión
                if (mediaType === 'video' && extension === 'webm') {
                    console.log('[Descarga] Video WebM detectado, convirtiendo a MP4 para compatibilidad...');
                    await descargarVideoConvertido();
                    return;
                }

                // Descarga normal (imágenes o videos externos que ya son MP4)
                const url = URL.createObjectURL(mediaFile);
                const nombreArchivo = `lado_${MODO_EDITOR}_${fecha}.${extension}`;

                const link = document.createElement('a');
                link.href = url;
                link.download = nombreArchivo;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                setTimeout(() => URL.revokeObjectURL(url), 1000);
            } catch (error) {
                console.error('Error al descargar:', error);
                logErrorToBackend('error', `Descarga directa falló: ${error.message}`, error.stack);
                alert('Error al descargar el archivo');
            }
        }

        // Convertir video a MP4 en el servidor y descargar
        async function descargarVideoConvertido() {
            const downloadBtn = document.getElementById('downloadBtn');
            const originalBtnHtml = downloadBtn ? downloadBtn.innerHTML : '';

            // Mostrar toast/notificación de que está preparando
            const toastId = mostrarToastDescarga('Preparando video MP4 para WhatsApp/iOS...');

            try {
                // Mostrar estado de conversión en el botón
                if (downloadBtn) {
                    downloadBtn.disabled = true;
                    downloadBtn.innerHTML = `
                        <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18" style="animation: spin 1s linear infinite;">
                            <circle cx="12" cy="12" r="10" stroke-dasharray="60" stroke-dashoffset="20"/>
                        </svg>
                    `;
                    downloadBtn.title = 'Convirtiendo a MP4...';
                }

                console.log('[Descarga] Enviando video para conversión a MP4...');

                // Crear FormData con el video
                const formData = new FormData();
                formData.append('video', mediaFile);

                // Enviar al servidor para conversión
                const response = await fetch('/Stories/ConvertirVideoMP4', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Error al convertir el video');
                }

                // Obtener el video convertido
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);

                console.log('[Descarga] Video convertido, tamaño:', (blob.size / 1024 / 1024).toFixed(2), 'MB');

                // Descargar
                const fecha = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const nombreArchivo = `lado_${MODO_EDITOR}_${fecha}.mp4`;

                const link = document.createElement('a');
                link.href = url;
                link.download = nombreArchivo;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                setTimeout(() => URL.revokeObjectURL(url), 1000);

            } catch (error) {
                console.error('[Descarga] Error convirtiendo video:', error);
                logErrorToBackend('error', `Descarga: Error convirtiendo video - ${error.message}`, error.stack);
                mostrarToastExito('Error al convertir. Descargando formato original...');

                // Fallback: descargar original
                try {
                    const url = URL.createObjectURL(mediaFile);
                    const extension = mediaFile.name.split('.').pop() || 'webm';
                    const fecha = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `lado_${MODO_EDITOR}_${fecha}.${extension}`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                } catch (fallbackError) {
                    logErrorToBackend('error', `Descarga fallback falló: ${fallbackError.message}`, fallbackError.stack);
                    mostrarToastExito('Error al descargar el video');
                }
            } finally {
                // Ocultar toast y restaurar botón
                ocultarToastDescarga(toastId);
                if (downloadBtn) {
                    downloadBtn.disabled = false;
                    downloadBtn.innerHTML = originalBtnHtml;
                    downloadBtn.title = 'Descargar antes de publicar';
                }
            }
        }

        // Toast para mostrar progreso de descarga
        function mostrarToastDescarga(mensaje) {
            // Remover toast anterior si existe
            const existingToast = document.getElementById('downloadToast');
            if (existingToast) existingToast.remove();

            const toast = document.createElement('div');
            toast.id = 'downloadToast';
            toast.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 14px 24px;
                border-radius: 12px;
                font-size: 14px;
                z-index: 10000;
                display: flex;
                align-items: center;
                gap: 12px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                animation: fadeInUp 0.3s ease;
            `;
            toast.innerHTML = `
                <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20" style="animation: spin 1s linear infinite;">
                    <circle cx="12" cy="12" r="10" stroke-dasharray="60" stroke-dashoffset="20"/>
                </svg>
                <span>${mensaje}</span>
            `;
            document.body.appendChild(toast);
            return 'downloadToast';
        }

        function ocultarToastDescarga(toastId) {
            const toast = document.getElementById(toastId);
            if (toast) {
                toast.style.animation = 'fadeOutDown 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }
        }

        // ========================================
        // SISTEMA DE LOGGING EXHAUSTIVO PARA EDITOR
        // Todos los errores se envían a /Admin/Logs
        // ========================================

        // Detectar dispositivo para contexto
        const editorDeviceInfo = {
            isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
            isAndroid: /Android/.test(navigator.userAgent),
            isMobile: /Mobile|Android|iPhone|iPad/.test(navigator.userAgent),
            browser: navigator.userAgent.match(/(Chrome|Safari|Firefox|Edge|Opera)/)?.[1] || 'Unknown',
            screenSize: `${window.screen.width}x${window.screen.height}`
        };

        // Enviar logs al backend para debugging - VERSIÓN MEJORADA
        async function logErrorToBackend(tipo, mensaje, detalle = null, subsistema = 'General') {
            try {
                // Construir detalle enriquecido
                const detalleEnriquecido = {
                    subsistema: subsistema,
                    dispositivo: editorDeviceInfo,
                    timestamp: new Date().toISOString(),
                    memoria: performance?.memory ? {
                        usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                        totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB'
                    } : null,
                    detalle: detalle
                };

                await fetch('/Admin/RegistrarLogFrontend', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tipo: tipo,
                        mensaje: `[Editor/${subsistema}] ${mensaje}`,
                        detalle: JSON.stringify(detalleEnriquecido, null, 2),
                        url: window.location.href
                    })
                });
            } catch (e) {
                console.error('Error enviando log:', e);
            }
        }

        // Helpers de logging por subsistema
        const EditorLog = {
            // Canvas y Fabric.js
            canvas: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Canvas'),

            // Audio y Música
            audio: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Audio'),

            // Carga de media (fotos/videos)
            media: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Media'),

            // Conversión HEIC/formatos
            conversion: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Conversion'),

            // GIFs
            gif: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'GIF'),

            // Efectos de video
            efectos: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Efectos'),

            // Texto y animaciones
            texto: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Texto'),

            // Herramientas (crop, pincel, borrador)
            tools: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Tools'),

            // Fondos y gradientes
            fondos: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Fondos'),

            // Plantillas
            plantillas: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Plantillas'),

            // Links
            links: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Links'),

            // BeatSync
            beatsync: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'BeatSync'),

            // Publicación
            publish: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Publish'),

            // Menciones/usuarios
            menciones: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Menciones'),

            // Partículas
            particles: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Particles'),

            // Descarga
            download: (tipo, msg, detalle) => logErrorToBackend(tipo, msg, detalle, 'Download')
        };

        // Capturar errores globales para BeatSync (más agresivo en iOS)
        const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent);
        window.addEventListener('error', function(e) {
            // En iOS capturar todos los errores, en otros solo los del Editor
            if (isIOSDevice || (e.filename && e.filename.includes('Editor')) || !e.filename) {
                logErrorToBackend('error', e.message || 'Error sin mensaje', `${e.filename || 'unknown'}:${e.lineno || 0}:${e.colno || 0}\n${e.error?.stack || 'Sin stack'}`);
            }
        });

        window.addEventListener('unhandledrejection', function(e) {
            logErrorToBackend('error', 'Unhandled Promise: ' + (e.reason?.message || String(e.reason)), e.reason?.stack || 'Sin stack');
        });

        // Capturar cuando la página va a cerrar (puede indicar crash en iOS)
        window.addEventListener('pagehide', function(e) {
            if (beatSyncPhotos && beatSyncPhotos.length > 0) {
                // Intentar log síncrono antes de cerrar usando Blob para content-type correcto
                const logData = new Blob([JSON.stringify({
                    tipo: 'warning',
                    mensaje: '[Stories/Editor] Página cerrada durante BeatSync',
                    detalle: JSON.stringify({
                        photosCount: beatSyncPhotos.length,
                        hasVideo: !!mediaFile,
                        persisted: e.persisted
                    }),
                    url: window.location.href
                })], { type: 'application/json' });
                navigator.sendBeacon('/Admin/RegistrarLogFrontend', logData);
            }
        });

        // Toast de éxito (no intrusivo)
        function mostrarToastExito(mensaje) {
            const existingToast = document.getElementById('successToast');
            if (existingToast) existingToast.remove();

            const toast = document.createElement('div');
            toast.id = 'successToast';
            toast.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                padding: 12px 20px;
                border-radius: 10px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                display: flex;
                align-items: center;
                gap: 10px;
                box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
                animation: fadeInUp 0.3s ease;
            `;
            toast.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="18" height="18">
                    <polyline points="20 6 9 17 4 12"/>
                </svg>
                <span>${mensaje}</span>
            `;
            document.body.appendChild(toast);

            // Auto-ocultar después de 3 segundos
            setTimeout(() => {
                toast.style.animation = 'fadeOutDown 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ========================================
        // PUBLICAR
        // ========================================
        async function publicarStory() {
            if (!mediaFile) {
                alert(MODO_EDITOR === 'reel' ? 'Debes subir una imagen o video para el reel' : 'Debes subir una imagen o video');
                return;
            }

            document.getElementById('loadingOverlay').classList.add('active');

            try {
                // Recopilar elementos del canvas
                const elementos = {
                    textos: [],
                    stickers: [],
                    dibujos: [],
                    menciones: [],
                    link: null,
                    canvasWidth: canvas.width,
                    canvasHeight: canvas.height
                };

                const mencionesIds = [];

                // Obtener dimensiones del canvas para convertir a porcentajes
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                // Función para convertir path de Fabric.js a string SVG
                function fabricPathToSvg(pathArray) {
                    if (!pathArray || !Array.isArray(pathArray)) return '';
                    return pathArray.map(cmd => {
                        if (Array.isArray(cmd)) {
                            return cmd.join(' ');
                        }
                        return cmd;
                    }).join(' ');
                }

                // Agregar marca de agua automáticamente
                const watermarkText = {
                    id: 9999,
                    texto: 'Creado con Ladoapp.com',
                    x: 50, // Centrado horizontalmente
                    y: 97, // Muy abajo (97% desde arriba)
                    fontSize: 10,
                    fontFamily: 'Poppins',
                    color: 'rgba(255, 255, 255, 0.6)',
                    backgroundColor: null,
                    rotation: 0,
                    isWatermark: true
                };
                elementos.textos.push(watermarkText);

                canvas.getObjects().forEach((obj, index) => {
                    // Convertir coordenadas a porcentajes
                    const xPercent = (obj.left / canvasWidth) * 100;
                    const yPercent = (obj.top / canvasHeight) * 100;

                    if (obj.type === 'i-text') {
                        if (obj.userId) {
                            // Es una mención
                            elementos.menciones.push({
                                id: index,
                                usuarioId: obj.userId,
                                username: obj.username || obj.text.replace('@@', ''),
                                x: xPercent,
                                y: yPercent,
                                fontSize: obj.fontSize,
                                color: obj.fill
                            });
                            mencionesIds.push(obj.userId);
                        } else {
                            // Es texto normal
                            elementos.textos.push({
                                id: index,
                                texto: obj.text,
                                x: xPercent,
                                y: yPercent,
                                fontSize: obj.fontSize,
                                fontFamily: obj.fontFamily,
                                color: obj.fill,
                                backgroundColor: obj.textBackgroundColor,
                                rotation: obj.angle
                            });
                        }
                    } else if (obj.type === 'text' && obj.text.length <= 4) {
                        // Es un sticker/emoji
                        elementos.stickers.push({
                            id: index,
                            valor: obj.text,
                            x: xPercent,
                            y: yPercent,
                            scale: obj.scaleX,
                            rotation: obj.angle
                        });
                    } else if (obj.type === 'path') {
                        // Es un dibujo - convertir path a SVG string
                        elementos.dibujos.push({
                            id: index,
                            pathData: fabricPathToSvg(obj.path),
                            color: obj.stroke,
                            strokeWidth: obj.strokeWidth
                        });
                    } else if (obj.isStoryLink) {
                        // Es un link
                        elementos.link = {
                            url: obj.linkUrl,
                            text: obj.linkText,
                            style: obj.linkStyle,
                            color: obj.linkColor || '#4682B4',
                            font: obj.linkFont || 'Poppins',
                            x: xPercent,
                            y: yPercent,
                            scale: obj.scaleX || 1,
                            rotation: obj.angle || 0
                        };
                    }
                });

                // Crear FormData
                const formData = new FormData();
                formData.append('archivo', mediaFile);
                formData.append('tipoLado', selectedLado);
                formData.append('elementosJson', JSON.stringify(elementos));
                formData.append('mencionesIds', mencionesIds.join(','));

                // Opción de publicar también en Feed
                const publicarEnFeedCheckbox = document.getElementById('publicarEnFeed');
                if (publicarEnFeedCheckbox && publicarEnFeedCheckbox.checked) {
                    formData.append('publicarEnFeed', 'true');
                }

                if (selectedMusic) {
                    formData.append('pistaMusicalId', selectedMusic.id);
                    formData.append('musicaTrimStart', musicTrimStart);
                    formData.append('musicaVolumen', musicVolume);
                }

                // Obtener token
                const tokenInput = document.querySelector('input[name="__RequestVerificationToken"]');
                if (tokenInput) {
                    formData.append('__RequestVerificationToken', tokenInput.value);
                }

                const response = await fetch(URL_CREAR, {
                    method: 'POST',
                    body: formData
                });

                // Verificar respuesta antes de parsear JSON
                const contentType = response.headers.get('content-type') || '';

                if (!response.ok) {
                    // Error HTTP - intentar obtener detalles
                    let errorDetail = `HTTP ${response.status}`;
                    try {
                        if (contentType.includes('application/json')) {
                            const errorData = await response.json();
                            errorDetail = errorData.message || errorData.error || errorDetail;
                        } else {
                            const textBody = await response.text();
                            errorDetail = textBody.substring(0, 200);
                        }
                    } catch (e) {}

                    logErrorToBackend('error', `Publicar: HTTP ${response.status}`, errorDetail);
                    mostrarToastExito(`Error al publicar (${response.status})`);
                    document.getElementById('loadingOverlay').classList.remove('active');
                    return;
                }

                // Parsear JSON de forma segura
                let data;
                try {
                    if (!contentType.includes('application/json')) {
                        throw new Error(`Respuesta inesperada: ${contentType}`);
                    }
                    data = await response.json();
                } catch (parseError) {
                    logErrorToBackend('error', `Publicar: Error parseando respuesta - ${parseError.message}`, `ContentType: ${contentType}`);
                    mostrarToastExito('Error en la respuesta del servidor');
                    document.getElementById('loadingOverlay').classList.remove('active');
                    return;
                }

                if (data.success) {
                    window.location.href = URL_REDIRECT;
                } else {
                    const errorMsg = data.message || 'Error al publicar';
                    logErrorToBackend('error', `Publicar: Server respondió error - ${errorMsg}`, JSON.stringify(data));
                    mostrarToastExito(errorMsg);
                    document.getElementById('loadingOverlay').classList.remove('active');
                }
            } catch (error) {
                console.error('[Publicar] Error:', error);
                logErrorToBackend('error', `Publicar: ${error.message}`, JSON.stringify({
                    stack: error.stack,
                    mediaType: mediaType,
                    mediaSize: mediaFile?.size,
                    mediaName: mediaFile?.name
                }));
                mostrarToastExito(MODO_EDITOR === 'reel' ? 'Error al publicar el reel' : 'Error al publicar');
                document.getElementById('loadingOverlay').classList.remove('active');
            }
        }

        function cancelarEditor() {
            const mensaje = MODO_EDITOR === 'reel' ? '¿Descartar reel?' : '¿Descartar historia?';
            if (confirm(mensaje)) {
                // Limpiar recursos de Beat Sync antes de salir
                if (typeof cleanupBeatSyncResources === 'function') {
                    cleanupBeatSyncResources();
                }
                window.location.href = '/Feed';
            }
        }

        // ========================================
        // CROP / RECORTE
        // ========================================
        let cropCanvas = null;
        let cropCtx = null;
        let cropImage = null;
        let cropAspect = 'free';
        let cropBox = { x: 50, y: 50, w: 200, h: 300 };
        let isDraggingCrop = false;
        let isResizingCrop = false;
        let activeHandle = null;
        let dragStart = { x: 0, y: 0 };

        function seleccionarAspectRatio(ratio, el) {
            cropConfig.aspectRatio = ratio;
            document.querySelectorAll('#cropOptions .adjust-btn').forEach(btn => btn.classList.remove('active'));
            el.classList.add('active');
        }

        function ajustarZoomCrop(value) {
            cropConfig.zoom = parseInt(value);
            if (canvas.backgroundImage) {
                const bgImg = canvas.backgroundImage;
                const baseScale = Math.max(canvas.width / bgImg.width, canvas.height / bgImg.height);
                const newScale = baseScale * (value / 100);
                bgImg.scale(newScale);
                bgImg.set({
                    left: canvas.width / 2,
                    top: canvas.height / 2
                });
                canvas.renderAll();
                saveHistory();
            }
        }

        function abrirRecortador() {
            if (!mediaUrl) {
                alert('Primero sube una imagen o video');
                return;
            }

            const overlay = document.getElementById('cropOverlay');
            const container = document.getElementById('cropContainer');
            overlay.classList.add('active');

            // Inicializar canvas de crop
            cropCanvas = document.getElementById('cropCanvas');
            cropCtx = cropCanvas.getContext('2d');

            const containerRect = container.getBoundingClientRect();
            cropCanvas.width = containerRect.width;
            cropCanvas.height = containerRect.height - 20;

            if (isVideoMedia) {
                // Capturar frame del video
                const video = document.getElementById('videoBackground');
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0);
                cropImage = new Image();
                cropImage.onload = () => dibujarCropPreview();
                cropImage.src = tempCanvas.toDataURL();
            } else {
                cropImage = new Image();
                cropImage.onload = () => dibujarCropPreview();
                cropImage.src = mediaUrl;
            }

            // Inicializar crop box
            initCropBox();
            setupCropEvents();
        }

        function initCropBox() {
            const box = document.getElementById('cropBox');
            const containerRect = document.getElementById('cropContainer').getBoundingClientRect();

            // Calcular tamaño inicial del crop box (80% del container)
            const boxW = containerRect.width * 0.7;
            const boxH = containerRect.height * 0.7;

            cropBox = {
                x: (containerRect.width - boxW) / 2,
                y: (containerRect.height - boxH) / 2,
                w: boxW,
                h: boxH
            };

            actualizarCropBox();
        }

        function actualizarCropBox() {
            const box = document.getElementById('cropBox');
            box.style.left = cropBox.x + 'px';
            box.style.top = cropBox.y + 'px';
            box.style.width = cropBox.w + 'px';
            box.style.height = cropBox.h + 'px';
        }

        function dibujarCropPreview() {
            if (!cropImage || !cropCtx) return;

            const scale = Math.min(
                cropCanvas.width / cropImage.width,
                cropCanvas.height / cropImage.height
            ) * 0.9;

            const drawW = cropImage.width * scale;
            const drawH = cropImage.height * scale;
            const drawX = (cropCanvas.width - drawW) / 2;
            const drawY = (cropCanvas.height - drawH) / 2;

            cropCtx.fillStyle = '#000';
            cropCtx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
            cropCtx.drawImage(cropImage, drawX, drawY, drawW, drawH);
        }

        function setupCropEvents() {
            const box = document.getElementById('cropBox');
            const handles = box.querySelectorAll('.crop-handle');

            box.addEventListener('mousedown', startDragCrop);
            box.addEventListener('touchstart', startDragCrop);

            handles.forEach(handle => {
                handle.addEventListener('mousedown', startResizeCrop);
                handle.addEventListener('touchstart', startResizeCrop);
            });

            document.addEventListener('mousemove', moveCrop);
            document.addEventListener('touchmove', moveCrop);
            document.addEventListener('mouseup', endCrop);
            document.addEventListener('touchend', endCrop);
        }

        function startDragCrop(e) {
            if (e.target.classList.contains('crop-handle')) return;
            e.preventDefault();
            isDraggingCrop = true;
            const pos = getEventPos(e);
            dragStart = { x: pos.x - cropBox.x, y: pos.y - cropBox.y };
        }

        function startResizeCrop(e) {
            e.preventDefault();
            e.stopPropagation();
            isResizingCrop = true;
            activeHandle = e.target.dataset.handle;
            const pos = getEventPos(e);
            dragStart = { x: pos.x, y: pos.y };
        }

        function moveCrop(e) {
            if (!isDraggingCrop && !isResizingCrop) return;

            const container = document.getElementById('cropContainer');
            const containerRect = container.getBoundingClientRect();
            const pos = getEventPos(e);

            if (isDraggingCrop) {
                cropBox.x = Math.max(0, Math.min(containerRect.width - cropBox.w, pos.x - dragStart.x));
                cropBox.y = Math.max(0, Math.min(containerRect.height - cropBox.h, pos.y - dragStart.y));
            } else if (isResizingCrop) {
                const dx = pos.x - dragStart.x;
                const dy = pos.y - dragStart.y;

                switch (activeHandle) {
                    case 'br':
                        cropBox.w = Math.max(50, cropBox.w + dx);
                        cropBox.h = Math.max(50, cropBox.h + dy);
                        break;
                    case 'bl':
                        cropBox.x += dx;
                        cropBox.w = Math.max(50, cropBox.w - dx);
                        cropBox.h = Math.max(50, cropBox.h + dy);
                        break;
                    case 'tr':
                        cropBox.y += dy;
                        cropBox.w = Math.max(50, cropBox.w + dx);
                        cropBox.h = Math.max(50, cropBox.h - dy);
                        break;
                    case 'tl':
                        cropBox.x += dx;
                        cropBox.y += dy;
                        cropBox.w = Math.max(50, cropBox.w - dx);
                        cropBox.h = Math.max(50, cropBox.h - dy);
                        break;
                }
                dragStart = { x: pos.x, y: pos.y };
            }

            actualizarCropBox();
        }

        function endCrop() {
            isDraggingCrop = false;
            isResizingCrop = false;
            activeHandle = null;
        }

        function getEventPos(e) {
            const container = document.getElementById('cropContainer');
            const rect = container.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function setCropAspect(aspect, el) {
            cropAspect = aspect;
            document.querySelectorAll('.aspect-btn').forEach(b => b.classList.remove('active'));
            el.classList.add('active');

            // Ajustar cropBox según aspect ratio
            const container = document.getElementById('cropContainer');
            const containerRect = container.getBoundingClientRect();

            if (aspect !== 'free') {
                const [w, h] = aspect.split(':').map(Number);
                const ratio = w / h;
                const maxW = containerRect.width * 0.8;
                const maxH = containerRect.height * 0.8;

                if (maxW / ratio <= maxH) {
                    cropBox.w = maxW;
                    cropBox.h = maxW / ratio;
                } else {
                    cropBox.h = maxH;
                    cropBox.w = maxH * ratio;
                }

                cropBox.x = (containerRect.width - cropBox.w) / 2;
                cropBox.y = (containerRect.height - cropBox.h) / 2;
                actualizarCropBox();
            }
        }

        function cancelarCrop() {
            document.getElementById('cropOverlay').classList.remove('active');
            document.removeEventListener('mousemove', moveCrop);
            document.removeEventListener('touchmove', moveCrop);
            document.removeEventListener('mouseup', endCrop);
            document.removeEventListener('touchend', endCrop);
        }

        function aplicarCrop() {
            try {
                if (!cropImage) {
                    EditorLog.tools('warning', 'aplicarCrop llamado sin imagen');
                    cancelarCrop();
                    return;
                }

                EditorLog.tools('info', 'Iniciando recorte de imagen', {
                    originalSize: `${cropImage.width}x${cropImage.height}`
                });

                // Calcular las coordenadas de recorte en la imagen original
                const scale = Math.min(
                    cropCanvas.width / cropImage.width,
                    cropCanvas.height / cropImage.height
                ) * 0.9;

                const drawW = cropImage.width * scale;
                const drawH = cropImage.height * scale;
                const drawX = (cropCanvas.width - drawW) / 2;
                const drawY = (cropCanvas.height - drawH) / 2;

                // Convertir cropBox a coordenadas de la imagen original
                const srcX = (cropBox.x - drawX) / scale;
                const srcY = (cropBox.y - drawY) / scale;
                const srcW = cropBox.w / scale;
                const srcH = cropBox.h / scale;

                // Crear canvas temporal para el recorte
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = srcW;
                tempCanvas.height = srcH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);

                // Actualizar la imagen de fondo del canvas principal
                const croppedUrl = tempCanvas.toDataURL('image/jpeg', 0.9);

                fabric.Image.fromURL(croppedUrl, function(img) {
                    try {
                        const scaleToFit = Math.max(
                            canvas.width / img.width,
                            canvas.height / img.height
                        );
                        img.scale(scaleToFit);
                        img.set({
                            left: canvas.width / 2,
                            top: canvas.height / 2,
                            originX: 'center',
                            originY: 'center',
                            selectable: false,
                            evented: false
                        });
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                        saveHistory();
                        EditorLog.tools('info', 'Recorte aplicado exitosamente', {
                            cropSize: `${Math.round(srcW)}x${Math.round(srcH)}`,
                            scale: scaleToFit.toFixed(2)
                        });
                    } catch (innerError) {
                        EditorLog.tools('error', 'Error aplicando imagen recortada', {
                            error: innerError.message
                        });
                    }
                });

                cancelarCrop();
            } catch (error) {
                EditorLog.tools('error', 'Error en aplicarCrop', {
                    error: error.message,
                    stack: error.stack
                });
                cancelarCrop();
            }
        }

        // ========================================
        // FONDOS / BACKGROUNDS
        // ========================================
        function aplicarFondoColor(color, el) {
            try {
                document.querySelectorAll('.bg-color-option, .bg-option').forEach(opt => opt.classList.remove('selected'));
                el.classList.add('selected');

                backgroundConfig.type = 'color';
                backgroundConfig.value = color;

                // Aplicar al canvas
                canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
                canvas.backgroundColor = color;
                canvas.renderAll();
                saveHistory();

                // Habilitar botón publicar si no hay media
                document.getElementById('uploadOverlay').classList.add('hidden');
                habilitarBotonPublicar();

                EditorLog.fondos('info', 'Fondo de color aplicado', { color });
            } catch (error) {
                EditorLog.fondos('error', 'Error aplicando fondo de color', {
                    color,
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        function aplicarFondoGradiente(gradient, el) {
            try {
                document.querySelectorAll('.bg-color-option, .bg-option').forEach(opt => opt.classList.remove('selected'));
                el.classList.add('selected');

                backgroundConfig.type = 'gradient';
                backgroundConfig.value = gradient;

                // Crear gradiente como imagen
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Parsear el gradiente y dibujarlo
                const gradientMatch = gradient.match(/linear-gradient\((\d+)deg,\s*(.+)\)/);
                if (gradientMatch) {
                    const angle = parseInt(gradientMatch[1]);
                    const colors = gradientMatch[2].split(',').map(c => c.trim());

                    // Calcular puntos del gradiente
                    const rad = (angle - 90) * Math.PI / 180;
                    const x1 = tempCanvas.width / 2 - Math.cos(rad) * tempCanvas.width;
                    const y1 = tempCanvas.height / 2 - Math.sin(rad) * tempCanvas.height;
                    const x2 = tempCanvas.width / 2 + Math.cos(rad) * tempCanvas.width;
                    const y2 = tempCanvas.height / 2 + Math.sin(rad) * tempCanvas.height;

                    const grad = tempCtx.createLinearGradient(x1, y1, x2, y2);

                    colors.forEach(colorStop => {
                        const match = colorStop.match(/(#[a-fA-F0-9]{6}|rgba?\([^)]+\))\s*(\d+)?%?/);
                        if (match) {
                            const color = match[1];
                            const stop = match[2] ? parseInt(match[2]) / 100 : colors.indexOf(colorStop) / (colors.length - 1);
                            grad.addColorStop(stop, color);
                        }
                    });

                    tempCtx.fillStyle = grad;
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                }

                fabric.Image.fromURL(tempCanvas.toDataURL(), function(img) {
                    try {
                        img.set({
                            left: 0,
                            top: 0,
                            originX: 'left',
                            originY: 'top',
                            selectable: false,
                            evented: false
                        });
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                        saveHistory();
                        EditorLog.fondos('info', 'Fondo de gradiente aplicado');
                    } catch (innerError) {
                        EditorLog.fondos('error', 'Error aplicando imagen de gradiente', {
                            error: innerError.message
                        });
                    }
                });

                // Habilitar botón publicar
                document.getElementById('uploadOverlay').classList.add('hidden');
                habilitarBotonPublicar();
            } catch (error) {
                EditorLog.fondos('error', 'Error en aplicarFondoGradiente', {
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        function aplicarBlurFondo(value) {
            try {
                backgroundConfig.blur = parseInt(value);

                const wrapper = document.getElementById('canvasWrapper');
                const bgImage = canvas.backgroundImage;

                if (bgImage && value > 0) {
                    // Aplicar blur al background image
                    bgImage.filters = [new fabric.Image.filters.Blur({ blur: value / 100 })];
                    bgImage.applyFilters();
                    canvas.renderAll();
                    EditorLog.fondos('info', 'Blur aplicado', { value });
                } else if (bgImage) {
                    bgImage.filters = [];
                    bgImage.applyFilters();
                    canvas.renderAll();
                }
            } catch (error) {
                EditorLog.fondos('error', 'Error aplicando blur', {
                    value,
                    error: error.message
                });
            }
        }

        // ========================================
        // PLANTILLAS / TEMPLATES
        // ========================================
        function renderizarPlantillas(category) {
            const grid = document.getElementById('templatesGrid');
            grid.innerHTML = '';

            const filteredTemplates = category === 'all'
                ? templates
                : templates.filter(t => t.category === category);

            filteredTemplates.forEach(template => {
                const item = document.createElement('div');
                item.className = 'template-item';
                item.onclick = () => aplicarPlantilla(template);

                const preview = document.createElement('div');
                preview.className = 'template-preview';
                preview.style.background = template.bg;

                // Agregar textos de preview con tamaños proporcionales
                template.texts.forEach(t => {
                    const span = document.createElement('span');
                    span.textContent = t.text;
                    span.style.fontFamily = t.font;
                    // Escalar el tamaño para que se vea bien en preview (dividir por 2.2)
                    const scaledSize = Math.max(10, Math.round(t.size / 2.2));
                    span.style.fontSize = scaledSize + 'px';
                    span.style.color = t.color;
                    span.style.fontWeight = t.font.includes('Anton') || t.font.includes('Bebas') || t.font.includes('Oswald') ? '400' : '600';
                    if (t.shadow) {
                        // Escalar también el shadow
                        span.style.textShadow = t.shadow.replace(/(\d+)px/g, (match, num) => Math.round(parseInt(num) / 2) + 'px');
                    }
                    preview.appendChild(span);
                });

                const name = document.createElement('div');
                name.className = 'template-name';
                name.textContent = template.name;

                item.appendChild(preview);
                item.appendChild(name);
                grid.appendChild(item);
            });
        }

        function filtrarPlantillas(category, el) {
            document.querySelectorAll('.template-tab').forEach(tab => tab.classList.remove('active'));
            el.classList.add('active');
            renderizarPlantillas(category);
        }

        function aplicarPlantilla(template) {
            try {
                EditorLog.plantillas('info', 'Aplicando plantilla', {
                    name: template.name,
                    category: template.category,
                    textsCount: template.texts?.length || 0
                });

                // Limpiar canvas
                canvas.clear();

                // Aplicar fondo
                if (template.bg.startsWith('linear-gradient') || template.bg.startsWith('#')) {
                    if (template.bg.startsWith('linear-gradient')) {
                        // Crear gradiente como imagen
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = canvas.width;
                        tempCanvas.height = canvas.height;
                        const tempCtx = tempCanvas.getContext('2d');

                        const gradientMatch = template.bg.match(/linear-gradient\((\d+)deg,\s*(.+)\)/);
                        if (gradientMatch) {
                            const angle = parseInt(gradientMatch[1]);
                            const colors = gradientMatch[2].split(',').map(c => c.trim());

                            const rad = (angle - 90) * Math.PI / 180;
                            const x1 = tempCanvas.width / 2 - Math.cos(rad) * tempCanvas.width;
                            const y1 = tempCanvas.height / 2 - Math.sin(rad) * tempCanvas.height;
                            const x2 = tempCanvas.width / 2 + Math.cos(rad) * tempCanvas.width;
                            const y2 = tempCanvas.height / 2 + Math.sin(rad) * tempCanvas.height;

                            const grad = tempCtx.createLinearGradient(x1, y1, x2, y2);

                            colors.forEach((colorStop, idx) => {
                                const match = colorStop.match(/(#[a-fA-F0-9]{6}|rgba?\([^)]+\))\s*(\d+)?%?/);
                                if (match) {
                                    const color = match[1];
                                    const stop = match[2] ? parseInt(match[2]) / 100 : idx / (colors.length - 1);
                                    grad.addColorStop(stop, color);
                                }
                            });

                            tempCtx.fillStyle = grad;
                            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                        }

                        fabric.Image.fromURL(tempCanvas.toDataURL(), function(img) {
                            try {
                                img.set({
                                    left: 0,
                                    top: 0,
                                    originX: 'left',
                                    originY: 'top',
                                    selectable: false,
                                    evented: false
                                });
                                canvas.setBackgroundImage(img, function() {
                                    agregarTextosPlantilla(template);
                                });
                            } catch (innerError) {
                                EditorLog.plantillas('error', 'Error aplicando fondo de plantilla', {
                                    error: innerError.message
                                });
                            }
                        });
                    } else {
                        canvas.backgroundColor = template.bg;
                        canvas.renderAll();
                        agregarTextosPlantilla(template);
                    }
                }

                // Ocultar overlay y habilitar publicar
                document.getElementById('uploadOverlay').classList.add('hidden');
                habilitarBotonPublicar();

                // Cerrar panel en móvil
                if (window.innerWidth <= 768) {
                    cerrarPanelOpciones();
                }

                EditorLog.plantillas('info', 'Plantilla aplicada exitosamente', { name: template.name });
            } catch (error) {
                EditorLog.plantillas('error', 'Error en aplicarPlantilla', {
                    template: template?.name,
                    error: error.message,
                    stack: error.stack
                });
            }
        }

        function agregarTextosPlantilla(template) {
            template.texts.forEach(t => {
                const textObj = new fabric.IText(t.text, {
                    left: canvas.width / 2,
                    top: (t.y / 100) * canvas.height,
                    originX: 'center',
                    originY: 'center',
                    fontFamily: t.font,
                    fontSize: t.size,
                    fill: t.color,
                    selectable: true,
                    evented: true,
                    hasControls: true,
                    hasBorders: true,
                    cornerColor: '#4682B4',
                    cornerStyle: 'circle',
                    borderColor: '#4682B4',
                    transparentCorners: false,
                    cornerSize: 10
                });

                if (t.shadow) {
                    textObj.set('shadow', new fabric.Shadow({
                        color: t.shadow.split(',')[0].match(/#[a-fA-F0-9]+/)?.[0] || '#000',
                        blur: 20,
                        offsetX: 0,
                        offsetY: 0
                    }));
                }

                canvas.add(textObj);
            });

            canvas.renderAll();
            saveHistory();
        }

        // ========================================
        // BEAT SYNC - Video musical sincronizado (v3.0 - Optimizado)
        // ========================================
        const beatSyncConfig = {
            audioContext: null,
            audioBuffer: null,
            audioFile: null,
            photos: [],
            beats: [],
            isPlaying: false,
            isPaused: false,
            previewAnimationId: null,
            currentPhotoIndex: 0,
            currentTime: 0,
            startTime: 0,
            pausedAt: 0,
            audioSource: null,
            mode: 'auto',
            preloadedImages: [],
            duration: 30,
            trimStart: 0,
            trimEnd: 30,
            // Audio cutter visual
            cutterPlaying: false,
            cutterSource: null,
            cutterAnimationId: null,
            isDraggingHandle: false,
            dragHandle: null,
            // ========== OPTIMIZACIONES v3.0 ==========
            // Caché de imágenes decodificadas (ImageBitmap)
            cachedImages: [],
            imagesCacheValid: false,
            // Caché de análisis spectral (evita recálculo completo)
            spectralFluxCache: null,
            spectralFluxCacheValid: false,
            // FFT twiddle factors precalculados
            fftTwiddleFactors: null,
            fftSize: 2048,
            // Marca de agua pre-renderizada
            watermarkCanvas: null,
            // Beats manuales (agregados/eliminados por usuario)
            manualBeatsAdded: [],
            manualBeatsRemoved: [],
            // Posiciones de beats en waveform (para clicks)
            beatPositions: [],
            // Flag para evitar duplicación de event listeners
            waveformClicksSetup: false,
            dragHandlesSetup: false,
            // ========== AUDIO PLAYER PERSISTENTE (iOS compatible) ==========
            audioPlayer: null, // HTMLAudioElement persistente
            audioPlayerReady: false,
            audioUrl: null,
            audioUrlIsBlob: false,
            // ========== PARTÍCULAS v1.0 ==========
            particleType: 'none',
            particleIntensity: 5,
            particleSystem: null
        };

        // Crear audio player persistente para BeatSync (mejor compatibilidad iOS)
        function initBeatSyncAudioPlayer() {
            if (beatSyncConfig.audioPlayer) return beatSyncConfig.audioPlayer;

            const audio = new Audio();
            audio.preload = 'auto';
            audio.volume = 0.8;

            // Eventos para debugging
            audio.oncanplaythrough = () => {
                beatSyncConfig.audioPlayerReady = true;
                console.log('BeatSync audio player ready');
            };

            audio.onerror = (e) => {
                console.error('BeatSync audio error:', e);
            };

            beatSyncConfig.audioPlayer = audio;
            return audio;
        }

        // Inicializar audio player en primer interacción con BeatSync
        function ensureBeatSyncAudioPlayer() {
            if (!beatSyncConfig.audioPlayer) {
                initBeatSyncAudioPlayer();
            }
            return beatSyncConfig.audioPlayer;
        }

        // ========================================
        // SISTEMA DE PARTÍCULAS
        // ========================================
        class ParticleSystem {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.particles = [];
                this.lastBeatTime = 0;
            }

            // Emitir partículas en un beat
            emitOnBeat(type, intensity, beatTime) {
                // Evitar emitir partículas demasiado seguidas
                if (beatTime - this.lastBeatTime < 0.1) return;
                this.lastBeatTime = beatTime;

                const count = Math.floor(intensity * 8); // 8-80 partículas según intensidad

                for (let i = 0; i < count; i++) {
                    const particle = this.createParticle(type, intensity);
                    if (particle) this.particles.push(particle);
                }
            }

            // Crear una partícula según el tipo
            createParticle(type, intensity) {
                const baseVelocity = 2 + intensity * 0.5;
                const particle = {
                    x: Math.random() * this.width,
                    y: -20,
                    vx: (Math.random() - 0.5) * baseVelocity * 2,
                    vy: Math.random() * baseVelocity + 1,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.02,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    scale: 0.5 + Math.random() * 0.5,
                    type: type
                };

                switch (type) {
                    case 'confetti':
                        particle.color = this.randomColor(['#ff6b6b', '#4ecdc4', '#45b7d1', '#fed766', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3']);
                        particle.width = 8 + Math.random() * 8;
                        particle.height = 4 + Math.random() * 4;
                        particle.vx *= 1.5;
                        break;
                    case 'hearts':
                        particle.emoji = ['❤️', '💕', '💗', '💖', '💝'][Math.floor(Math.random() * 5)];
                        particle.size = 16 + Math.random() * 16;
                        particle.vy *= 0.6; // Caen más lento
                        break;
                    case 'stars':
                        particle.emoji = ['⭐', '🌟', '✨', '💫'][Math.floor(Math.random() * 4)];
                        particle.size = 14 + Math.random() * 14;
                        particle.twinkle = Math.random() * Math.PI * 2;
                        break;
                    case 'sparkles':
                        particle.color = this.randomColor(['#ffd700', '#fff', '#ffec8b', '#fffacd']);
                        particle.size = 3 + Math.random() * 5;
                        particle.twinkle = Math.random() * Math.PI * 2;
                        particle.decay *= 1.5; // Desaparecen más rápido
                        break;
                    case 'fire':
                        particle.color = this.randomColor(['#ff4500', '#ff6347', '#ff8c00', '#ffa500', '#ffcc00']);
                        particle.size = 8 + Math.random() * 12;
                        particle.y = this.height + 20; // Nacen desde abajo
                        particle.vy = -(Math.random() * baseVelocity + 2); // Suben
                        particle.vx *= 0.3;
                        break;
                    case 'bubbles':
                        particle.color = 'rgba(135, 206, 250, 0.6)';
                        particle.size = 10 + Math.random() * 20;
                        particle.y = this.height + 20;
                        particle.vy = -(Math.random() * 2 + 1);
                        particle.vx = Math.sin(particle.x * 0.02) * 0.5;
                        particle.wobble = Math.random() * Math.PI * 2;
                        break;
                    case 'snow':
                        particle.color = '#fff';
                        particle.size = 4 + Math.random() * 6;
                        particle.vy *= 0.3; // Caen muy lento
                        particle.wobble = Math.random() * Math.PI * 2;
                        particle.decay *= 0.5; // Duran más
                        break;
                    case 'petals':
                        particle.emoji = ['🌸', '🌺', '💮', '🏵️'][Math.floor(Math.random() * 4)];
                        particle.size = 14 + Math.random() * 10;
                        particle.vy *= 0.4;
                        particle.vx = (Math.random() - 0.5) * 3;
                        particle.wobble = Math.random() * Math.PI * 2;
                        break;
                    default:
                        return null;
                }

                return particle;
            }

            randomColor(colors) {
                return colors[Math.floor(Math.random() * colors.length)];
            }

            // Actualizar todas las partículas
            update(deltaTime = 1/60) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];

                    // Física básica
                    p.x += p.vx;
                    p.y += p.vy;
                    p.rotation += p.rotationSpeed || 0;
                    p.life -= p.decay;

                    // Gravedad suave para algunos tipos
                    if (['confetti', 'hearts', 'stars', 'petals', 'snow'].includes(p.type)) {
                        p.vy += 0.05; // Gravedad
                    }

                    // Wobble para burbujas y nieve
                    if (p.wobble !== undefined) {
                        p.wobble += 0.1;
                        p.x += Math.sin(p.wobble) * 0.5;
                    }

                    // Twinkle para estrellas y brillos
                    if (p.twinkle !== undefined) {
                        p.twinkle += 0.2;
                    }

                    // Eliminar partículas muertas
                    if (p.life <= 0 || p.y > this.height + 50 || p.y < -50 || p.x < -50 || p.x > this.width + 50) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            // Dibujar todas las partículas
            draw(ctx) {
                for (const p of this.particles) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(1, p.life);
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.scale(p.scale, p.scale);

                    switch (p.type) {
                        case 'confetti':
                            ctx.fillStyle = p.color;
                            ctx.fillRect(-p.width / 2, -p.height / 2, p.width, p.height);
                            break;

                        case 'hearts':
                        case 'stars':
                        case 'petals':
                            ctx.font = `${p.size}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            if (p.twinkle !== undefined) {
                                ctx.globalAlpha *= 0.5 + Math.sin(p.twinkle) * 0.5;
                            }
                            ctx.fillText(p.emoji, 0, 0);
                            break;

                        case 'sparkles':
                            const sparkleAlpha = p.twinkle !== undefined ? (0.5 + Math.sin(p.twinkle) * 0.5) : 1;
                            ctx.globalAlpha *= sparkleAlpha;
                            ctx.fillStyle = p.color;
                            // Dibujar estrella de 4 puntas
                            this.drawSparkle(ctx, 0, 0, p.size);
                            break;

                        case 'fire':
                            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, p.size);
                            gradient.addColorStop(0, p.color);
                            gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                            ctx.fill();
                            break;

                        case 'bubbles':
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            // Reflejo
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.beginPath();
                            ctx.arc(-p.size / 4, -p.size / 4, p.size / 6, 0, Math.PI * 2);
                            ctx.fill();
                            break;

                        case 'snow':
                            ctx.fillStyle = p.color;
                            ctx.shadowColor = '#fff';
                            ctx.shadowBlur = 5;
                            ctx.beginPath();
                            ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                    }

                    ctx.restore();
                }
            }

            // Dibujar un brillo de 4 puntas
            drawSparkle(ctx, x, y, size) {
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI / 2);
                    const innerRadius = size * 0.2;
                    const outerRadius = size;

                    if (i === 0) {
                        ctx.moveTo(x + Math.cos(angle) * outerRadius, y + Math.sin(angle) * outerRadius);
                    } else {
                        ctx.lineTo(x + Math.cos(angle) * outerRadius, y + Math.sin(angle) * outerRadius);
                    }

                    const midAngle = angle + Math.PI / 4;
                    ctx.lineTo(x + Math.cos(midAngle) * innerRadius, y + Math.sin(midAngle) * innerRadius);
                }
                ctx.closePath();
                ctx.fill();
            }

            // Limpiar todas las partículas
            clear() {
                this.particles = [];
                this.lastBeatTime = 0;
            }

            // Obtener cantidad de partículas activas
            get count() {
                return this.particles.length;
            }
        }

        // Funciones de UI para partículas
        function seleccionarParticula(tipo, element) {
            // Actualizar selección visual
            document.querySelectorAll('.beatsync-particle-option').forEach(el => {
                el.classList.remove('selected');
            });
            element.classList.add('selected');

            // Guardar configuración
            beatSyncConfig.particleType = tipo;

            // Mostrar/ocultar configuración de intensidad
            const configPanel = document.getElementById('beatsyncParticlesConfig');
            if (tipo === 'none') {
                configPanel.classList.remove('active');
            } else {
                configPanel.classList.add('active');
            }

            console.log('Partícula seleccionada:', tipo);
        }

        function updateParticleIntensityLabel(value) {
            document.getElementById('beatsyncParticleIntensityValue').textContent = value;
            beatSyncConfig.particleIntensity = parseInt(value);
        }

        // ========================================
        // INICIALIZAR OPTIMIZACIONES
        // ========================================
        function initBeatSyncOptimizations() {
            // Pre-calcular twiddle factors para FFT
            const n = beatSyncConfig.fftSize;
            beatSyncConfig.fftTwiddleFactors = {
                cos: new Float32Array(n / 2),
                sin: new Float32Array(n / 2)
            };
            for (let k = 0; k < n / 2; k++) {
                const angle = -2 * Math.PI * k / n;
                beatSyncConfig.fftTwiddleFactors.cos[k] = Math.cos(angle);
                beatSyncConfig.fftTwiddleFactors.sin[k] = Math.sin(angle);
            }

            // Pre-renderizar marca de agua
            preRenderWatermark();
        }

        // Pre-renderizar marca de agua para reutilizar (VERTICAL IZQUIERDA)
        function preRenderWatermark() {
            const width = 1080;
            const height = 1920;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            const text = 'Creado con Ladoapp.com';
            const fontSize = Math.round(width * 0.024); // Un poco más pequeño para vertical

            ctx.font = `500 ${fontSize}px 'Poppins', sans-serif`;

            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize;
            const padding = fontSize * 0.4;

            // Posición vertical izquierda (centrado verticalmente)
            const x = width * 0.03; // 3% desde el borde izquierdo
            const y = height / 2;   // Centro vertical

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(-Math.PI / 2); // Rotar 90° antihorario

            // El texto ahora está rotado, textWidth es la "altura" visual
            // Fondo semitransparente (pill vertical)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            const bgX = -textWidth / 2 - padding;
            const bgY = -textHeight / 2 - padding / 2;
            const bgWidth = textWidth + padding * 2;
            const bgHeight = textHeight + padding;
            const bgRadius = fontSize * 0.3;

            ctx.beginPath();
            ctx.roundRect(bgX, bgY, bgWidth, bgHeight, bgRadius);
            ctx.fill();

            // Texto centrado
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);

            ctx.restore();

            beatSyncConfig.watermarkCanvas = canvas;
        }

        // Inicializar al cargar
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initBeatSyncOptimizations);
        } else {
            initBeatSyncOptimizations();
        }

        // Formatear tiempo mm:ss
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Formatear tiempo mm:ss.d (con décimas)
        function formatTimeMs(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return `${mins.toString().padStart(2, '0')}:${secs.padStart(4, '0')}`;
        }

        // Actualizar label de sensibilidad
        function updateSensitivityLabel(value) {
            document.getElementById('beatsyncSensitivityValue').textContent = value;
        }

        // Actualizar label de intervalo mínimo (mostrar en ms para mejor legibilidad)
        function updateMinIntervalLabel(value) {
            const ms = Math.round(parseFloat(value) * 1000);
            document.getElementById('beatsyncMinIntervalValue').textContent = ms + 'ms';
        }

        // Actualizar label de umbral
        function updateThresholdLabel(value) {
            const labels = {
                1: '1 (mínimo)',
                2: '2 (muy bajo)',
                3: '3 (bajo)',
                4: '4',
                5: '5 (medio)',
                6: '6',
                7: '7 (alto)',
                8: '8 (muy alto)',
                9: '9',
                10: '10 (máximo)'
            };
            document.getElementById('beatsyncThresholdValue').textContent = labels[value] || value;
        }

        // Actualizar label de agudeza
        function updateSharpnessLabel(value) {
            const labels = {
                1: '1 (muy suave)',
                2: '2 (suave)',
                3: '3 (suave)',
                4: '4',
                5: '5 (medio)',
                6: '6',
                7: '7 (agudo)',
                8: '8 (muy agudo)',
                9: '9',
                10: '10 (extremo)'
            };
            document.getElementById('beatsyncSharpnessValue').textContent = labels[value] || value;
        }

        // Cuando cambia la sensibilidad o intervalo, re-analizar (con debounce)
        let sensitivityDebounceTimer = null;
        function onSensitivityChange() {
            if (!beatSyncConfig.audioBuffer) return;

            // Cancelar timer anterior
            if (sensitivityDebounceTimer) {
                clearTimeout(sensitivityDebounceTimer);
            }

            // Esperar 300ms después de que el usuario deje de mover el slider
            sensitivityDebounceTimer = setTimeout(() => {
                reanalyzeBeatSync();
            }, 300);
        }

        // Versión inmediata para cuando se suelta el slider
        function onSensitivityChangeImmediate() {
            if (!beatSyncConfig.audioBuffer) return;

            // Cancelar debounce pendiente
            if (sensitivityDebounceTimer) {
                clearTimeout(sensitivityDebounceTimer);
                sensitivityDebounceTimer = null;
            }

            reanalyzeBeatSync();
        }

        // Cambiar modo de detección
        function setBeatSyncMode(mode, btn) {
            beatSyncConfig.mode = mode;
            document.querySelectorAll('.beatsync-mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            if (beatSyncConfig.audioBuffer) {
                reanalyzeBeatSync();
            }
        }

        // ========================================
        // AUDIO CUTTER VISUAL - Funciones
        // ========================================

        // Inicializar el audio cutter cuando se carga música
        function initAudioCutter() {
            if (!beatSyncConfig.audioBuffer) return;

            const duration = beatSyncConfig.audioBuffer.duration;
            const defaultEnd = Math.min(30, duration);

            beatSyncConfig.trimStart = 0;
            beatSyncConfig.trimEnd = defaultEnd;

            // Actualizar UI
            document.getElementById('beatsyncCutterFilename').textContent = beatSyncConfig.audioFile?.name || 'Audio';
            document.getElementById('beatsyncCutterDuration').textContent = formatTime(duration);

            updateCutterSelection();
            drawCutterWaveform();
            setupCutterDragHandles();
            setupWaveformBeatClicks(); // Doble click para agregar/eliminar beats
        }

        // Dibujar waveform mejorado con barras
        function drawCutterWaveform() {
            const canvas = document.getElementById('beatsyncWaveformCanvas2');
            const container = document.getElementById('beatsyncWaveformVisual');
            if (!canvas || !container || !beatSyncConfig.audioBuffer) return;

            const ctx = canvas.getContext('2d');
            const width = container.offsetWidth;
            const height = container.offsetHeight;

            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const buffer = beatSyncConfig.audioBuffer;
            const channelData = buffer.getChannelData(0);

            // Combinar canales si es stereo
            let data = channelData;
            if (buffer.numberOfChannels > 1) {
                const ch2 = buffer.getChannelData(1);
                data = new Float32Array(channelData.length);
                for (let i = 0; i < channelData.length; i++) {
                    data[i] = (channelData[i] + ch2[i]) / 2;
                }
            }

            // Encontrar pico máximo
            let maxPeak = 0;
            for (let i = 0; i < data.length; i++) {
                const absVal = Math.abs(data[i]);
                if (absVal > maxPeak) maxPeak = absVal;
            }
            maxPeak = maxPeak || 1;

            // Configuración de barras
            const barWidth = 3;
            const barGap = 1;
            const barCount = Math.floor(width / (barWidth + barGap));
            const samplesPerBar = Math.floor(data.length / barCount);
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);

            for (let i = 0; i < barCount; i++) {
                const startSample = i * samplesPerBar;
                const endSample = startSample + samplesPerBar;

                // Calcular RMS para mejor representación
                let sumSquares = 0;
                let peakInBar = 0;
                for (let j = startSample; j < endSample && j < data.length; j++) {
                    const val = Math.abs(data[j]);
                    sumSquares += val * val;
                    if (val > peakInBar) peakInBar = val;
                }
                const rms = Math.sqrt(sumSquares / samplesPerBar);
                const normalizedValue = ((rms * 0.7) + (peakInBar * 0.3)) / maxPeak;
                const barHeight = Math.max(2, normalizedValue * height * 0.85);

                const x = i * (barWidth + barGap);
                const y = centerY - (barHeight / 2);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(x, y, barWidth, barHeight, 1);
                ctx.fill();
            }

            // Dibujar marcadores de beats mejorados
            const duration = buffer.duration;
            const beatsInRange = beatSyncConfig.beats.filter(
                b => b >= beatSyncConfig.trimStart && b <= beatSyncConfig.trimEnd
            );

            // Dibujar beats con mejor visibilidad
            beatsInRange.forEach((beatTime, idx) => {
                const x = (beatTime / duration) * width;

                // Línea vertical tenue
                ctx.fillStyle = 'rgba(239, 68, 68, 0.25)';
                ctx.fillRect(x - 0.5, 0, 1, height);

                // Marcadores más visibles arriba y abajo
                ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
                ctx.beginPath();
                // Triángulo arriba
                ctx.moveTo(x, 0);
                ctx.lineTo(x - 4, 8);
                ctx.lineTo(x + 4, 8);
                ctx.closePath();
                ctx.fill();

                // Triángulo abajo
                ctx.beginPath();
                ctx.moveTo(x, height);
                ctx.lineTo(x - 4, height - 8);
                ctx.lineTo(x + 4, height - 8);
                ctx.closePath();
                ctx.fill();
            });

            // Almacenar posiciones de beats para clicks
            beatSyncConfig.beatPositions = beatsInRange.map(beatTime => ({
                time: beatTime,
                x: (beatTime / duration) * width
            }));
        }

        // Click en waveform para agregar/eliminar beats
        function setupWaveformBeatClicks() {
            const canvas = document.getElementById('beatsyncWaveformCanvas2');
            const container = document.getElementById('beatsyncWaveformVisual');
            if (!canvas || !container) return;

            // Evitar duplicación de event listeners
            if (beatSyncConfig.waveformClicksSetup) return;
            beatSyncConfig.waveformClicksSetup = true;

            canvas.addEventListener('dblclick', (e) => {
                if (!beatSyncConfig.audioBuffer) return;

                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const width = container.offsetWidth;
                const duration = beatSyncConfig.audioBuffer.duration;
                const clickTime = (x / width) * duration;

                // Verificar si hay un beat cerca (tolerancia de 50px)
                const tolerance = 50;
                const positions = beatSyncConfig.beatPositions || [];
                const nearbyBeat = positions.find(b => Math.abs(b.x - x) < tolerance);

                if (nearbyBeat) {
                    // Eliminar beat existente
                    const idx = beatSyncConfig.beats.indexOf(nearbyBeat.time);
                    if (idx > -1) {
                        beatSyncConfig.beats.splice(idx, 1);
                        beatSyncConfig.manualBeatsRemoved.push(nearbyBeat.time);
                    }
                } else {
                    // Agregar nuevo beat
                    beatSyncConfig.beats.push(clickTime);
                    beatSyncConfig.beats.sort((a, b) => a - b);
                    beatSyncConfig.manualBeatsAdded.push(clickTime);
                }

                // Redibujar waveform y actualizar UI
                drawCutterWaveform();
                updateCutterSelection();
            });
        }

        // Actualizar selección visual del cutter
        function updateCutterSelection() {
            if (!beatSyncConfig.audioBuffer) return;

            const container = document.getElementById('beatsyncWaveformVisual');
            const selection = document.getElementById('beatsyncWaveformSelection');
            const handleLeft = document.getElementById('beatsyncHandleLeft');
            const handleRight = document.getElementById('beatsyncHandleRight');
            const overlayLeft = document.getElementById('beatsyncOverlayLeft');
            const overlayRight = document.getElementById('beatsyncOverlayRight');

            if (!container || !selection) return;

            const duration = beatSyncConfig.audioBuffer.duration;
            const startPercent = (beatSyncConfig.trimStart / duration) * 100;
            const endPercent = (beatSyncConfig.trimEnd / duration) * 100;

            // Actualizar área de selección
            selection.style.left = startPercent + '%';
            selection.style.width = (endPercent - startPercent) + '%';

            // Actualizar handles (posicionados independientemente)
            if (handleLeft) {
                handleLeft.style.left = `calc(${startPercent}% - 14px)`;
            }
            if (handleRight) {
                handleRight.style.left = `calc(${endPercent}% - 14px)`;
            }

            // Actualizar overlays oscuros
            if (overlayLeft) {
                overlayLeft.style.width = startPercent + '%';
            }
            if (overlayRight) {
                overlayRight.style.width = (100 - endPercent) + '%';
            }

            // Actualizar displays de tiempo
            document.getElementById('beatsyncCutStart').textContent = formatTimeMs(beatSyncConfig.trimStart);
            document.getElementById('beatsyncCutEnd').textContent = formatTimeMs(beatSyncConfig.trimEnd);

            // Actualizar input de duración
            const trimDuration = Math.round(beatSyncConfig.trimEnd - beatSyncConfig.trimStart);
            const durationInput = document.getElementById('beatsyncCutDuration');
            if (durationInput) {
                durationInput.value = trimDuration;
            }

            // Actualizar tiempo actual del playhead
            const currentPos = beatSyncConfig.cutterStartTime !== undefined
                ? beatSyncConfig.cutterStartTime
                : beatSyncConfig.trimStart;
            updateCurrentTimeDisplay(currentPos);

            // Actualizar posición visual del playhead
            const playhead = document.getElementById('beatsyncCutterPlayhead');
            if (playhead && !beatSyncConfig.cutterPlaying) {
                const playheadPercent = (currentPos / duration) * 100;
                playhead.style.left = playheadPercent + '%';
                playhead.classList.add('active');
            }

            // Actualizar conteo de beats en el rango
            const beatsInRange = beatSyncConfig.beats.filter(
                b => b >= beatSyncConfig.trimStart && b <= beatSyncConfig.trimEnd
            ).length;
            document.getElementById('beatsyncCutterBeats').textContent = beatsInRange + ' beats';
        }

        // Setup drag handles para el cutter
        function setupCutterDragHandles() {
            const handleLeft = document.getElementById('beatsyncHandleLeft');
            const handleRight = document.getElementById('beatsyncHandleRight');
            const container = document.getElementById('beatsyncWaveformVisual');

            if (!handleLeft || !handleRight || !container) return;

            // Evitar duplicación de event listeners
            if (beatSyncConfig.dragHandlesSetup) return;
            beatSyncConfig.dragHandlesSetup = true;

            const startDrag = (e, handle) => {
                e.preventDefault();
                e.stopPropagation();
                beatSyncConfig.isDraggingHandle = true;
                beatSyncConfig.dragHandle = handle;

                document.body.style.cursor = 'ew-resize';
                if (handle === 'left') {
                    handleLeft.classList.add('dragging');
                } else {
                    handleRight.classList.add('dragging');
                }

                document.addEventListener('mousemove', onCutterDrag);
                document.addEventListener('mouseup', stopCutterDrag);
                document.addEventListener('touchmove', onCutterDrag, { passive: false });
                document.addEventListener('touchend', stopCutterDrag);
            };

            handleLeft.addEventListener('mousedown', (e) => startDrag(e, 'left'));
            handleRight.addEventListener('mousedown', (e) => startDrag(e, 'right'));
            handleLeft.addEventListener('touchstart', (e) => startDrag(e, 'left'), { passive: false });
            handleRight.addEventListener('touchstart', (e) => startDrag(e, 'right'), { passive: false });

            // Click en waveform para mover playhead o selección
            container.addEventListener('click', function(e) {
                if (beatSyncConfig.isDraggingHandle) return;
                if (!beatSyncConfig.audioBuffer) return;

                const rect = container.getBoundingClientRect();
                const clickX = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const percent = clickX / rect.width;
                const duration = beatSyncConfig.audioBuffer.duration;
                const clickTime = percent * duration;

                // Si el click está dentro de la selección, mover playhead ahí
                if (clickTime >= beatSyncConfig.trimStart && clickTime <= beatSyncConfig.trimEnd) {
                    // Mover playhead a la posición del click
                    seekCutterPlayhead(clickTime);
                } else {
                    // Click fuera de selección: mover el rango centrado en el click
                    const rangeWidth = beatSyncConfig.trimEnd - beatSyncConfig.trimStart;
                    let newStart = clickTime - (rangeWidth / 2);
                    newStart = Math.max(0, Math.min(newStart, duration - rangeWidth));

                    beatSyncConfig.trimStart = newStart;
                    beatSyncConfig.trimEnd = newStart + rangeWidth;

                    updateCutterSelection();
                    reanalyzeBeatSync();
                }
            });
        }

        // Mover playhead a una posición específica
        function seekCutterPlayhead(time) {
            const playhead = document.getElementById('beatsyncCutterPlayhead');
            const container = document.getElementById('beatsyncWaveformVisual');
            if (!playhead || !container || !beatSyncConfig.audioBuffer) return;

            const duration = beatSyncConfig.audioBuffer.duration;
            const percent = (time / duration) * 100;

            playhead.style.left = percent + '%';
            playhead.classList.add('active');

            // Actualizar display de tiempo actual
            updateCurrentTimeDisplay(time);

            // Si está reproduciendo, reiniciar desde esta posición
            if (beatSyncConfig.cutterPlaying) {
                stopCutterPlayback();
                beatSyncConfig.cutterStartTime = time;
                startCutterPlayback(time);
            } else {
                // Guardar posición para cuando se reproduzca
                beatSyncConfig.cutterStartTime = time;
            }
        }

        // Actualizar display de tiempo actual
        function updateCurrentTimeDisplay(time) {
            const el = document.getElementById('beatsyncCurrentTime');
            if (el) {
                el.textContent = formatTimeMs(time);
            }
        }

        // Cambiar duración (modifica "hasta")
        function onDurationChange(value) {
            if (!beatSyncConfig.audioBuffer) return;

            const duration = parseFloat(value);
            if (isNaN(duration) || duration < 5) return;

            const audioDuration = beatSyncConfig.audioBuffer.duration;
            let newEnd = beatSyncConfig.trimStart + duration;

            // Limitar al final del audio
            if (newEnd > audioDuration) {
                newEnd = audioDuration;
                // Actualizar el input con el valor real
                document.getElementById('beatsyncCutDuration').value = Math.round(newEnd - beatSyncConfig.trimStart);
            }

            beatSyncConfig.trimEnd = newEnd;
            updateCutterSelection();
            reanalyzeBeatSync();
        }

        function onCutterDrag(e) {
            if (!beatSyncConfig.isDraggingHandle || !beatSyncConfig.audioBuffer) return;
            e.preventDefault();

            const container = document.getElementById('beatsyncWaveformVisual');
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let x = clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width));

            const duration = beatSyncConfig.audioBuffer.duration;
            const time = (x / rect.width) * duration;

            if (beatSyncConfig.dragHandle === 'left') {
                beatSyncConfig.trimStart = Math.min(time, beatSyncConfig.trimEnd - 1);
                beatSyncConfig.trimStart = Math.max(0, beatSyncConfig.trimStart);
            } else {
                beatSyncConfig.trimEnd = Math.max(time, beatSyncConfig.trimStart + 1);
                beatSyncConfig.trimEnd = Math.min(duration, beatSyncConfig.trimEnd);
            }

            updateCutterSelection();
        }

        function stopCutterDrag() {
            if (!beatSyncConfig.isDraggingHandle) return;

            beatSyncConfig.isDraggingHandle = false;
            document.body.style.cursor = '';

            const handleLeft = document.getElementById('beatsyncHandleLeft');
            const handleRight = document.getElementById('beatsyncHandleRight');
            if (handleLeft) handleLeft.classList.remove('dragging');
            if (handleRight) handleRight.classList.remove('dragging');

            document.removeEventListener('mousemove', onCutterDrag);
            document.removeEventListener('mouseup', stopCutterDrag);
            document.removeEventListener('touchmove', onCutterDrag);
            document.removeEventListener('touchend', stopCutterDrag);

            // Asegurar que el playhead esté dentro de la selección
            if (beatSyncConfig.cutterStartTime === undefined ||
                beatSyncConfig.cutterStartTime < beatSyncConfig.trimStart ||
                beatSyncConfig.cutterStartTime > beatSyncConfig.trimEnd) {
                beatSyncConfig.cutterStartTime = beatSyncConfig.trimStart;
            }

            // Re-analizar beats con el nuevo rango
            reanalyzeBeatSync();
        }

        // Toggle reproducción del cutter (SINCRÓNICO para iOS)
        async function toggleCutterPlayback() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

            // En iOS, primero asegurar que el AudioContext esté activo
            if (isIOS && beatSyncConfig.audioContext && beatSyncConfig.audioContext.state === 'suspended') {
                try {
                    await beatSyncConfig.audioContext.resume();
                    console.log('[iOS] AudioContext resumido');
                } catch (e) {
                    console.warn('[iOS] Error resumiendo AudioContext:', e);
                    logErrorToBackend('warning', 'iOS: Error resumiendo AudioContext', e.message);
                }
            }

            if (beatSyncConfig.cutterPlaying) {
                stopCutterPlayback();
            } else {
                await startCutterPlayback();
            }
        }

        // Reproducir audio del cutter - Compatible con iOS/Android/PC
        async function startCutterPlayback(fromTime = null) {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

            // IMPORTANTE: Detener preview si está activo (evitar acoplamiento)
            if (beatSyncConfig.isPlaying) {
                stopBeatSyncPreview();
            }
            // Detener preview de tracks de biblioteca
            detenerPreviewTrack();

            // En iOS, asegurar AudioContext activo
            if (isIOS && beatSyncConfig.audioContext && beatSyncConfig.audioContext.state === 'suspended') {
                try {
                    await beatSyncConfig.audioContext.resume();
                } catch (e) {
                    logErrorToBackend('warning', 'iOS cutter: Error resumiendo AudioContext', e.message);
                }
            }

            // Verificar que hay audio disponible
            if (!beatSyncConfig.audioUrl) {
                console.warn('No hay audioUrl para reproducir');
                logErrorToBackend('warning', 'Cutter: No hay audioUrl disponible');
                // Si hay buffer pero no URL, crear URL desde el archivo
                if (beatSyncConfig.audioFile && beatSyncConfig.audioFile instanceof File) {
                    beatSyncConfig.audioUrl = URL.createObjectURL(beatSyncConfig.audioFile);
                    beatSyncConfig.audioUrlIsBlob = true;
                } else {
                    mostrarToastExito('Error: No hay audio cargado');
                    return;
                }
            }

            // Obtener o crear el audio player persistente
            const audio = ensureBeatSyncAudioPlayer();

            // Determinar desde dónde reproducir
            let playFrom;
            if (fromTime !== null) {
                playFrom = fromTime;
            } else if (beatSyncConfig.cutterStartTime !== undefined &&
                       beatSyncConfig.cutterStartTime >= beatSyncConfig.trimStart &&
                       beatSyncConfig.cutterStartTime <= beatSyncConfig.trimEnd) {
                playFrom = beatSyncConfig.cutterStartTime;
            } else {
                playFrom = beatSyncConfig.trimStart;
            }

            const trimEnd = beatSyncConfig.trimEnd;
            const duration = trimEnd - playFrom;

            // Detener reproducción anterior
            audio.pause();

            // Configurar source y tiempo
            // IMPORTANTE: En iOS, cambiar src reinicia el audio completamente
            // Comparar URLs normalizadas (audio.src es URL completa, audioUrl puede ser relativa)
            const currentSrc = audio.src || '';
            const targetUrl = beatSyncConfig.audioUrl;
            const isSameSource = currentSrc.endsWith(targetUrl) || currentSrc === targetUrl ||
                                 (targetUrl.startsWith('blob:') && currentSrc === targetUrl);

            if (!isSameSource) {
                audio.src = beatSyncConfig.audioUrl;
            }

            // Marcar como reproduciendo ANTES de play() para UI
            beatSyncConfig.cutterPlaying = true;
            beatSyncConfig.cutterPlayFrom = playFrom;

            // Actualizar UI inmediatamente
            document.getElementById('beatsyncCutterPlayBtn')?.classList.add('playing');
            const playhead = document.getElementById('beatsyncCutterPlayhead');
            if (playhead) playhead.classList.add('active');

            const totalDuration = beatSyncConfig.audioBuffer?.duration || 30;

            // Función de animación del playhead
            function animatePlayhead() {
                if (!beatSyncConfig.cutterPlaying) return;

                const currentTime = audio.currentTime;

                if (currentTime >= trimEnd) {
                    stopCutterPlayback();
                    return;
                }

                const percent = (currentTime / totalDuration) * 100;
                if (playhead) playhead.style.left = percent + '%';

                // Guardar posición actual para resume
                beatSyncConfig.cutterStartTime = currentTime;

                // Actualizar display de tiempo actual
                updateCurrentTimeDisplay(currentTime);

                beatSyncConfig.cutterAnimationId = requestAnimationFrame(animatePlayhead);
            }

            // Configurar eventos
            audio.ontimeupdate = () => {
                if (audio.currentTime >= trimEnd) {
                    stopCutterPlayback();
                }
            };

            audio.onended = () => {
                stopCutterPlayback();
            };

            audio.onerror = (e) => {
                console.error('Error en audio:', e);
                stopCutterPlayback();
            };

            // Función helper para intentar reproducir
            async function tryPlay() {
                try {
                    audio.currentTime = playFrom;
                } catch (e) {
                    console.warn('Error setting currentTime:', e);
                    logErrorToBackend('warning', `Cutter: Error setting currentTime to ${playFrom}`, e.message);
                }

                try {
                    await audio.play();
                    beatSyncConfig.cutterPlayStartTime = Date.now();
                    animatePlayhead();
                    console.log('[Cutter] Audio reproduciéndose desde', playFrom);
                } catch (error) {
                    console.error('Error en play():', error);
                    logErrorToBackend('error', `Cutter play() falló: ${error.name} - ${error.message}`,
                        `readyState: ${audio.readyState}, src: ${audio.src?.substring(0, 50)}, isIOS: ${isIOS}`);

                    if (error.name === 'NotAllowedError') {
                        mostrarToastExito('Toca de nuevo para reproducir');
                    }
                    stopCutterPlayback();
                }
            }

            // Si el audio ya está listo (cached), reproducir inmediatamente
            if (audio.readyState >= 3) {
                console.log('[Cutter] Audio listo (readyState:', audio.readyState, '), reproduciendo...');
                await tryPlay();
            } else if (!isSameSource) {
                // Nuevo source - cargar y esperar
                console.log('[Cutter] Cargando nuevo source...');
                audio.oncanplay = async function() {
                    audio.oncanplay = null;
                    await tryPlay();
                };
                audio.load();
            } else {
                // Mismo source pero no listo - intentar de todos modos (iOS quirk)
                console.log('[Cutter] Mismo source, readyState:', audio.readyState, ', intentando...');

                // En iOS, a veces necesita load() incluso para el mismo source
                if (isIOS && audio.readyState < 2) {
                    audio.oncanplay = async function() {
                        audio.oncanplay = null;
                        await tryPlay();
                    };
                    audio.load();
                } else {
                    await tryPlay();
                }
            }
        }

        function stopCutterPlayback() {
            beatSyncConfig.cutterPlaying = false;

            // Detener audio player persistente (NO destruir, solo pausar)
            if (beatSyncConfig.audioPlayer) {
                try {
                    beatSyncConfig.audioPlayer.pause();
                    // Limpiar eventos para evitar llamadas fantasma
                    beatSyncConfig.audioPlayer.ontimeupdate = null;
                    beatSyncConfig.audioPlayer.onended = null;
                    beatSyncConfig.audioPlayer.onerror = null;
                    beatSyncConfig.audioPlayer.oncanplay = null;
                } catch(e) {
                    console.warn('Error pausando audio:', e);
                }
                // NO destruir el audio player, se reutiliza
            }

            // Legacy: detener HTMLAudioElement antiguo si existe
            if (beatSyncConfig.cutterAudioElement && beatSyncConfig.cutterAudioElement !== beatSyncConfig.audioPlayer) {
                try {
                    beatSyncConfig.cutterAudioElement.pause();
                    beatSyncConfig.cutterAudioElement.src = '';
                } catch(e) {}
                beatSyncConfig.cutterAudioElement = null;
            }

            // Detener Web Audio API source (legacy)
            if (beatSyncConfig.cutterSource) {
                try { beatSyncConfig.cutterSource.stop(); } catch(e) {}
                beatSyncConfig.cutterSource = null;
            }

            if (beatSyncConfig.cutterAnimationId) {
                cancelAnimationFrame(beatSyncConfig.cutterAnimationId);
                beatSyncConfig.cutterAnimationId = null;
            }

            document.getElementById('beatsyncCutterPlayBtn')?.classList.remove('playing');
            document.getElementById('beatsyncCutterPlayhead')?.classList.remove('active');
        }

        // Re-analizar beats
        async function reanalyzeBeatSync() {
            if (!beatSyncConfig.audioBuffer) return;

            if (beatSyncConfig.isPlaying) {
                stopBeatSyncPreview();
            }
            if (beatSyncConfig.cutterPlaying) {
                stopCutterPlayback();
            }

            const progressEl = document.getElementById('beatsyncProgress');
            const headerProgressEl = document.getElementById('beatsyncHeaderProgress');
            progressEl.classList.add('active');
            if (headerProgressEl) headerProgressEl.classList.add('active');
            updateBeatSyncProgress(30, 'Analizando ritmo...');

            await detectBeatsImproved();
            drawCutterWaveform();
            updateCutterSelection();

            updateBeatSyncProgress(100, 'Listo!');
            setTimeout(() => progressEl.classList.remove('active'), 300);
        }

        // ========================================
        // BIBLIOTECA DE MÚSICA
        // ========================================
        let musicLibraryCache = null;
        let musicLibraryLoaded = false;
        let musicLibrarySearchTimeout = null;
        let musicLibraryPreviewAudio = null;
        let musicLibraryCurrentCategory = 'all';
        let musicLibraryGenres = [];

        // Escapar HTML para evitar XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Cambiar entre tabs de música
        function cambiarTabMusica(tab, element) {
            // Actualizar tabs
            document.querySelectorAll('.beatsync-music-tab').forEach(t => t.classList.remove('active'));
            element.classList.add('active');

            // Mostrar contenido correspondiente
            document.getElementById('beatsyncTabUpload').classList.remove('active');
            document.getElementById('beatsyncTabLibrary').classList.remove('active');

            if (tab === 'upload') {
                document.getElementById('beatsyncTabUpload').classList.add('active');
            } else {
                document.getElementById('beatsyncTabLibrary').classList.add('active');
                // Cargar biblioteca si no está cargada
                if (!musicLibraryLoaded) {
                    cargarBibliotecaMusica();
                }
            }
        }

        // Cargar biblioteca de música (usa /api/Musica/biblioteca como Contenido/Editar)
        async function cargarBibliotecaMusica() {
            const container = document.getElementById('beatsyncMusicLibrary');
            const loading = document.getElementById('beatsyncLibraryLoading');

            if (loading) loading.style.display = 'flex';

            try {
                // Cargar pistas y géneros en paralelo
                const [pistasRes, generosRes] = await Promise.all([
                    fetch('/api/Musica/biblioteca'),
                    fetch('/api/Musica/generos')
                ]);

                if (!pistasRes.ok) throw new Error('Error cargando biblioteca');

                const pistas = await pistasRes.json();
                const generos = generosRes.ok ? await generosRes.json() : [];

                // Mapear al formato esperado - usar proxy URL para evitar CORS en iOS
                musicLibraryCache = pistas.map(p => ({
                    id: p.id,
                    title: p.titulo,
                    artist: p.artista,
                    url: `/api/Musica/audio/${p.id}`, // Usar proxy con headers CORS correctos
                    originalUrl: p.rutaArchivo, // Mantener URL original por si acaso
                    cover: p.rutaPortada,
                    duration: p.duracion,
                    genre: p.genero,
                    category: p.genero?.toLowerCase().replace(/ /g, '').replace(/ó/g, 'o').replace(/í/g, 'i') || 'all',
                    bpm: p.bpm,
                    energy: p.energia,
                    mood: p.estadoAnimo
                }));

                musicLibraryGenres = generos.map(g => g.nombre || g.Nombre);
                musicLibraryLoaded = true;

                // Actualizar categorías dinámicamente
                renderizarCategorias(musicLibraryGenres);
                renderizarBibliotecaMusica(musicLibraryCache);
            } catch (error) {
                console.error('Error cargando biblioteca:', error);
                container.innerHTML = `
                    <div class="beatsync-library-empty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                        <div>No hay música disponible</div>
                        <div style="font-size: 12px; margin-top: 4px;">Agrega música desde /Admin/Musica</div>
                    </div>
                `;
            }
        }

        // Renderizar categorías dinámicas
        function renderizarCategorias(genres) {
            const container = document.getElementById('beatsyncMusicCategories');
            if (!container) return;

            let html = `<button class="beatsync-music-category active" data-category="all" onclick="filtrarMusicaCategoria('all', this)">Todas</button>`;

            genres.forEach(genre => {
                const categoryKey = genre.toLowerCase().replace(/ /g, '').replace(/ó/g, 'o').replace(/í/g, 'i').replace(/é/g, 'e').replace(/á/g, 'a').replace(/ú/g, 'u');
                html += `<button class="beatsync-music-category" data-category="${categoryKey}" onclick="filtrarMusicaCategoria('${categoryKey}', this)">${genre}</button>`;
            });

            container.innerHTML = html;
        }

        // Renderizar lista de música
        function renderizarBibliotecaMusica(tracks) {
            const container = document.getElementById('beatsyncMusicLibrary');

            if (!tracks || tracks.length === 0) {
                container.innerHTML = `
                    <div class="beatsync-library-empty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                        <div>No se encontraron canciones</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = tracks.map(track => `
                <div class="beatsync-track"
                     data-track-id="${track.id}"
                     data-track-url="${encodeURIComponent(track.url)}"
                     data-track-title="${encodeURIComponent(track.title)}">
                    <button class="beatsync-track-play-btn"
                            onclick="event.stopPropagation(); togglePreviewTrack(this.closest('.beatsync-track'), decodeURIComponent(this.closest('.beatsync-track').dataset.trackUrl))"
                            aria-label="Reproducir o pausar">
                        <div class="beatsync-track-cover">
                            ${track.cover ? `<img src="${track.cover}" alt="">` : `
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M9 18V5l12-2v13"/>
                                    <circle cx="6" cy="18" r="3"/>
                                    <circle cx="18" cy="16" r="3"/>
                                </svg>
                            `}
                            <div class="play-overlay play-icon">
                                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                                    <polygon points="5 3 19 12 5 21 5 3"/>
                                </svg>
                            </div>
                            <div class="play-overlay pause-icon">
                                <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                                    <rect x="6" y="4" width="4" height="16"/>
                                    <rect x="14" y="4" width="4" height="16"/>
                                </svg>
                            </div>
                        </div>
                    </button>
                    <div class="beatsync-track-info" onclick="togglePreviewTrack(this.closest('.beatsync-track'), decodeURIComponent(this.closest('.beatsync-track').dataset.trackUrl))">
                        <div class="beatsync-track-title">${escapeHtml(track.title)}</div>
                        <div class="beatsync-track-artist">${escapeHtml(track.artist) || 'Artista desconocido'}${track.genre ? ` • ${escapeHtml(track.genre)}` : ''}</div>
                    </div>
                    <span class="beatsync-track-duration">${formatTime(track.duration || 0)}</span>
                    <button class="beatsync-track-use-btn" onclick="event.stopPropagation(); usarTrackBiblioteca(this)">
                        Usar
                    </button>
                </div>
            `).join('');
        }

        // Usar track de biblioteca (wrapper que lee data attributes)
        function usarTrackBiblioteca(buttonEl) {
            const trackEl = buttonEl.closest('.beatsync-track');
            if (!trackEl) {
                console.error('[BeatSync] No se encontró el elemento track padre');
                return;
            }

            const url = decodeURIComponent(trackEl.dataset.trackUrl || '');
            const title = decodeURIComponent(trackEl.dataset.trackTitle || '');
            const trackId = parseInt(trackEl.dataset.trackId) || 0;

            console.log('[BeatSync] usarTrackBiblioteca:', { url, title, trackId });

            if (!url) {
                console.error('[BeatSync] URL de track vacía');
                alert('Error: URL de la canción no disponible');
                return;
            }

            seleccionarTrackBiblioteca(url, title, trackId);
        }

        // Preview de track - Optimizado con streaming
        function togglePreviewTrack(element, url) {
            // Desbloquear audio en iOS primero
            if (isIOS() && !audioUnlocked) {
                unlockAudioForIOS();
            }

            // Si ya está reproduciendo este track, pausar
            if (element.classList.contains('playing')) {
                detenerPreviewTrack();
                return;
            }

            // Detener cualquier preview anterior
            detenerPreviewTrack();

            // Usar HTMLAudioElement con streaming (más rápido)
            musicLibraryPreviewAudio = new Audio();
            musicLibraryPreviewAudio.preload = 'auto';
            musicLibraryPreviewAudio.volume = 0.5;

            musicLibraryPreviewAudio.oncanplaythrough = () => {
                // Solo reproducir si aún queremos este track
                if (musicLibraryPreviewAudio && musicLibraryPreviewAudio.src.includes(url.split('/').pop())) {
                    musicLibraryPreviewAudio.play().catch(() => {});
                }
            };

            musicLibraryPreviewAudio.onplay = () => {
                element.classList.remove('loading');
                element.classList.add('playing');
            };

            musicLibraryPreviewAudio.onended = () => {
                element.classList.remove('playing');
                element.classList.remove('loading');
            };

            musicLibraryPreviewAudio.onerror = () => {
                element.classList.remove('playing');
                element.classList.remove('loading');
            };

            musicLibraryPreviewAudio.onpause = () => {
                element.classList.remove('playing');
            };

            // Indicador visual inmediato de carga
            element.classList.add('loading');

            // Iniciar carga (streaming)
            musicLibraryPreviewAudio.src = url;
            musicLibraryPreviewAudio.load();
        }

        function detenerPreviewTrack() {
            if (musicLibraryPreviewAudio) {
                try {
                    musicLibraryPreviewAudio.pause();
                    musicLibraryPreviewAudio.src = '';
                    musicLibraryPreviewAudio.load();
                } catch(e) {}
                musicLibraryPreviewAudio = null;
            }
            document.querySelectorAll('.beatsync-track.playing, .beatsync-track.loading').forEach(t => {
                t.classList.remove('playing');
                t.classList.remove('loading');
            });
        }

        // Seleccionar track de biblioteca
        async function seleccionarTrackBiblioteca(url, nombre, trackId) {
            console.log('[BeatSync] seleccionarTrackBiblioteca llamada:', { url, nombre, trackId });

            // IMPORTANTE: Detener TODOS los audios antes de cargar nueva música
            stopAllBeatSyncAudio();

            // Deshabilitar botón de play del cutter mientras carga
            const playBtn = document.getElementById('beatsyncCutterPlayBtn');
            if (playBtn) {
                playBtn.classList.add('loading');
                playBtn.disabled = true;
            }

            // Cambiar a tab de subir PRIMERO para que los elementos estén visibles
            const uploadTab = document.querySelector('.beatsync-music-tab[data-tab="upload"]');
            if (uploadTab) {
                cambiarTabMusica('upload', uploadTab);
            }

            // Actualizar UI inmediatamente (igual que handleBeatSyncMusic)
            const uploadEl = document.getElementById('beatsyncMusicUpload');
            const nameEl = document.getElementById('beatsyncMusicName');
            const textEl = uploadEl?.querySelector('.beatsync-music-text');

            if (uploadEl) uploadEl.classList.add('has-music');
            if (textEl) textEl.style.display = 'none';
            if (nameEl) {
                nameEl.style.display = 'block';
                nameEl.textContent = nombre;
            }

            // Mostrar progress
            const progressEl = document.getElementById('beatsyncProgress');
            const headerProgressEl = document.getElementById('beatsyncHeaderProgress');
            if (!progressEl) {
                console.error('[BeatSync] progressEl no encontrado!');
            } else {
                progressEl.classList.add('active');
            if (headerProgressEl) headerProgressEl.classList.add('active');
            }
            updateBeatSyncProgress(10, 'Cargando canción...');
            console.log('[BeatSync] Progress mostrado, iniciando carga...');

            try {
                // Incrementar contador de usos (usa /api/Musica/{id}/usar)
                if (trackId) {
                    fetch(`/api/Musica/${trackId}/usar`, { method: 'POST' }).catch(() => {});
                }

                // Crear AudioContext con manejo robusto
                if (!beatSyncConfig.audioContext || beatSyncConfig.audioContext.state === 'closed') {
                    if (globalAudioContext && globalAudioContext.state !== 'closed') {
                        beatSyncConfig.audioContext = globalAudioContext;
                    } else {
                        try {
                            beatSyncConfig.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            globalAudioContext = beatSyncConfig.audioContext;
                        } catch (ctxError) {
                            console.error('Error creando AudioContext:', ctxError);
                            try {
                                beatSyncConfig.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                                globalAudioContext = beatSyncConfig.audioContext;
                            } catch (e) {
                                throw new Error('No se pudo inicializar el audio');
                            }
                        }
                    }
                }

                // Resumir AudioContext si está suspendido (importante para iOS)
                if (beatSyncConfig.audioContext.state === 'suspended') {
                    try {
                        await beatSyncConfig.audioContext.resume();
                    } catch (e) {
                        console.warn('No se pudo resumir AudioContext:', e);
                    }
                }

                // Descargar el audio
                console.log('[BeatSync] Descargando audio desde:', url);
                const response = await fetch(url);
                if (!response.ok) throw new Error('Error descargando audio: ' + response.status);
                console.log('[BeatSync] Audio descargado, obteniendo arrayBuffer...');

                const arrayBuffer = await response.arrayBuffer();
                console.log('[BeatSync] ArrayBuffer obtenido, tamaño:', arrayBuffer.byteLength);
                updateBeatSyncProgress(30, 'Decodificando audio...');

                // Decodificar audio (necesita clonar el buffer porque decodeAudioData lo consume)
                const audioData = arrayBuffer.slice(0);
                console.log('[BeatSync] Decodificando audio...');
                beatSyncConfig.audioBuffer = await beatSyncConfig.audioContext.decodeAudioData(audioData);
                console.log('[BeatSync] Audio decodificado, duración:', beatSyncConfig.audioBuffer.duration);
                beatSyncConfig.audioFile = { name: nombre };
                beatSyncConfig.audioUrl = url; // Guardar URL para playback con HTMLAudioElement
                beatSyncConfig.audioUrlIsBlob = false; // URL del servidor, no blob

                // Pre-inicializar audio player para iOS (mejor responsividad al play)
                const audioPlayer = ensureBeatSyncAudioPlayer();
                audioPlayer.src = url;
                audioPlayer.load(); // Precargar

                // Invalidar caché de spectral flux (nuevo audio)
                beatSyncConfig.spectralFluxCache = null;

                updateBeatSyncProgress(50, 'Analizando ritmo...');

                // IMPORTANTE: Mostrar el audio cutter ANTES de inicializarlo
                // para que los elementos tengan dimensiones calculables
                const audioCutter = document.getElementById('beatsyncAudioCutter');
                console.log('[BeatSync] audioCutter elemento:', audioCutter);
                if (audioCutter) audioCutter.style.display = 'block';

                // Esperar un frame para que el layout se calcule
                await new Promise(resolve => requestAnimationFrame(resolve));

                // Verificar dimensiones del contenedor
                const waveformVisual = document.getElementById('beatsyncWaveformVisual');
                console.log('[BeatSync] waveformVisual dimensiones:', waveformVisual?.offsetWidth, 'x', waveformVisual?.offsetHeight);

                // Inicializar audio cutter visual (ahora con dimensiones correctas)
                console.log('[BeatSync] Llamando initAudioCutter...');
                initAudioCutter();
                console.log('[BeatSync] initAudioCutter completado');

                // Detectar beats con el algoritmo mejorado
                console.log('[BeatSync] Detectando beats...');
                await detectBeatsImproved();
                console.log('[BeatSync] Beats detectados:', beatSyncConfig.beats?.length);
                updateBeatSyncProgress(100, 'Listo!');

                // Habilitar botón de play del cutter
                if (playBtn) {
                    playBtn.classList.remove('loading');
                    playBtn.disabled = false;
                }

                // Ocultar progress después de un momento
                setTimeout(() => {
                    progressEl.classList.remove('active');
            if (headerProgressEl) headerProgressEl.classList.remove('active');
                    checkBeatSyncReady();
                }, 500);

            } catch (error) {
                console.error('Error cargando track de biblioteca:', error);
                progressEl.classList.remove('active');
            if (headerProgressEl) headerProgressEl.classList.remove('active');
                // Habilitar botón de play en caso de error también
                if (playBtn) {
                    playBtn.classList.remove('loading');
                    playBtn.disabled = false;
                }
                alert('Error al cargar la canción: ' + error.message);
            }
        }

        // Búsqueda en biblioteca
        function buscarMusicaLibraryDebounced(query) {
            if (musicLibrarySearchTimeout) {
                clearTimeout(musicLibrarySearchTimeout);
            }
            musicLibrarySearchTimeout = setTimeout(() => {
                buscarMusicaLibrary(query);
            }, 300);
        }

        function buscarMusicaLibrary(query) {
            if (!musicLibraryCache) return;

            const filtered = query.trim() === ''
                ? filtrarPorCategoria(musicLibraryCache, musicLibraryCurrentCategory)
                : musicLibraryCache.filter(track => {
                    const searchLower = query.toLowerCase();
                    return (track.title && track.title.toLowerCase().includes(searchLower)) ||
                           (track.artist && track.artist.toLowerCase().includes(searchLower));
                });

            renderizarBibliotecaMusica(filtered);
        }

        // Filtrar por categoría
        function filtrarMusicaCategoria(categoria, element) {
            // Actualizar botones
            document.querySelectorAll('.beatsync-music-category').forEach(c => c.classList.remove('active'));
            element.classList.add('active');

            musicLibraryCurrentCategory = categoria;

            if (!musicLibraryCache) return;

            const filtered = filtrarPorCategoria(musicLibraryCache, categoria);
            renderizarBibliotecaMusica(filtered);

            // Limpiar búsqueda
            const searchInput = document.getElementById('beatsyncMusicSearch');
            if (searchInput) searchInput.value = '';
        }

        function filtrarPorCategoria(tracks, categoria) {
            if (categoria === 'all') return tracks;
            return tracks.filter(track => track.category === categoria || track.tags?.includes(categoria));
        }

        // Manejar subida de música
        async function handleBeatSyncMusic(event) {
            const file = event.target.files[0];
            if (!file) return;

            // IMPORTANTE: Detener TODOS los audios antes de cargar nueva música
            stopAllBeatSyncAudio();

            beatSyncConfig.audioFile = file;

            // Deshabilitar botón de play del cutter mientras carga
            const playBtn = document.getElementById('beatsyncCutterPlayBtn');
            if (playBtn) {
                playBtn.classList.add('loading');
                playBtn.disabled = true;
            }

            // Actualizar UI
            const uploadEl = document.getElementById('beatsyncMusicUpload');
            const nameEl = document.getElementById('beatsyncMusicName');
            const textEl = uploadEl.querySelector('.beatsync-music-text');

            uploadEl.classList.add('has-music');
            textEl.style.display = 'none';
            nameEl.style.display = 'block';
            nameEl.textContent = file.name;

            // Mostrar progress
            const progressEl = document.getElementById('beatsyncProgress');
            const headerProgressEl = document.getElementById('beatsyncHeaderProgress');
            progressEl.classList.add('active');
            if (headerProgressEl) headerProgressEl.classList.add('active');
            updateBeatSyncProgress(10, 'Cargando audio...');

            try {
                // Crear AudioContext con manejo robusto
                if (!beatSyncConfig.audioContext || beatSyncConfig.audioContext.state === 'closed') {
                    if (globalAudioContext && globalAudioContext.state !== 'closed') {
                        beatSyncConfig.audioContext = globalAudioContext;
                    } else {
                        try {
                            beatSyncConfig.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            globalAudioContext = beatSyncConfig.audioContext;
                        } catch (ctxError) {
                            console.error('Error creando AudioContext:', ctxError);
                            try {
                                beatSyncConfig.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
                                globalAudioContext = beatSyncConfig.audioContext;
                            } catch (e) {
                                throw new Error('No se pudo inicializar el audio');
                            }
                        }
                    }
                }

                // Resumir AudioContext si está suspendido (importante para iOS)
                if (beatSyncConfig.audioContext.state === 'suspended') {
                    try {
                        await beatSyncConfig.audioContext.resume();
                    } catch (e) {
                        console.warn('No se pudo resumir AudioContext:', e);
                    }
                }

                // Leer archivo
                const arrayBuffer = await file.arrayBuffer();
                updateBeatSyncProgress(30, 'Decodificando audio...');

                // Decodificar audio
                beatSyncConfig.audioBuffer = await beatSyncConfig.audioContext.decodeAudioData(arrayBuffer);

                // Crear URL para playback con HTMLAudioElement (mejor compatibilidad iOS)
                beatSyncConfig.audioUrl = URL.createObjectURL(file);
                beatSyncConfig.audioUrlIsBlob = true;

                // Pre-inicializar audio player para iOS (mejor responsividad al play)
                const audioPlayer = ensureBeatSyncAudioPlayer();
                audioPlayer.src = beatSyncConfig.audioUrl;
                audioPlayer.load(); // Precargar

                // Invalidar caché de spectral flux (nuevo audio)
                beatSyncConfig.spectralFluxCache = null;

                updateBeatSyncProgress(50, 'Analizando ritmo...');

                // IMPORTANTE: Mostrar el audio cutter ANTES de inicializarlo
                // para que los elementos tengan dimensiones calculables
                const audioCutter = document.getElementById('beatsyncAudioCutter');
                if (audioCutter) audioCutter.style.display = 'block';

                // Esperar un frame para que el layout se calcule
                await new Promise(resolve => requestAnimationFrame(resolve));

                // Inicializar audio cutter visual (ahora con dimensiones correctas)
                initAudioCutter();

                // Detectar beats con el algoritmo mejorado
                await detectBeatsImproved();
                updateBeatSyncProgress(100, 'Listo!');

                // Ocultar progress después de un momento
                setTimeout(() => {
                    progressEl.classList.remove('active');
            if (headerProgressEl) headerProgressEl.classList.remove('active');
                    checkBeatSyncReady();
                }, 500);

                // Re-habilitar botón de play del cutter
                if (playBtn) {
                    playBtn.classList.remove('loading');
                    playBtn.disabled = false;
                }

            } catch (error) {
                console.error('Error procesando audio:', error);
                progressEl.classList.remove('active');
            if (headerProgressEl) headerProgressEl.classList.remove('active');

                // Re-habilitar botón de play del cutter en caso de error
                if (playBtn) {
                    playBtn.classList.remove('loading');
                    playBtn.disabled = false;
                }

                alert('Error al procesar el audio. Intenta con otro archivo.');
            }
        }

        // ========================================
        // DETECCIÓN DE BEATS - SPECTRAL FLUX + ONSET DETECTION
        // Detecta CUALQUIER cambio musical: notas, acordes, rasgueos, etc.
        // ========================================
        async function detectBeatsImproved() {
            const buffer = beatSyncConfig.audioBuffer;
            if (!buffer) return [];

            const sampleRate = buffer.sampleRate;
            const mode = beatSyncConfig.mode;

            // Configuración desde sliders
            const sensitivity = parseInt(document.getElementById('beatsyncSensitivity')?.value) || 10;
            const minInterval = parseFloat(document.getElementById('beatsyncMinInterval')?.value) || 0.10;
            const thresholdParam = parseInt(document.getElementById('beatsyncThreshold')?.value) || 3;
            const sharpnessParam = parseInt(document.getElementById('beatsyncSharpness')?.value) || 3;

            // ========================================
            // PARÁMETROS DE ANÁLISIS FFT
            // ========================================
            const fftSize = 2048;
            const hopSize = Math.floor(fftSize / 4);
            const numFrames = Math.floor((buffer.getChannelData(0).length - fftSize) / hopSize);

            // ========================================
            // VERIFICAR CACHÉ DE SPECTRAL FLUX
            // ========================================
            let bassFlux, midFlux, highFlux;
            const cache = beatSyncConfig.spectralFluxCache;

            if (cache && cache.valid && cache.numFrames === numFrames) {
                // Usar datos cacheados (evita recálculo FFT)
                bassFlux = cache.bassFlux;
                midFlux = cache.midFlux;
                highFlux = cache.highFlux;
            } else {
                // Calcular spectral flux desde cero
                let channelData = buffer.getChannelData(0);
                if (buffer.numberOfChannels > 1) {
                    const ch2 = buffer.getChannelData(1);
                    const merged = new Float32Array(channelData.length);
                    for (let i = 0; i < channelData.length; i++) {
                        merged[i] = (channelData[i] + ch2[i]) / 2;
                    }
                    channelData = merged;
                }

                // Función de ventana Hanning
                const hanningWindow = new Float32Array(fftSize);
                for (let i = 0; i < fftSize; i++) {
                    hanningWindow[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
                }

                const numBins = fftSize / 2;
                let prevSpectrum = new Float32Array(numBins);
                bassFlux = new Float32Array(numFrames);
                midFlux = new Float32Array(numFrames);
                highFlux = new Float32Array(numFrames);

                const bassEnd = Math.floor(200 * fftSize / sampleRate);
                const midEnd = Math.floor(2000 * fftSize / sampleRate);

                for (let frame = 0; frame < numFrames; frame++) {
                    const start = frame * hopSize;
                    const frameData = new Float32Array(fftSize);
                    for (let i = 0; i < fftSize; i++) {
                        frameData[i] = (channelData[start + i] || 0) * hanningWindow[i];
                    }

                    const spectrum = computeFFTMagnitude(frameData);

                    let bFlux = 0, mFlux = 0, hFlux = 0;
                    for (let bin = 1; bin < numBins; bin++) {
                        const diff = spectrum[bin] - prevSpectrum[bin];
                        if (diff > 0) {
                            if (bin < bassEnd) bFlux += diff;
                            else if (bin < midEnd) mFlux += diff;
                            else hFlux += diff;
                        }
                    }

                    bassFlux[frame] = bFlux;
                    midFlux[frame] = mFlux;
                    highFlux[frame] = hFlux;
                    prevSpectrum = spectrum.slice();
                }

                // Normalizar y cachear
                const normalize = (arr) => {
                    let max = 0;
                    for (let i = 0; i < arr.length; i++) if (arr[i] > max) max = arr[i];
                    if (max > 0) for (let i = 0; i < arr.length; i++) arr[i] /= max;
                };
                normalize(bassFlux);
                normalize(midFlux);
                normalize(highFlux);

                // Guardar en caché
                beatSyncConfig.spectralFluxCache = {
                    valid: true,
                    numFrames: numFrames,
                    bassFlux: bassFlux,
                    midFlux: midFlux,
                    highFlux: highFlux,
                    sampleRate: sampleRate,
                    hopSize: hopSize
                };
            }

            // ========================================
            // COMBINAR SEÑALES DE DETECCIÓN (rápido, usa caché)
            // ========================================
            const onsetFunction = new Float32Array(numFrames);

            // Combinar según el modo
            // sharpnessParam: 1 = detecta todo (más mids/highs), 10 = solo golpes fuertes (más bass)
            const bassWeight = 0.2 + (sharpnessParam - 1) * 0.08; // 0.2 a 0.92
            const midWeight = 0.5 - (sharpnessParam - 1) * 0.03;  // 0.5 a 0.23
            const highWeight = 0.3 - (sharpnessParam - 1) * 0.025; // 0.3 a 0.075

            for (let i = 0; i < numFrames; i++) {
                if (mode === 'bass') {
                    onsetFunction[i] = bassFlux[i];
                } else if (mode === 'beats') {
                    onsetFunction[i] = bassFlux[i] * 0.6 + midFlux[i] * 0.3 + highFlux[i] * 0.1;
                } else {
                    // Modo 'all' - combinar todo según sharpness
                    onsetFunction[i] = bassFlux[i] * bassWeight +
                                       midFlux[i] * midWeight +
                                       highFlux[i] * highWeight;
                }
            }

            // Suavizar ligeramente para reducir ruido
            const smoothed = new Float32Array(numFrames);
            for (let i = 1; i < numFrames - 1; i++) {
                smoothed[i] = onsetFunction[i] * 0.6 +
                              (onsetFunction[i-1] + onsetFunction[i+1]) * 0.2;
            }

            // ========================================
            // DETECCIÓN DE PICOS (ONSETS)
            // ========================================
            // Threshold basado en sensibilidad
            // Sensibilidad 20 = threshold muy bajo (detecta casi todo)
            // Sensibilidad 1 = threshold alto (solo picos fuertes)
            const baseThreshold = 0.02 + (thresholdParam - 1) * 0.03; // 0.02 a 0.29
            const sensitivityMultiplier = 1 - (sensitivity - 1) / 25; // 1.0 a 0.24
            const globalThreshold = baseThreshold * sensitivityMultiplier;

            // Ventana para threshold adaptativo local
            const localWindowMs = 100; // 100ms
            const localWindowFrames = Math.floor(localWindowMs * sampleRate / (hopSize * 1000));

            const beats = [];
            let lastBeatTime = -minInterval;

            for (let i = 2; i < numFrames - 2; i++) {
                const time = (i * hopSize) / sampleRate;

                // Solo detectar dentro del rango de trim
                if (time < beatSyncConfig.trimStart || time > beatSyncConfig.trimEnd) continue;

                const val = smoothed[i];

                // Verificar que es un pico local (mayor que vecinos inmediatos)
                const isPeak = val > smoothed[i-1] && val > smoothed[i+1];
                if (!isPeak) continue;

                // Calcular threshold local adaptativo
                let localSum = 0;
                let localCount = 0;
                for (let j = Math.max(0, i - localWindowFrames); j < Math.min(numFrames, i + localWindowFrames); j++) {
                    if (j !== i) {
                        localSum += smoothed[j];
                        localCount++;
                    }
                }
                const localMean = localSum / localCount;

                // Threshold: combinar global + local
                // Con alta sensibilidad, el threshold local tiene menos peso
                const localWeight = 0.3 + (20 - sensitivity) * 0.035; // 0.3 a 0.965
                const threshold = globalThreshold + localMean * localWeight;

                // Verificar prominencia (el pico debe destacar)
                const neighborAvg = (smoothed[i-1] + smoothed[i+1]) / 2;
                const prominence = val - neighborAvg;
                // Con sharpnessParam bajo, requerimos menos prominencia
                const minProminence = 0.01 + (sharpnessParam - 1) * 0.005; // 0.01 a 0.055

                if (val > threshold && prominence > minProminence && (time - lastBeatTime) >= minInterval) {
                    beats.push(time);
                    lastBeatTime = time;
                }
            }

            // Si detectamos muy pocos beats, bajar el threshold y reintentar
            if (beats.length < 5 && sensitivity >= 10) {
                beats.length = 0;
                lastBeatTime = -minInterval;
                const emergencyThreshold = globalThreshold * 0.3;

                for (let i = 2; i < numFrames - 2; i++) {
                    const time = (i * hopSize) / sampleRate;
                    if (time < beatSyncConfig.trimStart || time > beatSyncConfig.trimEnd) continue;

                    const val = smoothed[i];
                    const isPeak = val > smoothed[i-1] && val > smoothed[i+1];

                    if (isPeak && val > emergencyThreshold && (time - lastBeatTime) >= minInterval) {
                        beats.push(time);
                        lastBeatTime = time;
                    }
                }
            }

            // Último recurso: beats automáticos
            if (beats.length < 3) {
                const duration = beatSyncConfig.trimEnd - beatSyncConfig.trimStart;
                const interval = Math.max(minInterval, duration / 10);
                for (let t = beatSyncConfig.trimStart; t < beatSyncConfig.trimEnd; t += interval) {
                    beats.push(t);
                }
            }

            beatSyncConfig.beats = beats;

            // Actualizar UI con animación
            const beatsCountEl = document.getElementById('beatsyncBeatsCount');
            if (beatsCountEl) beatsCountEl.textContent = beats.length;

            const cutterBeatsEl = document.getElementById('beatsyncCutterBeats');
            if (cutterBeatsEl) cutterBeatsEl.textContent = beats.length + ' beats';

            // Animar el dot para feedback visual
            const beatDot = document.getElementById('beatsyncBeatDot');
            if (beatDot) {
                beatDot.classList.remove('active');
                void beatDot.offsetWidth; // Forzar reflow para reiniciar animación
                beatDot.classList.add('active');
            }

            return beats;
        }

        // ========================================
        // FFT Radix-2 (Cooley-Tukey) - OPTIMIZADO con Twiddle Factors
        // ========================================
        function computeFFTMagnitude(signal) {
            const n = signal.length;
            const numBins = n / 2;

            // Copiar señal a arrays de partes real e imaginaria
            const real = new Float32Array(n);
            const imag = new Float32Array(n);
            for (let i = 0; i < n; i++) {
                real[i] = signal[i];
                imag[i] = 0;
            }

            // Bit-reversal permutation (precalcular si es posible)
            let j = 0;
            for (let i = 0; i < n - 1; i++) {
                if (i < j) {
                    let temp = real[i];
                    real[i] = real[j];
                    real[j] = temp;
                    temp = imag[i];
                    imag[i] = imag[j];
                    imag[j] = temp;
                }
                let k = n >> 1;
                while (k <= j) {
                    j -= k;
                    k >>= 1;
                }
                j += k;
            }

            // Cooley-Tukey FFT con twiddle factors precalculados
            const twiddleCos = beatSyncConfig.fftTwiddleFactors?.cos;
            const twiddleSin = beatSyncConfig.fftTwiddleFactors?.sin;
            const hasTwiddle = twiddleCos && twiddleSin && n === beatSyncConfig.fftSize;

            for (let len = 2; len <= n; len <<= 1) {
                const halfLen = len >> 1;
                const tableStep = n / len; // Paso en tabla de twiddle

                for (let i = 0; i < n; i += len) {
                    for (let k = 0; k < halfLen; k++) {
                        const idx1 = i + k;
                        const idx2 = i + k + halfLen;

                        // Usar twiddle factors precalculados si están disponibles
                        let cos, sin;
                        if (hasTwiddle) {
                            const twiddleIdx = k * tableStep;
                            cos = twiddleCos[twiddleIdx % (n / 2)];
                            sin = twiddleSin[twiddleIdx % (n / 2)];
                        } else {
                            const theta = -2 * Math.PI * k / len;
                            cos = Math.cos(theta);
                            sin = Math.sin(theta);
                        }

                        const tReal = real[idx2] * cos - imag[idx2] * sin;
                        const tImag = real[idx2] * sin + imag[idx2] * cos;

                        real[idx2] = real[idx1] - tReal;
                        imag[idx2] = imag[idx1] - tImag;
                        real[idx1] = real[idx1] + tReal;
                        imag[idx1] = imag[idx1] + tImag;
                    }
                }
            }

            // Calcular magnitud
            const magnitude = new Float32Array(numBins);
            for (let i = 0; i < numBins; i++) {
                magnitude[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / n;
            }

            return magnitude;
        }

        // Aplicar filtro de paso bajo para detectar solo bajos
        async function applyLowPassFilter(buffer, cutoffFreq) {
            const offlineCtx = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;

            const filter = offlineCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = cutoffFreq;
            filter.Q.value = 1;

            source.connect(filter);
            filter.connect(offlineCtx.destination);
            source.start();

            const filteredBuffer = await offlineCtx.startRendering();
            return filteredBuffer.getChannelData(0);
        }

        // Manejar subida de fotos - Procesamiento en servidor para evitar problemas de memoria
        async function handleBeatSyncPhotos(event) {
            const files = Array.from(event.target.files);
            if (!files.length) return;

            // Límite de fotos: 50 en iOS/móvil, 200 en PC
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isMobile = isIOS || /Android/i.test(navigator.userAgent);
            const MAX_PHOTOS = isMobile ? 50 : 200;
            const currentPhotos = beatSyncConfig.photos.length;
            const availableSlots = MAX_PHOTOS - currentPhotos;

            // Verificar límite
            if (availableSlots <= 0) {
                const mensaje = isMobile
                    ? `Máximo ${MAX_PHOTOS} fotos en móvil para evitar problemas de memoria`
                    : `Máximo ${MAX_PHOTOS} fotos permitidas`;
                mostrarToastExito(mensaje);
                logErrorToBackend('warning', `BeatSync: Usuario intentó agregar fotos pero ya tiene ${currentPhotos}/${MAX_PHOTOS} (${isMobile ? 'móvil' : 'PC'})`);
                event.target.value = '';
                return;
            }

            // Limitar archivos si exceden el máximo
            let filesToProcess = files;
            if (files.length > availableSlots) {
                filesToProcess = files.slice(0, availableSlots);
                mostrarToastExito(`Solo se cargarán ${availableSlots} fotos (máximo ${MAX_PHOTOS} total)`);
                logErrorToBackend('info', `BeatSync: Limitando de ${files.length} a ${availableSlots} fotos`);
            }

            const progressEl = document.getElementById('beatsyncProgress');
            const headerProgressEl = document.getElementById('beatsyncHeaderProgress');
            const totalFiles = filesToProcess.length;

            // Mostrar indicador de progreso
            if (progressEl) {
                progressEl.classList.add('active');
            if (headerProgressEl) headerProgressEl.classList.add('active');
                updateBeatSyncProgress(5, `Subiendo ${totalFiles} fotos al servidor...`);
            }

            try {
                // Subir en lotes pequeños para iOS (5 en lugar de 10)
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const BATCH_SIZE = isIOS ? 5 : 10;
                const allPhotos = [];

                logErrorToBackend('info', `BeatSync: Iniciando carga de ${totalFiles} fotos (lotes de ${BATCH_SIZE}, iOS: ${isIOS})`);

                for (let i = 0; i < filesToProcess.length; i += BATCH_SIZE) {
                    const batch = filesToProcess.slice(i, i + BATCH_SIZE);

                    // En iOS, dar tiempo al garbage collector entre lotes
                    if (isIOS && i > 0) {
                        await new Promise(r => setTimeout(r, 100));
                    }

                    // Crear FormData para este lote
                    const formData = new FormData();
                    batch.forEach(file => {
                        // Filtrar solo imágenes
                        const isImage = file.type.startsWith('image/');
                        const isHeic = file.name.toLowerCase().endsWith('.heic') ||
                                      file.name.toLowerCase().endsWith('.heif');
                        if (isImage || isHeic) {
                            formData.append('fotos', file);
                        }
                    });

                    // Actualizar progreso
                    const uploadPercent = Math.round(((i + batch.length) / totalFiles) * 40) + 10;
                    if (progressEl) {
                        updateBeatSyncProgress(uploadPercent, `Subiendo fotos... ${i + batch.length}/${totalFiles}`);
                    }

                    // Enviar al servidor
                    const response = await fetch('/Stories/ProcesarFotosBeatSync', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error('Error del servidor: ' + response.status);
                    }

                    const result = await response.json();

                    if (result.success && result.fotos) {
                        // Agregar URLs de fotos procesadas
                        result.fotos.forEach(url => {
                            allPhotos.push({
                                src: url,
                                isServerUrl: true // Marcar que es URL del servidor
                            });
                        });
                    }

                    // Actualizar progreso de procesamiento
                    const processPercent = Math.round(((i + batch.length) / totalFiles) * 40) + 50;
                    if (progressEl) {
                        updateBeatSyncProgress(processPercent, `Procesando... ${allPhotos.length} fotos listas`);
                    }
                }

                if (!allPhotos.length) {
                    if (progressEl) progressEl.classList.remove('active');
            if (headerProgressEl) headerProgressEl.classList.remove('active');
                    alert('No se pudieron procesar las fotos. Verifica que sean imágenes válidas.');
                    return;
                }

                // Agregar fotos al config
                beatSyncConfig.photos.push(...allPhotos);

                // Invalidar caché de imágenes
                beatSyncConfig.imagesCacheValid = false;
                beatSyncConfig.cachedImages = [];

                // Actualizar UI
                if (progressEl) {
                    updateBeatSyncProgress(95, 'Renderizando miniaturas...');
                }

                // Renderizar con un pequeño delay para que el UI se actualice
                await new Promise(r => setTimeout(r, 100));
                renderBeatSyncPhotos();
                checkBeatSyncReady();

                if (progressEl) progressEl.classList.remove('active');
            if (headerProgressEl) headerProgressEl.classList.remove('active');

            } catch (error) {
                console.error('Error cargando fotos:', error);
                logErrorToBackend('error', `BeatSync: Error cargando fotos - ${error.message}`, error.stack);
                if (progressEl) progressEl.classList.remove('active');
                if (headerProgressEl) headerProgressEl.classList.remove('active');
                mostrarToastExito('Error al cargar fotos. Intenta con menos imágenes.');
            }

            // Reset input para permitir seleccionar los mismos archivos
            event.target.value = '';

            // En iOS, forzar limpieza de memoria
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                await new Promise(r => setTimeout(r, 200));
            }
        }

        // Renderizar fotos subidas - Optimizado para iOS
        function renderBeatSyncPhotos() {
            const photos = beatSyncConfig.photos;
            const container = document.getElementById('beatsyncPhotosUpload');
            const grid = document.getElementById('beatsyncPhotosGrid');
            const info = document.getElementById('beatsyncPhotosInfo');
            const countLabel = document.getElementById('beatsyncPhotosCountLabel');

            countLabel.textContent = photos.length;

            if (photos.length === 0) {
                container.style.display = 'block';
                grid.style.display = 'none';
                info.style.display = 'none';
                return;
            }

            container.style.display = 'none';
            grid.style.display = 'grid';
            info.style.display = 'block';

            // En móvil, limitar las miniaturas visibles para ahorrar memoria
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isMobile = isIOS || /Android/i.test(navigator.userAgent);
            const MAX_VISIBLE_THUMBS = isMobile ? 20 : 100;
            const showAll = photos.length <= MAX_VISIBLE_THUMBS;

            if (showAll) {
                // Mostrar todas las fotos
                grid.innerHTML = photos.map((photo, idx) => `
                    <div class="beatsync-photo-item" draggable="true" data-index="${idx}">
                        <img src="${photo.src}" alt="Foto ${idx + 1}" loading="lazy" decoding="async">
                        <span class="photo-number">${idx + 1}</span>
                        <button class="photo-remove" onclick="removeBeatSyncPhoto(${idx})">&times;</button>
                    </div>
                `).join('') + `
                    <div class="beatsync-add-more" onclick="document.getElementById('beatsyncPhotosInput').click()">+</div>
                `;
            } else {
                // Mostrar solo las primeras + indicador de "más fotos"
                const visiblePhotos = photos.slice(0, MAX_VISIBLE_THUMBS);
                const hiddenCount = photos.length - MAX_VISIBLE_THUMBS;

                grid.innerHTML = visiblePhotos.map((photo, idx) => `
                    <div class="beatsync-photo-item" draggable="true" data-index="${idx}">
                        <img src="${photo.src}" alt="Foto ${idx + 1}" loading="lazy" decoding="async">
                        <span class="photo-number">${idx + 1}</span>
                        <button class="photo-remove" onclick="removeBeatSyncPhoto(${idx})">&times;</button>
                    </div>
                `).join('') + `
                    <div class="beatsync-photo-item beatsync-more-photos" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; cursor: default;">
                        +${hiddenCount} más
                    </div>
                    <div class="beatsync-add-more" onclick="document.getElementById('beatsyncPhotosInput').click()">+</div>
                `;
            }

            // Setup drag and drop
            setupPhotoDragDrop();
        }

        // Eliminar foto
        function removeBeatSyncPhoto(index) {
            // Liberar objectURL de la foto eliminada (solo si es local, no URL del servidor)
            const photo = beatSyncConfig.photos[index];
            if (photo && photo.isObjectUrl && photo.src && !photo.isServerUrl) {
                try {
                    URL.revokeObjectURL(photo.src);
                } catch (e) {}
            }

            beatSyncConfig.photos.splice(index, 1);

            // Liberar ImageBitmaps cacheados antes de invalidar
            if (beatSyncConfig.cachedImages && beatSyncConfig.cachedImages.length > 0) {
                beatSyncConfig.cachedImages.forEach(img => {
                    if (img && typeof img.close === 'function') {
                        img.close();
                    }
                });
            }

            // Invalidar caché de imágenes
            beatSyncConfig.imagesCacheValid = false;
            beatSyncConfig.cachedImages = [];
            renderBeatSyncPhotos();
            checkBeatSyncReady();
        }

        // Mezclar fotos aleatoriamente
        function shuffleBeatSyncPhotos() {
            if (beatSyncConfig.photos.length < 2) return;

            // Algoritmo Fisher-Yates para shuffle
            const photos = beatSyncConfig.photos;
            for (let i = photos.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [photos[i], photos[j]] = [photos[j], photos[i]];
            }

            // Invalidar caché (orden cambió)
            beatSyncConfig.imagesCacheValid = false;
            renderBeatSyncPhotos();
        }

        // Setup drag and drop para reordenar
        function setupPhotoDragDrop() {
            const grid = document.getElementById('beatsyncPhotosGrid');
            const items = grid.querySelectorAll('.beatsync-photo-item');

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', item.dataset.index);
                    item.style.opacity = '0.5';
                });

                item.addEventListener('dragend', () => {
                    item.style.opacity = '1';
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    item.style.transform = 'scale(1.05)';
                });

                item.addEventListener('dragleave', () => {
                    item.style.transform = '';
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.style.transform = '';

                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = parseInt(item.dataset.index);

                    if (fromIndex !== toIndex) {
                        const photos = beatSyncConfig.photos;
                        const [moved] = photos.splice(fromIndex, 1);
                        photos.splice(toIndex, 0, moved);
                        // Invalidar caché (orden cambió)
                        beatSyncConfig.imagesCacheValid = false;
                        renderBeatSyncPhotos();
                    }
                });
            });
        }

        // Verificar si está listo para generar
        function checkBeatSyncReady() {
            const hasMusic = beatSyncConfig.audioBuffer !== null;
            const hasPhotos = beatSyncConfig.photos.length >= 2;
            const generateBtn = document.getElementById('beatsyncGenerateBtn');
            const previewBtn = document.getElementById('beatsyncPreviewBtn');

            const isReady = hasMusic && hasPhotos;
            generateBtn.disabled = !isReady;
            previewBtn.disabled = !isReady;
        }

        // Actualizar barra de progreso (en el header del panel)
        function updateBeatSyncProgress(percent, text) {
            // Actualizar barra en header del panel
            const headerProgress = document.getElementById('beatsyncHeaderProgress');
            const headerFill = document.getElementById('beatsyncHeaderProgressFill');
            const headerText = document.getElementById('beatsyncHeaderProgressText');

            if (headerFill) headerFill.style.width = percent + '%';
            if (headerText) headerText.textContent = text;

            // También actualizar la barra interna si existe (por compatibilidad)
            const internalFill = document.getElementById('beatsyncProgressFill');
            const internalText = document.getElementById('beatsyncProgressText');
            if (internalFill) internalFill.style.width = percent + '%';
            if (internalText) internalText.textContent = text;
        }

        // Mostrar/ocultar barra de progreso del header
        function showBeatSyncHeaderProgress(show) {
            const headerProgress = document.getElementById('beatsyncHeaderProgress');
            const internalProgress = document.getElementById('beatsyncProgress');

            if (headerProgress) {
                if (show) {
                    headerProgress.classList.add('active');
                } else {
                    headerProgress.classList.remove('active');
                }
            }
            if (internalProgress) {
                if (show) {
                    internalProgress.classList.add('active');
                } else {
                    internalProgress.classList.remove('active');
                }
            }
        }

        // Preview del Beat Sync
        async function previewBeatSync() {
            if (!beatSyncConfig.audioBuffer || beatSyncConfig.photos.length < 2) {
                alert('Necesitas subir música y al menos 2 fotos');
                return;
            }

            // IMPORTANTE: Detener todos los audios antes de preview
            stopAllBeatSyncAudio();

            // Asegurar que AudioContext esté activo (navegadores bloquean autoplay)
            if (beatSyncConfig.audioContext && beatSyncConfig.audioContext.state === 'suspended') {
                await beatSyncConfig.audioContext.resume();
            }

            // Mostrar sección de preview
            document.getElementById('beatsyncPreviewSection').style.display = 'block';

            // Iniciar preview
            startBeatSyncPreview();
        }

        // Iniciar preview animado
        async function startBeatSyncPreview() {
            const previewCanvas = document.getElementById('beatsyncPreviewCanvas');
            if (!previewCanvas) {
                console.error('Canvas de preview no encontrado');
                return;
            }
            const ctx = previewCanvas.getContext('2d');

            // Configurar canvas 9:16
            previewCanvas.width = 360;
            previewCanvas.height = 640;

            const photos = beatSyncConfig.photos;
            const beats = beatSyncConfig.beats;
            const transitionEl = document.getElementById('beatsyncTransition');
            const transition = transitionEl ? transitionEl.value : 'cut';

            // Usar valores de trim
            const trimStart = beatSyncConfig.trimStart || 0;
            const trimEnd = beatSyncConfig.trimEnd || (beatSyncConfig.audioBuffer ? beatSyncConfig.audioBuffer.duration : 30);
            const duration = trimEnd - trimStart;

            console.log('Beat Sync Preview - Duration:', duration, 'Beats:', beats.length, 'Photos:', photos.length);

            // Los beats ya están filtrados al rango de trim, pero los ajustamos relativo al inicio
            let validBeats = beats.map(b => b - trimStart).filter(b => b >= 0 && b <= duration);

            // Si no hay beats detectados, crear beats automáticos
            if (validBeats.length === 0) {
                const interval = Math.max(0.3, duration / Math.max(photos.length, 5));
                for (let t = 0; t < duration; t += interval) {
                    validBeats.push(t);
                }
                console.log('Beats automáticos creados:', validBeats.length);
            }

            // Crear secuencia de fotos para cada beat
            const photoSequence = [];
            let lastPhotoIndex = -1;
            for (let i = 0; i < validBeats.length; i++) {
                if (photos.length === 1) {
                    photoSequence.push(0);
                } else if (i < photos.length) {
                    photoSequence.push(i);
                    lastPhotoIndex = i;
                } else {
                    let randomIndex;
                    let attempts = 0;
                    do {
                        randomIndex = Math.floor(Math.random() * photos.length);
                        attempts++;
                    } while (randomIndex === lastPhotoIndex && photos.length > 1 && attempts < 10);
                    photoSequence.push(randomIndex);
                    lastPhotoIndex = randomIndex;
                }
            }

            console.log('Photo sequence:', photoSequence);

            // Precargar imágenes
            const images = await Promise.all(photos.map((photo, idx) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        console.log('Imagen', idx, 'cargada:', img.width, 'x', img.height);
                        resolve(img);
                    };
                    img.onerror = (e) => {
                        console.error('Error cargando imagen', idx, e);
                        resolve(null);
                    };
                    img.src = photo.src;
                });
            }));

            const validImages = images.filter(img => img !== null);
            if (validImages.length === 0) {
                alert('Error: No se pudieron cargar las imágenes');
                return;
            }

            console.log('Imágenes válidas:', validImages.length);

            // Detener preview anterior si existe
            if (beatSyncConfig.isPlaying) {
                stopBeatSyncPreview();
                await new Promise(r => setTimeout(r, 100));
            }

            // Asegurar AudioContext activo
            if (beatSyncConfig.audioContext.state === 'suspended') {
                await beatSyncConfig.audioContext.resume();
            }

            // Crear source de audio
            const source = beatSyncConfig.audioContext.createBufferSource();
            source.buffer = beatSyncConfig.audioBuffer;
            source.connect(beatSyncConfig.audioContext.destination);

            beatSyncConfig.isPlaying = true;
            beatSyncConfig.audioSource = source;
            beatSyncConfig.currentPhotoIndex = 0;

            const seekOffset = beatSyncConfig.pausedAt || 0;
            const audioStartOffset = trimStart + seekOffset;
            const startTime = beatSyncConfig.audioContext.currentTime;

            console.log('Iniciando audio desde:', audioStartOffset, 'duración:', duration - seekOffset);

            try {
                source.start(0, audioStartOffset, duration - seekOffset);
            } catch (e) {
                console.error('Error iniciando audio:', e);
                beatSyncConfig.isPlaying = false;
                return;
            }

            // Cambiar icono a pause
            const playIcon = document.getElementById('beatsyncPlayIcon');
            if (playIcon) playIcon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';

            // Elementos de UI
            const timelineProgress = document.getElementById('beatsyncTimelineProgress');
            const timeDisplay = document.getElementById('beatsyncTimeDisplay');
            const photoIndicator = document.getElementById('beatsyncPhotoIndicator');
            const beatFlash = document.getElementById('beatsyncBeatFlash');

            // Inicializar sistema de partículas para el preview
            const particleType = beatSyncConfig.particleType;
            const particleIntensity = beatSyncConfig.particleIntensity;
            let particleSystem = null;
            if (particleType && particleType !== 'none') {
                particleSystem = new ParticleSystem(previewCanvas.width, previewCanvas.height);
                beatSyncConfig.particleSystem = particleSystem;
            }

            // Función de animación
            let lastBeatIndex = -1;
            let currentImg = validImages[0]; // Imagen actual para redibujar con partículas

            function animate() {
                if (!beatSyncConfig.isPlaying) return;

                const currentTime = seekOffset + (beatSyncConfig.audioContext.currentTime - startTime);
                beatSyncConfig.currentTime = currentTime;

                if (currentTime >= duration) {
                    stopBeatSyncPreview();
                    return;
                }

                // Actualizar timeline progress
                const progressPercent = (currentTime / duration) * 100;
                if (timelineProgress) timelineProgress.style.width = `${progressPercent}%`;

                // Actualizar tiempo
                if (timeDisplay) timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;

                // Encontrar el beat actual
                let currentBeatIndex = 0;
                for (let i = 0; i < validBeats.length; i++) {
                    if (validBeats[i] <= currentTime) {
                        currentBeatIndex = i;
                    } else {
                        break;
                    }
                }

                // Cambiar imagen en cada beat usando la secuencia pre-calculada
                const photoIndex = photoSequence[currentBeatIndex] || 0;

                if (currentBeatIndex !== lastBeatIndex) {
                    lastBeatIndex = currentBeatIndex;

                    // Usar la imagen correspondiente (validar que exista)
                    currentImg = validImages[photoIndex % validImages.length];
                    drawPhotoWithTransition(ctx, currentImg, previewCanvas.width, previewCanvas.height, transition);

                    // Actualizar indicador de foto
                    if (photoIndicator) photoIndicator.textContent = `${(photoIndex % photos.length) + 1} / ${photos.length}`;

                    // Mostrar flash de beat
                    if (beatFlash && currentBeatIndex > 0) {
                        beatFlash.style.opacity = '1';
                        setTimeout(() => {
                            beatFlash.style.opacity = '0';
                        }, 100);
                    }

                    // Emitir partículas en el beat
                    if (particleSystem && currentBeatIndex > 0) {
                        particleSystem.emitOnBeat(particleType, particleIntensity, currentTime);
                    }
                }

                // Actualizar y dibujar partículas
                if (particleSystem && particleSystem.count > 0) {
                    // Redibujar imagen de fondo
                    drawPhotoWithTransition(ctx, currentImg, previewCanvas.width, previewCanvas.height, 'cut');
                    // Actualizar y dibujar partículas
                    particleSystem.update();
                    particleSystem.draw(ctx);
                }

                beatSyncConfig.previewAnimationId = requestAnimationFrame(animate);
            }

            // Determinar el índice inicial basado en el tiempo de inicio
            let initialBeatIndex = 0;
            for (let i = 0; i < validBeats.length; i++) {
                if (validBeats[i] <= seekOffset) {
                    initialBeatIndex = i;
                } else {
                    break;
                }
            }
            const initialPhotoIndex = photoSequence[initialBeatIndex] || 0;

            // Dibujar imagen inicial
            const initialImg = validImages[initialPhotoIndex % validImages.length];
            drawPhotoWithTransition(ctx, initialImg, previewCanvas.width, previewCanvas.height, 'cut');

            // Actualizar indicador de foto inicial
            if (photoIndicator) photoIndicator.textContent = `${(initialPhotoIndex % photos.length) + 1} / ${photos.length}`;

            // Iniciar UI
            if (timeDisplay) timeDisplay.textContent = `${formatTime(seekOffset)} / ${formatTime(duration)}`;
            if (timelineProgress) timelineProgress.style.width = `${(seekOffset / duration) * 100}%`;

            animate();

            // Detener cuando termine
            source.onended = () => {
                stopBeatSyncPreview();
            };

            beatSyncConfig.audioSource = source;
            beatSyncConfig.pausedAt = 0; // Reset para la próxima vez
        }

        // Dibujar foto con transición
        function drawPhotoWithTransition(ctx, img, width, height, transition) {
            // Configurar calidad
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Calcular dimensiones para cover (usar naturalWidth/Height para proporción real)
            const imgRatio = (img.naturalWidth || img.width) / (img.naturalHeight || img.height);
            const canvasRatio = width / height;

            let drawWidth, drawHeight, drawX, drawY;

            if (imgRatio > canvasRatio) {
                drawHeight = height;
                drawWidth = height * imgRatio;
                drawX = (width - drawWidth) / 2;
                drawY = 0;
            } else {
                drawWidth = width;
                drawHeight = width / imgRatio;
                drawX = 0;
                drawY = (height - drawHeight) / 2;
            }

            // Aplicar transición
            switch (transition) {
                case 'fade':
                    ctx.globalAlpha = 0;
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    let fadeAlpha = 0;
                    const fadeIn = setInterval(() => {
                        fadeAlpha += 0.1;
                        ctx.globalAlpha = fadeAlpha;
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        if (fadeAlpha >= 1) {
                            clearInterval(fadeIn);
                            ctx.globalAlpha = 1;
                        }
                    }, 20);
                    break;

                case 'flash':
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, width, height);
                    setTimeout(() => {
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    }, 50);
                    break;

                case 'zoom':
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    let scale = 1.2;
                    const zoomIn = setInterval(() => {
                        scale -= 0.02;
                        ctx.clearRect(0, 0, width, height);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, width, height);

                        const zoomWidth = drawWidth * scale;
                        const zoomHeight = drawHeight * scale;
                        const zoomX = drawX - (zoomWidth - drawWidth) / 2;
                        const zoomY = drawY - (zoomHeight - drawHeight) / 2;

                        ctx.drawImage(img, zoomX, zoomY, zoomWidth, zoomHeight);

                        if (scale <= 1) {
                            clearInterval(zoomIn);
                        }
                    }, 20);
                    break;

                case 'zoom-out':
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    let scaleOut = 0.8;
                    const zoomOut = setInterval(() => {
                        scaleOut += 0.02;
                        ctx.clearRect(0, 0, width, height);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, width, height);

                        const zoomWidth = drawWidth * scaleOut;
                        const zoomHeight = drawHeight * scaleOut;
                        const zoomX = drawX - (zoomWidth - drawWidth) / 2;
                        const zoomY = drawY - (zoomHeight - drawHeight) / 2;

                        ctx.drawImage(img, zoomX, zoomY, zoomWidth, zoomHeight);

                        if (scaleOut >= 1) {
                            clearInterval(zoomOut);
                        }
                    }, 20);
                    break;

                case 'slide':
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    let slideX = width;
                    const slideIn = setInterval(() => {
                        slideX -= width / 10;
                        ctx.clearRect(0, 0, width, height);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(img, drawX + slideX, drawY, drawWidth, drawHeight);
                        if (slideX <= 0) {
                            clearInterval(slideIn);
                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        }
                    }, 20);
                    break;

                case 'wipe-left':
                    ctx.clearRect(0, 0, width, height);
                    let wipeL = 0;
                    const wipeLeft = setInterval(() => {
                        wipeL += width / 10;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, wipeL, height);
                        ctx.clip();
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.restore();
                        if (wipeL >= width) {
                            clearInterval(wipeLeft);
                        }
                    }, 20);
                    break;

                case 'wipe-right':
                    ctx.clearRect(0, 0, width, height);
                    let wipeR = 0;
                    const wipeRight = setInterval(() => {
                        wipeR += width / 10;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(width - wipeR, 0, wipeR, height);
                        ctx.clip();
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.restore();
                        if (wipeR >= width) {
                            clearInterval(wipeRight);
                        }
                    }, 20);
                    break;

                case 'wipe-up':
                    ctx.clearRect(0, 0, width, height);
                    let wipeU = 0;
                    const wipeUp = setInterval(() => {
                        wipeU += height / 10;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, height - wipeU, width, wipeU);
                        ctx.clip();
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.restore();
                        if (wipeU >= height) {
                            clearInterval(wipeUp);
                        }
                    }, 20);
                    break;

                case 'wipe-down':
                    ctx.clearRect(0, 0, width, height);
                    let wipeD = 0;
                    const wipeDown = setInterval(() => {
                        wipeD += height / 10;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, width, wipeD);
                        ctx.clip();
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.restore();
                        if (wipeD >= height) {
                            clearInterval(wipeDown);
                        }
                    }, 20);
                    break;

                case 'spin':
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    let spinAngle = Math.PI;
                    let spinScale = 0;
                    const spinIn = setInterval(() => {
                        spinAngle -= Math.PI / 10;
                        spinScale += 0.1;
                        ctx.clearRect(0, 0, width, height);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, width, height);

                        ctx.save();
                        ctx.translate(width / 2, height / 2);
                        ctx.rotate(spinAngle);
                        ctx.scale(spinScale, spinScale);
                        ctx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                        ctx.restore();

                        if (spinScale >= 1) {
                            clearInterval(spinIn);
                            ctx.clearRect(0, 0, width, height);
                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        }
                    }, 25);
                    break;

                case 'pixelize':
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    let pixelSize = 40;
                    const pixelIn = setInterval(() => {
                        pixelSize -= 4;
                        ctx.clearRect(0, 0, width, height);

                        // Dibujar pixelado
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width / Math.max(pixelSize, 1);
                        tempCanvas.height = height / Math.max(pixelSize, 1);
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(tempCanvas, 0, 0, width, height);
                        ctx.imageSmoothingEnabled = true;

                        if (pixelSize <= 1) {
                            clearInterval(pixelIn);
                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        }
                    }, 30);
                    break;

                case 'blur':
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);

                    let blurAmount = 20;
                    const blurIn = setInterval(() => {
                        blurAmount -= 2;
                        ctx.clearRect(0, 0, width, height);
                        ctx.filter = `blur(${Math.max(blurAmount, 0)}px)`;
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        ctx.filter = 'none';

                        if (blurAmount <= 0) {
                            clearInterval(blurIn);
                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        }
                    }, 25);
                    break;

                case 'glitch':
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    let glitchCount = 0;
                    const glitchEffect = setInterval(() => {
                        glitchCount++;
                        ctx.clearRect(0, 0, width, height);

                        // Efecto RGB shift
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

                        // Red channel offset
                        ctx.globalCompositeOperation = 'multiply';
                        ctx.fillStyle = 'cyan';
                        ctx.fillRect(0, 0, width, height);

                        ctx.globalCompositeOperation = 'source-over';
                        ctx.globalAlpha = 0.5;
                        ctx.drawImage(img, drawX + (Math.random() - 0.5) * 10, drawY, drawWidth, drawHeight);
                        ctx.globalAlpha = 1;

                        if (glitchCount >= 5) {
                            clearInterval(glitchEffect);
                            ctx.globalCompositeOperation = 'source-over';
                            ctx.clearRect(0, 0, width, height);
                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        }
                    }, 50);
                    break;

                case 'shake':
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

                    let shakeCount = 0;
                    const shakeEffect = setInterval(() => {
                        shakeCount++;
                        const offsetX = (Math.random() - 0.5) * 20;
                        const offsetY = (Math.random() - 0.5) * 20;

                        ctx.clearRect(0, 0, width, height);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(img, drawX + offsetX, drawY + offsetY, drawWidth, drawHeight);

                        if (shakeCount >= 6) {
                            clearInterval(shakeEffect);
                            ctx.clearRect(0, 0, width, height);
                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        }
                    }, 30);
                    break;

                default:
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            }
        }

        // Toggle preview play/pause
        function toggleBeatSyncPreview() {
            if (beatSyncConfig.isPlaying) {
                stopBeatSyncPreview();
            } else {
                startBeatSyncPreview();
            }
        }

        // Detener preview
        // ========================================
        // FUNCIÓN CENTRAL: DETENER TODOS LOS AUDIOS DE BEATSYNC
        // ========================================
        function stopAllBeatSyncAudio() {
            // 1. Detener cutter playback
            if (beatSyncConfig.cutterPlaying) {
                beatSyncConfig.cutterPlaying = false;
                if (beatSyncConfig.audioPlayer) {
                    try {
                        beatSyncConfig.audioPlayer.pause();
                        beatSyncConfig.audioPlayer.ontimeupdate = null;
                        beatSyncConfig.audioPlayer.onended = null;
                        beatSyncConfig.audioPlayer.onerror = null;
                        beatSyncConfig.audioPlayer.oncanplay = null;
                    } catch(e) {}
                }
                if (beatSyncConfig.cutterAnimationId) {
                    cancelAnimationFrame(beatSyncConfig.cutterAnimationId);
                    beatSyncConfig.cutterAnimationId = null;
                }
                document.getElementById('beatsyncCutterPlayBtn')?.classList.remove('playing');
                document.getElementById('beatsyncCutterPlayhead')?.classList.remove('active');
            }

            // 2. Detener preview playback
            if (beatSyncConfig.isPlaying) {
                beatSyncConfig.isPlaying = false;
                beatSyncConfig.isPaused = false;
                if (beatSyncConfig.previewAnimationId) {
                    cancelAnimationFrame(beatSyncConfig.previewAnimationId);
                    beatSyncConfig.previewAnimationId = null;
                }
                if (beatSyncConfig.audioSource) {
                    try { beatSyncConfig.audioSource.stop(); } catch(e) {}
                    beatSyncConfig.audioSource = null;
                }
            }

            // 3. Detener cualquier source legacy
            if (beatSyncConfig.cutterSource) {
                try { beatSyncConfig.cutterSource.stop(); } catch(e) {}
                beatSyncConfig.cutterSource = null;
            }

            // 4. Detener preview track de biblioteca
            if (musicLibraryPreviewAudio) {
                try {
                    musicLibraryPreviewAudio.pause();
                    musicLibraryPreviewAudio.src = '';
                } catch(e) {}
                musicLibraryPreviewAudio = null;
                document.querySelectorAll('.beatsync-track').forEach(t => {
                    t.classList.remove('playing');
                    t.classList.remove('loading');
                });
            }

            console.log('[BeatSync] Todos los audios detenidos');
        }

        function stopBeatSyncPreview() {
            beatSyncConfig.isPlaying = false;
            beatSyncConfig.isPaused = false;
            beatSyncConfig.currentTime = 0;
            beatSyncConfig.pausedAt = 0;

            if (beatSyncConfig.previewAnimationId) {
                cancelAnimationFrame(beatSyncConfig.previewAnimationId);
                beatSyncConfig.previewAnimationId = null;
            }

            if (beatSyncConfig.audioSource) {
                try {
                    beatSyncConfig.audioSource.stop();
                } catch (e) {}
                beatSyncConfig.audioSource = null;
            }

            // Cambiar icono a play
            const playIcon = document.getElementById('beatsyncPlayIcon');
            if (playIcon) playIcon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3"/>';

            // Resetear UI
            const timelineProgress = document.getElementById('beatsyncTimelineProgress');
            if (timelineProgress) timelineProgress.style.width = '0%';

            const timeDisplay = document.getElementById('beatsyncTimeDisplay');
            const duration = beatSyncConfig.audioBuffer ? beatSyncConfig.audioBuffer.duration : 0;
            if (timeDisplay) timeDisplay.textContent = `0:00 / ${formatTime(duration)}`;

            const photoIndicator = document.getElementById('beatsyncPhotoIndicator');
            if (photoIndicator) photoIndicator.textContent = `1 / ${beatSyncConfig.photos.length}`;

            // Ocultar flash
            const beatFlash = document.getElementById('beatsyncBeatFlash');
            if (beatFlash) beatFlash.style.opacity = '0';
        }

        // Liberar memoria de fotos después de generar video (las fotos ya están en el video)
        function liberarMemoriaFotosPostGeneracion() {
            const photosCount = beatSyncConfig.photos?.length || 0;
            const cachedCount = beatSyncConfig.cachedImages?.length || 0;

            if (photosCount === 0 && cachedCount === 0) return;

            console.log(`[BeatSync] Liberando memoria: ${photosCount} fotos, ${cachedCount} imágenes cacheadas`);

            // 1. Cerrar ImageBitmaps cacheados (liberan memoria GPU)
            if (beatSyncConfig.cachedImages && beatSyncConfig.cachedImages.length > 0) {
                beatSyncConfig.cachedImages.forEach(img => {
                    if (img && typeof img.close === 'function') {
                        try { img.close(); } catch (e) {}
                    }
                });
                beatSyncConfig.cachedImages = [];
                beatSyncConfig.imagesCacheValid = false;
            }

            // 2. Revocar Object URLs de las fotos (libera blobs en memoria)
            if (beatSyncConfig.photos && beatSyncConfig.photos.length > 0) {
                beatSyncConfig.photos.forEach(photo => {
                    if (photo && photo.isObjectUrl && photo.src && !photo.isServerUrl) {
                        try { URL.revokeObjectURL(photo.src); } catch (e) {}
                    }
                });
                beatSyncConfig.photos = [];
            }

            // 3. Ocultar grid de fotos y mostrar mensaje
            const grid = document.getElementById('beatsyncPhotosGrid');
            const container = document.getElementById('beatsyncPhotosUpload');
            const info = document.getElementById('beatsyncPhotosInfo');

            if (grid) grid.style.display = 'none';
            if (info) info.style.display = 'none';
            if (container) {
                container.style.display = 'block';
                container.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--success);">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="48" height="48" style="margin-bottom: 10px;">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                            <polyline points="22 4 12 14.01 9 11.01"/>
                        </svg>
                        <div style="font-weight: 600;">Video generado</div>
                        <div style="font-size: 12px; color: var(--muted); margin-top: 5px;">
                            Fotos liberadas de memoria
                        </div>
                    </div>
                `;
            }

            // 4. Deshabilitar botones de generar/preview (ya no hay fotos)
            const generateBtn = document.getElementById('beatsyncGenerateBtn');
            const previewBtn = document.getElementById('beatsyncPreviewBtn');
            if (generateBtn) generateBtn.disabled = true;
            if (previewBtn) previewBtn.disabled = true;

            // Forzar garbage collection (sugerencia al navegador)
            if (window.gc) {
                try { window.gc(); } catch (e) {}
            }

            logErrorToBackend('info', `BeatSync: Memoria liberada - ${photosCount} fotos, ${cachedCount} cached`);
        }

        // Limpiar recursos de Beat Sync (llamar al salir del modo)
        function cleanupBeatSyncResources() {
            // Detener cualquier reproducción
            stopBeatSyncPreview();
            stopCutterPlayback();

            // Cerrar ImageBitmaps cacheados para liberar memoria
            if (beatSyncConfig.cachedImages && beatSyncConfig.cachedImages.length > 0) {
                beatSyncConfig.cachedImages.forEach(img => {
                    if (img && typeof img.close === 'function') {
                        img.close(); // ImageBitmap.close() libera memoria
                    }
                });
                beatSyncConfig.cachedImages = [];
                beatSyncConfig.imagesCacheValid = false;
            }

            // Limpiar caché de spectral flux
            beatSyncConfig.spectralFluxCache = null;

            // NO cerrar el AudioContext global, solo limpiar la referencia local
            // El AudioContext global se reutiliza para evitar "failed to start audio device"
            beatSyncConfig.audioContext = null;

            // Limpiar referencias
            beatSyncConfig.audioBuffer = null;
            beatSyncConfig.audioFile = null;
            beatSyncConfig.beats = [];

            // Limpiar audio player persistente completamente al salir
            if (beatSyncConfig.audioPlayer) {
                try {
                    beatSyncConfig.audioPlayer.pause();
                    beatSyncConfig.audioPlayer.src = '';
                    beatSyncConfig.audioPlayer.load(); // Forzar liberación de recursos
                    beatSyncConfig.audioPlayer.ontimeupdate = null;
                    beatSyncConfig.audioPlayer.onended = null;
                    beatSyncConfig.audioPlayer.onerror = null;
                    beatSyncConfig.audioPlayer.oncanplay = null;
                    beatSyncConfig.audioPlayer.oncanplaythrough = null;
                } catch (e) {}
                beatSyncConfig.audioPlayer = null;
                beatSyncConfig.audioPlayerReady = false;
            }

            // Liberar blob URL del audio si existe
            if (beatSyncConfig.audioUrl && beatSyncConfig.audioUrlIsBlob) {
                try {
                    URL.revokeObjectURL(beatSyncConfig.audioUrl);
                } catch (e) {}
            }
            beatSyncConfig.audioUrl = null;
            beatSyncConfig.audioUrlIsBlob = false;

            // Liberar memoria de objectURLs de las fotos (si las hay)
            if (beatSyncConfig.photos && beatSyncConfig.photos.length > 0) {
                beatSyncConfig.photos.forEach(photo => {
                    // Solo revocar URLs de objetos locales, no URLs del servidor
                    if (photo && photo.isObjectUrl && photo.src && !photo.isServerUrl) {
                        try {
                            URL.revokeObjectURL(photo.src);
                        } catch (e) {}
                    }
                });
            }
            beatSyncConfig.photos = [];
            beatSyncConfig.manualBeatsAdded = [];
            beatSyncConfig.manualBeatsRemoved = [];
            beatSyncConfig.beatPositions = [];

            // Limpiar sistema de partículas
            if (beatSyncConfig.particleSystem) {
                beatSyncConfig.particleSystem.clear();
                beatSyncConfig.particleSystem = null;
            }

            // Resetear flags de event listeners para permitir reinicialización
            beatSyncConfig.waveformClicksSetup = false;
            beatSyncConfig.dragHandlesSetup = false;

            console.log('Beat Sync: Recursos liberados');
        }

        // Buscar en timeline
        function seekBeatSyncTimeline(event) {
            if (!beatSyncConfig.audioBuffer) return;

            const timeline = document.getElementById('beatsyncTimeline');
            const rect = timeline.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percent = clickX / rect.width;

            // Usar valores de trim
            const trimStart = beatSyncConfig.trimStart || 0;
            const trimEnd = beatSyncConfig.trimEnd || beatSyncConfig.audioBuffer.duration;
            const duration = trimEnd - trimStart;
            const seekTime = percent * duration;

            // Si está reproduciendo, reiniciar desde la nueva posición
            if (beatSyncConfig.isPlaying) {
                stopBeatSyncPreview();
                beatSyncConfig.pausedAt = seekTime;
                startBeatSyncPreview();
            } else {
                // Solo actualizar el indicador visual
                const timelineProgress = document.getElementById('beatsyncTimelineProgress');
                if (timelineProgress) timelineProgress.style.width = `${percent * 100}%`;

                const timeDisplay = document.getElementById('beatsyncTimeDisplay');
                if (timeDisplay) timeDisplay.textContent = `${formatTime(seekTime)} / ${formatTime(duration)}`;

                beatSyncConfig.pausedAt = seekTime;
            }
        }

        // Generar video final usando MediaRecorder
        async function generateBeatSync() {
            if (!beatSyncConfig.audioBuffer || beatSyncConfig.photos.length < 2) {
                alert('Necesitas subir música y al menos 2 fotos');
                return;
            }

            // Deshabilitar botones mientras genera
            const generateBtn = document.getElementById('beatsyncGenerateBtn');
            const previewBtn = document.getElementById('beatsyncPreviewBtn');
            const originalBtnText = generateBtn ? generateBtn.innerHTML : '';

            if (generateBtn) {
                generateBtn.disabled = true;
                generateBtn.innerHTML = `
                    <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;">
                        <circle cx="12" cy="12" r="10" stroke-dasharray="60" stroke-dashoffset="20"/>
                    </svg>
                    Generando...
                `;
            }
            if (previewBtn) previewBtn.disabled = true;

            console.log('[BeatSync] Iniciando generación de video...');

            // IMPORTANTE: Detener todos los audios antes de generar
            stopAllBeatSyncAudio();

            // Detectar iOS/Safari y verificar compatibilidad
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

            // Verificar soporte de MediaRecorder
            if (typeof MediaRecorder === 'undefined') {
                // Restaurar botones
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = originalBtnText;
                }
                if (previewBtn) previewBtn.disabled = false;

                alert('Tu navegador no soporta la grabación de video.\n\n' +
                      (isIOS ? 'En iOS, necesitas iOS 14.5 o superior.\nPrueba actualizar tu dispositivo o usa un navegador en computadora.' :
                               'Intenta usar Chrome, Firefox o Edge en una computadora.'));
                return;
            }

            // Verificar canvas.captureStream
            const testCanvas = document.createElement('canvas');
            if (typeof testCanvas.captureStream !== 'function') {
                alert('Tu navegador no soporta captura de canvas.\n\n' +
                      (isIOS ? 'En iOS, necesitas iOS 13 o superior.' :
                               'Intenta usar un navegador más reciente.'));
                return;
            }

            const progressEl = document.getElementById('beatsyncProgress');
            const headerProgressEl = document.getElementById('beatsyncHeaderProgress');
            progressEl.classList.add('active');
            if (headerProgressEl) headerProgressEl.classList.add('active');
            updateBeatSyncProgress(0, 'Preparando grabación...');

            try {
                const photos = beatSyncConfig.photos;
                const beats = beatSyncConfig.beats;
                const transitionEl = document.getElementById('beatsyncTransition');
                const transition = transitionEl ? transitionEl.value : 'cut';

                // Usar valores de trim
                const trimStart = beatSyncConfig.trimStart || 0;
                const trimEnd = beatSyncConfig.trimEnd || beatSyncConfig.audioBuffer.duration;
                const duration = trimEnd - trimStart;

                // Preparar beats válidos
                let validBeats = beats.map(b => b - trimStart).filter(b => b >= 0 && b <= duration);
                if (validBeats.length === 0) {
                    const interval = Math.max(0.3, duration / Math.max(photos.length, 5));
                    for (let t = 0; t < duration; t += interval) {
                        validBeats.push(t);
                    }
                }

                // Crear secuencia de fotos
                const photoSequence = [];
                let lastPhotoIndex = -1;
                for (let i = 0; i < validBeats.length; i++) {
                    if (photos.length === 1) {
                        photoSequence.push(0);
                    } else if (i < photos.length) {
                        photoSequence.push(i);
                        lastPhotoIndex = i;
                    } else {
                        let randomIndex;
                        let attempts = 0;
                        do {
                            randomIndex = Math.floor(Math.random() * photos.length);
                            attempts++;
                        } while (randomIndex === lastPhotoIndex && photos.length > 1 && attempts < 10);
                        photoSequence.push(randomIndex);
                        lastPhotoIndex = randomIndex;
                    }
                }

                // Crear canvas para grabación (RESOLUCIÓN ALTA: 1080x1920)
                const recordCanvas = document.createElement('canvas');
                recordCanvas.width = 1080;
                recordCanvas.height = 1920;
                const recordCtx = recordCanvas.getContext('2d', {
                    alpha: false,
                    desynchronized: true // Mejor rendimiento
                });

                // Configurar calidad de renderizado
                recordCtx.imageSmoothingEnabled = true;
                recordCtx.imageSmoothingQuality = 'high';

                // Precargar imágenes con ImageBitmap para renderizado más rápido
                updateBeatSyncProgress(10, 'Cargando imágenes en alta calidad...');

                // Verificar si hay ImageBitmaps cacheados válidos
                const useCache = beatSyncConfig.imagesCacheValid &&
                                 beatSyncConfig.cachedImages.length === photos.length;

                // Función para convertir data URL a Blob (más confiable que fetch)
                const dataURLtoBlob = (dataURL) => {
                    const arr = dataURL.split(',');
                    const mime = arr[0].match(/:(.*?);/)?.[1] || 'image/jpeg';
                    const bstr = atob(arr[1]);
                    const n = bstr.length;
                    const u8arr = new Uint8Array(n);
                    for (let i = 0; i < n; i++) {
                        u8arr[i] = bstr.charCodeAt(i);
                    }
                    return new Blob([u8arr], { type: mime });
                };

                const images = useCache
                    ? beatSyncConfig.cachedImages
                    : await Promise.all(photos.map(async (photo, index) => {
                        try {
                            // Convertir data URL a blob directamente (más confiable que fetch)
                            let blob;
                            if (photo.src.startsWith('data:')) {
                                blob = dataURLtoBlob(photo.src);
                            } else {
                                const response = await fetch(photo.src);
                                blob = await response.blob();
                            }

                            // Crear ImageBitmap (más rápido que Image para canvas)
                            const bitmap = await createImageBitmap(blob, {
                                premultiplyAlpha: 'none',
                                colorSpaceConversion: 'none'
                            });

                            return bitmap;
                        } catch (e) {
                            console.warn(`Error creando ImageBitmap para imagen ${index + 1}:`, e);
                            // Fallback a Image tradicional
                            return new Promise((resolve) => {
                                const img = new Image();
                                img.crossOrigin = 'anonymous';

                                const timeout = setTimeout(() => {
                                    console.warn(`Timeout cargando imagen ${index + 1}`);
                                    resolve(img.complete ? img : null);
                                }, 10000);

                                img.onload = () => {
                                    clearTimeout(timeout);
                                    resolve(img);
                                };

                                img.onerror = () => {
                                    clearTimeout(timeout);
                                    console.error(`Error cargando imagen ${index + 1}`);
                                    resolve(null);
                                };

                                img.src = photo.src;
                            });
                        }
                    }));

                // Cachear las imágenes para uso futuro
                if (!useCache) {
                    beatSyncConfig.cachedImages = images.filter(img => img !== null);
                    beatSyncConfig.imagesCacheValid = true;
                }

                const validImages = images.filter(img => img !== null);
                if (validImages.length === 0) {
                    throw new Error('No se pudieron cargar las imágenes');
                }

                updateBeatSyncProgress(20, 'Configurando grabación HD...');

                // Asegurar AudioContext activo
                if (beatSyncConfig.audioContext.state === 'suspended') {
                    await beatSyncConfig.audioContext.resume();
                }

                // Crear MediaRecorder del canvas (60 FPS para fluidez)
                const targetFPS = 60;
                const canvasStream = recordCanvas.captureStream(targetFPS);

                // Crear audio destination para capturar audio (SIN conectar a altavoces)
                const audioDestination = beatSyncConfig.audioContext.createMediaStreamDestination();
                const audioSource = beatSyncConfig.audioContext.createBufferSource();
                audioSource.buffer = beatSyncConfig.audioBuffer;
                audioSource.connect(audioDestination);
                // NO conectar a destination (altavoces) - solo grabar el audio silenciosamente

                // Combinar streams
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...audioDestination.stream.getAudioTracks()
                ]);

                // Configurar MediaRecorder con ALTA CALIDAD (8 Mbps)
                // Priorizar MP4/H.264 para máxima compatibilidad (iOS/Safari)
                // WebM/VP9 tiene mejor compresión pero NO funciona en Safari
                const codecOptions = [
                    'video/mp4;codecs=avc1.42E01E,mp4a.40.2', // H.264 Baseline + AAC (iOS/Safari ✓)
                    'video/mp4;codecs=avc1.4D401E,mp4a.40.2', // H.264 Main Profile + AAC
                    'video/mp4;codecs=avc1.64001E,mp4a.40.2', // H.264 High Profile + AAC
                    'video/mp4',                              // MP4 genérico
                    'video/webm;codecs=vp9,opus',             // VP9 (fallback si no hay MP4)
                    'video/webm;codecs=vp8,opus',             // VP8 fallback
                    'video/webm'                              // WebM genérico
                ];

                let mimeType = 'video/mp4'; // Default a MP4 para iOS
                let codecFound = false;
                for (const codec of codecOptions) {
                    if (MediaRecorder.isTypeSupported(codec)) {
                        mimeType = codec;
                        codecFound = true;
                        console.log('Codec seleccionado:', codec);
                        break;
                    }
                }

                // Si ningún codec fue encontrado, usar WebM como último recurso
                if (!codecFound) {
                    mimeType = 'video/webm';
                    console.warn('Ningún codec preferido soportado, usando WebM genérico');
                }

                const mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 8000000 // 8 Mbps para alta calidad
                });

                const chunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };

                // Promesa para esperar que termine la grabación
                // IMPORTANTE: Usar el mimeType seleccionado, no hardcodeado
                const recordingComplete = new Promise((resolve, reject) => {
                    mediaRecorder.onstop = () => {
                        // Extraer tipo base del mimeType (sin codecs)
                        const blobType = mimeType.split(';')[0];
                        const blob = new Blob(chunks, { type: blobType });
                        console.log('Video generado con tipo:', blobType);
                        resolve(blob);
                    };
                    mediaRecorder.onerror = (e) => reject(e);
                });

                updateBeatSyncProgress(30, 'Grabando video...');

                // Iniciar grabación
                mediaRecorder.start(100);

                // Inicializar sistema de partículas para generación
                const genParticleType = beatSyncConfig.particleType;
                const genParticleIntensity = beatSyncConfig.particleIntensity;
                let genParticleSystem = null;
                if (genParticleType && genParticleType !== 'none') {
                    genParticleSystem = new ParticleSystem(recordCanvas.width, recordCanvas.height);
                }

                // Dibujar primera imagen
                let lastBeatIndex = -1;
                let currentRecordImg = validImages[photoSequence[0] || 0];
                drawPhotoToCanvas(recordCtx, currentRecordImg, recordCanvas.width, recordCanvas.height);

                // Duración de la pantalla de créditos al final (2 segundos)
                const creditsDuration = 2.0;
                const totalDuration = duration + creditsDuration;
                let creditsStarted = false;

                // Iniciar audio y guardar tiempo de inicio
                const audioStartTime = beatSyncConfig.audioContext.currentTime;
                const recordingStartTime = performance.now(); // Tiempo de inicio independiente
                audioSource.start(0, trimStart, duration);

                // Flag para flash en progreso
                let flashInProgress = false;

                // Usar intervalo fijo para mayor consistencia (60fps = 16.67ms)
                const frameInterval = 1000 / 60;
                let lastFrameTime = performance.now();
                let animationStopped = false;

                function animateRecording() {
                    if (animationStopped) return;

                    const now = performance.now();
                    const deltaFrame = now - lastFrameTime;

                    // Mantener 60fps consistente
                    if (deltaFrame < frameInterval * 0.8) {
                        requestAnimationFrame(animateRecording);
                        return;
                    }
                    lastFrameTime = now;

                    // Usar performance.now() como fuente de tiempo principal
                    // AudioContext puede ser inestable después de que el audio termine
                    const elapsedMs = now - recordingStartTime;
                    const currentTime = elapsedMs / 1000; // Convertir a segundos

                    // Actualizar progreso (incluir créditos en el cálculo)
                    const recordProgress = Math.min(currentTime / totalDuration, 1);
                    updateBeatSyncProgress(30 + Math.floor(recordProgress * 60), `Grabando... ${Math.floor(recordProgress * 100)}%`);

                    // Mostrar pantalla de créditos al final del contenido
                    if (currentTime >= duration && currentTime < totalDuration) {
                        if (!creditsStarted) {
                            creditsStarted = true;
                            console.log('[BeatSync] Iniciando créditos a', currentTime.toFixed(2), 's de', totalDuration.toFixed(2), 's');
                            // Limpiar partículas al entrar a créditos
                            if (genParticleSystem) genParticleSystem.clear();
                        }
                        // Calcular progreso de los créditos (0 a 1)
                        const creditsProgress = (currentTime - duration) / creditsDuration;
                        drawCreditsScreen(recordCtx, recordCanvas.width, recordCanvas.height, creditsProgress);
                        requestAnimationFrame(animateRecording);
                        return;
                    }

                    if (currentTime >= totalDuration) {
                        // Detener grabación (después de créditos)
                        animationStopped = true;
                        mediaRecorder.stop();
                        try { audioSource.stop(); } catch(e) {}
                        return;
                    }

                    // Encontrar beat actual basado en tiempo del audio
                    let currentBeatIndex = 0;
                    for (let i = 0; i < validBeats.length; i++) {
                        if (validBeats[i] <= currentTime) {
                            currentBeatIndex = i;
                        } else {
                            break;
                        }
                    }

                    // Detectar cambio de beat
                    const beatChanged = currentBeatIndex !== lastBeatIndex && !flashInProgress;

                    // Cambiar imagen en cada beat
                    if (beatChanged) {
                        lastBeatIndex = currentBeatIndex;
                        const photoIndex = photoSequence[currentBeatIndex] || 0;
                        currentRecordImg = validImages[photoIndex % validImages.length];

                        // Emitir partículas en el beat
                        if (genParticleSystem && currentBeatIndex > 0) {
                            genParticleSystem.emitOnBeat(genParticleType, genParticleIntensity, currentTime);
                        }

                        // Transición flash: mostrar blanco brevemente
                        if (transition === 'flash') {
                            flashInProgress = true;
                            recordCtx.fillStyle = '#fff';
                            recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
                            // El siguiente frame dibujará la imagen
                            setTimeout(() => { flashInProgress = false; }, 32);
                        }
                    }

                    // SIEMPRE redibujar la imagen actual en cada frame (excepto durante flash)
                    // Esto es CRÍTICO para que MediaRecorder capture frames frescos
                    if (!flashInProgress) {
                        drawPhotoToCanvas(recordCtx, currentRecordImg, recordCanvas.width, recordCanvas.height);
                    }

                    // Actualizar y dibujar partículas encima de la imagen
                    if (genParticleSystem && genParticleSystem.count > 0) {
                        genParticleSystem.update();
                        genParticleSystem.draw(recordCtx);
                    }

                    requestAnimationFrame(animateRecording);
                }

                animateRecording();

                // Esperar a que termine la grabación
                const videoBlob = await recordingComplete;

                updateBeatSyncProgress(95, 'Finalizando...');

                // Crear archivo de video con extensión correcta según codec
                const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';
                const fileType = mimeType.includes('mp4') ? 'video/mp4' : 'video/webm';
                mediaFile = new File([videoBlob], 'beatsync_' + Date.now() + extension, { type: fileType });
                mediaType = 'video';

                // Guardar info del Beat Sync
                beatSyncConfig.generated = true;
                beatSyncConfig.videoBlob = videoBlob;

                // Configurar música (ya está incluida en el video)
                selectedMusic = null; // El audio ya está en el video

                // Mostrar primera imagen en el canvas principal de Fabric
                const firstImg = validImages[0];
                const fabricDataUrl = recordCanvas.toDataURL('image/jpeg', 0.9);

                fabric.Image.fromURL(fabricDataUrl, function(img) {
                    const scale = Math.max(
                        canvas.width / img.width,
                        canvas.height / img.height
                    );
                    img.set({
                        scaleX: scale,
                        scaleY: scale,
                        left: canvas.width / 2,
                        top: canvas.height / 2,
                        originX: 'center',
                        originY: 'center',
                        selectable: false,
                        evented: false
                    });
                    canvas.clear();
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                });

                updateBeatSyncProgress(100, 'Video listo!');
                console.log('[BeatSync] Video generado exitosamente. Formato:', mimeType);
                logErrorToBackend('info', `BeatSync generación exitosa`, JSON.stringify({
                    formato: mimeType,
                    duracion: totalDuration.toFixed(1),
                    photosCount: validImages.length,
                    videoSize: (videoBlob.size / 1024 / 1024).toFixed(2) + 'MB'
                }));

                // Guardar formato usado para referencia
                beatSyncConfig.generatedMimeType = mimeType;

                setTimeout(() => {
                    progressEl.classList.remove('active');
                    if (headerProgressEl) headerProgressEl.classList.remove('active');

                    // Restaurar botones
                    if (generateBtn) {
                        generateBtn.disabled = false;
                        generateBtn.innerHTML = originalBtnText;
                    }
                    if (previewBtn) previewBtn.disabled = false;

                    habilitarBotonPublicar();

                    document.getElementById('uploadOverlay').style.display = 'none';

                    // Mostrar toast no intrusivo en lugar de alert
                    mostrarToastExito(`Video listo (${totalDuration.toFixed(1)}s)`);

                    // En móvil, cerrar panel de opciones pero mantener el video generado
                    if (window.innerWidth <= 768) {
                        console.log('[BeatSync] Cerrando panel en móvil (video ya generado)');
                        cerrarPanelOpciones();
                    }

                    // Liberar memoria de fotos (ya están embebidas en el video)
                    setTimeout(() => {
                        liberarMemoriaFotosPostGeneracion();
                    }, 1000);

                    saveHistory();
                }, 500);

            } catch (error) {
                console.error('[BeatSync] Error generando video:', error);
                logErrorToBackend('error', `BeatSync generación falló: ${error.message}`, error.stack || JSON.stringify({
                    photosCount: beatSyncPhotos?.length || 0,
                    hasAudio: !!beatSyncConfig.audioBuffer,
                    beatCount: beatSyncConfig.beats?.length || 0
                }));
                progressEl.classList.remove('active');
                if (headerProgressEl) headerProgressEl.classList.remove('active');

                // Restaurar botones en caso de error
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = originalBtnText;
                }
                if (previewBtn) previewBtn.disabled = false;

                alert('Error al generar el video: ' + error.message);
            }
        }

        // Dibujar foto en canvas (cover mode) con marca de agua
        // Soporta tanto Image como ImageBitmap
        function drawPhotoToCanvas(ctx, img, width, height, addWatermark = true) {
            // Asegurar calidad alta
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // ImageBitmap usa .width/.height, Image usa .naturalWidth/.naturalHeight
            const imgWidth = img.naturalWidth || img.width;
            const imgHeight = img.naturalHeight || img.height;
            const imgRatio = imgWidth / imgHeight;
            const canvasRatio = width / height;

            let drawWidth, drawHeight, drawX, drawY;

            // Cover mode: la imagen cubre todo el canvas, se recorta si es necesario
            if (imgRatio > canvasRatio) {
                // Imagen más ancha: ajustar por altura
                drawHeight = height;
                drawWidth = height * imgRatio;
                drawX = (width - drawWidth) / 2;
                drawY = 0;
            } else {
                // Imagen más alta: ajustar por ancho
                drawWidth = width;
                drawHeight = width / imgRatio;
                drawX = 0;
                drawY = (height - drawHeight) / 2;
            }

            // Fondo negro
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Dibujar imagen
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

            // Agregar marca de agua
            if (addWatermark) {
                drawWatermark(ctx, width, height);
            }
        }

        // Dibujar marca de agua (OPTIMIZADO - usa canvas pre-renderizado) - VERTICAL IZQUIERDA
        function drawWatermark(ctx, width, height) {
            // Usar watermark pre-renderizado si está disponible y tiene el tamaño correcto
            if (beatSyncConfig.watermarkCanvas &&
                width === 1080 && height === 1920) {
                ctx.drawImage(beatSyncConfig.watermarkCanvas, 0, 0);
                return;
            }

            // Fallback: renderizar dinámicamente para otros tamaños (también vertical izquierda)
            const text = 'Creado con Ladoapp.com';
            const fontSize = Math.round(width * 0.024);

            ctx.save();
            ctx.font = `500 ${fontSize}px 'Poppins', sans-serif`;

            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize;
            const padding = fontSize * 0.4;

            // Posición vertical izquierda (centrado verticalmente)
            const x = width * 0.03;
            const y = height / 2;

            ctx.translate(x, y);
            ctx.rotate(-Math.PI / 2); // Rotar 90° antihorario

            // Fondo semitransparente
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            const bgX = -textWidth / 2 - padding;
            const bgY = -textHeight / 2 - padding / 2;
            const bgWidth = textWidth + padding * 2;
            const bgHeight = textHeight + padding;
            const bgRadius = fontSize * 0.3;

            ctx.beginPath();
            ctx.roundRect(bgX, bgY, bgWidth, bgHeight, bgRadius);
            ctx.fill();

            // Texto centrado
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);

            ctx.restore();
        }

        // Dibujar pantalla de créditos final (estilo CapCut/TikTok)
        function drawCreditsScreen(ctx, width, height, progress = 1) {
            // Fondo negro
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Animación de fade in para el texto
            const alpha = Math.min(1, progress * 2); // Fade in en la primera mitad

            // Texto principal "Creado con"
            const fontSize1 = Math.round(width * 0.045);
            ctx.font = `400 ${fontSize1}px 'Poppins', sans-serif`;
            ctx.fillStyle = `rgba(180, 180, 180, ${alpha * 0.9})`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Creado con', width / 2, height / 2 - fontSize1 * 1.2);

            // Texto principal "LadoApp.Com" (más grande y destacado)
            const fontSize2 = Math.round(width * 0.08);
            ctx.font = `700 ${fontSize2}px 'Poppins', sans-serif`;

            // Gradiente para el texto principal
            const gradient = ctx.createLinearGradient(
                width / 2 - fontSize2 * 3,
                height / 2,
                width / 2 + fontSize2 * 3,
                height / 2
            );
            gradient.addColorStop(0, `rgba(255, 59, 92, ${alpha})`);   // Rosa/rojo
            gradient.addColorStop(0.5, `rgba(255, 107, 107, ${alpha})`); // Rosa claro
            gradient.addColorStop(1, `rgba(255, 59, 92, ${alpha})`);   // Rosa/rojo

            ctx.fillStyle = gradient;
            ctx.fillText('LadoApp.Com', width / 2, height / 2 + fontSize2 * 0.3);

            // Línea decorativa debajo
            const lineWidth = width * 0.3;
            const lineY = height / 2 + fontSize2 * 1.2;
            ctx.strokeStyle = `rgba(255, 59, 92, ${alpha * 0.6})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width / 2 - lineWidth / 2, lineY);
            ctx.lineTo(width / 2 + lineWidth / 2, lineY);
            ctx.stroke();

            // Icono/logo pequeño (nota musical estilizada)
            const iconY = height / 2 + fontSize2 * 2;
            const iconSize = fontSize1 * 0.8;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
            ctx.font = `${iconSize}px Arial`;
            ctx.fillText('♪', width / 2, iconY);
        }
    </script>
</body>
</html>
